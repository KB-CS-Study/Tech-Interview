#  2️⃣:메모리 관리(페이징 & 세그멘테이션) + 가상 메모리

스터디 날짜: 2025/04/02

노션 공개 링크 : https://ebony-homegrown-b56.notion.site/1c0b9140200f80768a13e96ef73333b2?pvs=4

**목차**

- [1. 메모리 관리 기법](#1-메모리-관리-기법)
  - [📕 페이징(Paging)](#-페이징paging)
  - [📕 세그멘테이션](#-세그멘테이션)
- [2. 가상 메모리 개념](#2-가상-메모리-개념)
  - [📘 가상 메모리(Virtual Memory)](#-가상-메모리virtual-memory)
  - [📘 요구 페이징(Demand Paging)](#-요구-페이징demand-paging)
  - [📘 페이지 부재(Page Fault)](#-페이지-부재page-fault)
- [3. 캐시 메모리, TLB](#3-캐시-메모리-tlb)
  - [📗 캐시 메모리(Cache Memory)](#-캐시-메모리cache-memory)
  - [📗 TLB(Translation Lookaside Buffer)](#-tlbtranslation-lookaside-buffer)
- [4. 메모리 할당 전략](#4-메모리-할당-전략)
  - [🍋 First fit (최초 적합)](#-first-fit--최초-적합)
  - [🍋 Best fit (최적 적합)](#-best-fit--최적-적합)
  - [🍋 Worst fit (최악 적합)](#-worst-fit--최악-적합)

<br>

## 1. 메모리 관리 기법

### 📕 페이징(Paging)

- 메모리를 고정된 크기인 **페이지(Page)** 단위로 나누어 관리하는 방식
- 가상 메모리 → 페이지 단위로 분할
- 물리 메모리 → 프레임이라는 동일 크기의 블록으로 분할

**동작 방식**

- 프로세스의 가상 메모리를 페이지 단위로 분할, 이를 물리 메모리의 프레임에 매핑

**페이지 테이블** : 가상 주소의 페이지 번호 → 물리 주소의 프레임 번호 변환

- **프로세스 마다 페이지 테이블 존재**
- **물리 메모리에 저장**
- 페이지 테이블은 매우 커질 수 있음
    - 모든 페이지에 대한 항목 이미 존재

![image](https://github.com/user-attachments/assets/43d6a635-e39f-408d-9025-42a55d030b1f)


**페이지 테이블이 가지는 정보**

- **매핑 정보** : 해당 페이지가 어느 물리 프레임에 올라가 있는지
- **Valid Bit / Present Bit** : 해당 페이지가 현재 메모리에 존재하는지 여부

**장점**

- **외부 단편화 없음**(페이지 크기가 모두 같으므로)
- **유연성** : 메모리 관리가 단순하고 효율적

**단점**

- **내부 단편화 발생 가능**(마지막 페이지가 다 차지 않는 경우)
- **주소 변환 비용**으로 인한 속도 저하 ****→ 이후 TLB로 보완

<br>

### ❓ 페이지 테이블로 인해 처리 속도가 저하되는 이유는?

<aside>
👉🏻

메모리의 데이터를 한 번 읽으려면, 페이지 테이블도 읽어와야 하므로 ⇒ **총 2번 메모리 접근 필요** 
⇒ **성능 저하**

</aside>

![image](https://github.com/user-attachments/assets/4bc8fa3e-ed4d-4685-85bb-d7df56ed5f96)


<br>

### 📕 세그멘테이션

- 메모리를 **논리적인 단위인 세그먼트**로 나누어 관리
- 각 세그먼트를 **물리 메모리의 각기 다른 위치에 배치** 가능
- **세그멘트** : 특정 길이를 가지는 연속적인 주소 공간
    
    (ex, 코드, 데이터, 스택 등)
    

**동작 방식**

- 각 세그먼트의 크기 불일치
- 주소 = (세그먼트 번호, 오프셋) 형태
- 세그먼트 테이블을 통해 실제 물리 주소로 변환

![image](https://github.com/user-attachments/assets/799cfd7a-54e1-4615-a43b-76e0ab61db83)


**장점** 

- **논리적 단위로 관리** → 코드 관리 편리
- **내부 단편화 없음** (가변 길이로 필요한 만큼만 할당하기 때문)

**단점**

- **외부 단편화 발생 (**크기가 다른 세그먼트가 흩어져 할당되기 때문**)**
- **매핑 테이블 복잡** (세그먼트 번호 + 오프셋)

> **외부 단편화** : 전체 사용 가능한 메모리는 충분하지만, 연속된 공간이 없어 메모리를 할당할 수 없는 현상
> 
<br>

### 🚨 페이징 vs 세그멘테이션 비교

![image](https://github.com/user-attachments/assets/e522d8d6-780a-44a3-9f07-c22dddc76a21)



<br>

## 2. 가상 메모리 개념

### 📘 가상 메모리(Virtual Memory)

- 실제 물리 메모리보다 큰 주소 공간을 제공하는 기술
- 물리 메모리를 공유하지만, 프로세스는 자기만의 독립적인 메모리 공간을 갖는 것처럼 보임
- 실제로 쓰는 부분만 메모리에 올려 사용

**가상 메모리의 주요 목표**

1. **투명성(transparency)** : 실행 중인 프로그램이 가상 메모리 존재를 인지하지 못하도록 가상 메모리 시스템 구현
2. **효율성(efficiency)** : 가상화가 시간과 공간 측면에서 효율적이어야 함
3. **보호(protection)** : 하나의 프로세스를 다른 프로세스로부터 보호해야 함

![image](https://github.com/user-attachments/assets/e2542867-65a6-4bf3-afe2-8acaeeec278d)


**가상 주소 공간**

- 프로세스가 사용할 수 있는 가상 메모리의 범위
- 프로그램 입장에서, 자기것처럼 보이는 주소 공간

### 📘 요구 페이징(Demand Paging)

- 실제로 접근한 페이지만 물리 메모리에 적재하는 방식

**동작 방식**

- 프로세스 시작 시, 메모리에 아무것도 올리지 않음
- CPU가 어떤 가상 주소의 페이지에 접근하려 함
- 페이지가 메모리에 없으면→ Page fault 발생
- 디스트에서 해당 페이지를 읽어 메모리 로드
- 명령 재실행

**장점**

- 메모리 효율적

**단점**

- 최초 접근 시 Page Fault로 인한 속도 저하
- Page Fault 빈번 → 성능 급락
  
<br>

### 📘 페이지 부재(Page Fault)

- CPU가 접근하려는 가상 주소의 페이지가 **메모리**에 없을 때 발생하는 예외 상황

❓**여기서 메모리 == 페이지 테이블** ❓

<aside>
❓

**NO !** 
Page Fault에서 말하는 ‘**메모리’는 물리 메모리(ram)** 의미

자세히는, **페이지 테이블에 메모리에 없다고 표시되어 있어서 발생한다.**

- ❌ **"페이지 부재는 페이지 테이블에 페이지 번호를 조회해보니 해당하는 PTE가 없어서 발생"**
- ✅ **"페이지 부재는 페이지 테이블에 페이지 번호를 조회해보니 메모리에 없다고 표시되어 있어서 발생"**
</aside>

**처리 과정**

- CPU가 어떤 가상 주소에 접근
- MMU가 페이지 테이블 확인
- 해당 페이지가 메모리에 없다고 표시
- ⇒ Page Fault 발생
- OS가 디스크에서 해당 페이지를 읽어 메모리에 적재
- 페이지 테이블 업데이트
- 다시 명령어 재실행

<br>

## 3. 캐시 메모리, TLB

### 📗 캐시 메모리(Cache Memory)

- CPU와 메인 메모리(RAM) 사이에 위치한 **고속 임시 저장 공간**
    
    👉🏻 자주 사용되는 데이터를 미리 저장해서, 접근 속도 향상
    

**원리 : 지역성(Loyalty)**

- **시간 지역성** : 최근에 사용한 데이터를 다시 사용
- **공간 지역성** : 근처 데이터를 다시 사용

**동작 방식**

1. CPU가 어떤 데이터를 요청하면,
2. 먼저 캐시에 그 데이터가 있는지 확인함 (👉 **캐시 히트** or **캐시 미스**)
3. 캐시에 있으면 → 바로 반환 (💨 빠름!)
4. 없으면 → RAM에서 읽고, 캐시에 복사

### 📗 TLB(Translation Lookaside Buffer)

- MMU 내부에 있는 **주소 변환 캐시**
- **가상 주소 → 물리 주소 매핑 정보를 캐싱**
- 페이징의 메모리 접근 오버헤드 극복
- 하드웨어에 존재

![image](https://github.com/user-attachments/assets/8c722bd9-a382-4d5f-a033-2f28871bc5eb)


**동작 방식**

1. CPU가 가상 주소를 생성
2. MMU가 TLB에서 해당 가상 페이지 번호를 찾음
    - ✅ **TLB Hit** → 바로 물리 주소 반환 (💨 빠름)
    - ❌ **TLB Miss** → 페이지 테이블 접근 → 변환 결과를 TLB에 캐싱

**MMU(Memory Management Unit)**

<aside>
📝

**메모리 관리 유닛**
CPU가 생성한 가상 주소를 물리 주소로 변환해주는 하드웨어 장치

</aside>

<br>

## 4. 메모리 할당 전략

- 운영체제가 프로세스에 메모리를 할당할 때, 어떤 빈 공간에 넣을지 결정하는 방법

### 🍋 First fit ( 최초 적합)

- **첫 번째로 찾은** 충분히 큰 빈 공간에 할당
- 장점 : 검색 속도가 빠름
- 단점 : 작은 공간들이 남아, 외부 단편화 발생 가능

### 🍋 Best fit ( 최적 적합)

- **가장 딱 맞는** 빈 공간에 할당
- 장점 : 공간 낭비가 적음
- 단점 : 탐색 시간 오래 소요

### 🍋 Worst fit ( 최악 적합)

- **가장 큰** 빈 공간에 할당
- 장점 : 큰 공간 유지 가능
- 단점 : 큰 공간도 잘게 나눠져 낭비 가능
