### [2주차] 메모리 관리 (페이징 & 세그멘테이션) + 가상 메모리

- 주소 공간, 물리적 주소, 논리적 주소, 주소 바인딩
- 메모리 관리 기법 (페이징, 세그멘테이션)
- 가상 메모리 (Demand Paging, Page Fault)
- 캐시 메모리, TLB(Translation Lookaside Buffer)
- 메모리 할당 전략 (First Fit, Best Fit, Worst Fit)

---

<br>

## 🔵 주소 공간, 물리적 주소, 논리적 주소, 주소 바인딩

### 주소 공간(Address Space)

컴퓨팅에서 주소 공간은 물리 메모리나 가상 메모리 등 다른 논리적 실체나 물리적 실체에 대응되는 주소의 범위를 정의한 공간을 말한다.

메모리 주소는 컴퓨터 메모리의 물리 위치를 파악하며, 데이터가 저장되는 위치를 가리킨다.

#### 프로세스와 주소 공간

일반적으로 운영체제는 하나의 프로세스에 대하여 하나의 주소 공간을 제공하며, 프로세스 내의 사용자 스레드들은 주소공간을 공유한다.

---

### 물리적 주소(Physical Space)

메모리는 배열이기 때문에 인덱스 값을 가지는데, 이 인덱스 값을 '물리적 주소'라고 한다. 물리적 주소는 **메모리 자체의 인덱스**다.

---

### 논리적 주소(Logical Space)

논리적 주소는 CPU 입장에서의 메모리 주소, 또는 프로그램 실행 중에 CPU가 생성하는 주소이다. 따라서 가상 주소라고도 한다.

CPU가 명령어를 실행하면서 생성하는 주소이다.

사용자 프로세스가 접근하는 주소는 모두 논리적 주소

변환 작업은 MMU(Memory Management Unit)에서 이루어진다.

---

#### 논리적 주소와 물리적 주소의 관계

| 종류        | 의미                       | 생성 주체  | 접근 방식                     |
| ----------- | -------------------------- | ---------- | ----------------------------- |
| 논리적 주소 | CPU가 생성하는 가상의 주소 | CPU        | 사용자 프로세스에서 직접 사용 |
| 물리적 주소 | 실제 메모리 주소           | MMU가 계산 | 운영체제나 하드웨어에서 접근  |

---

#### 논리적 주소가 필요한 이유

- **메모리 보호**: 각 프로세스는 자신의 주소 공간만 보게 하여 다른 프로세스의 메모리를 침범하지 못하도록 한다.
- **멀티프로그래밍 지원**: 서로 다른 프로세스들이 각자 독립된 주소 공간을 갖도록 함
- **프로그램의 이식성**: 논리 주소를 사용하면 프로그램을 어느 메모리의 어느 위치에서든 실행할 수 있다.

---

### 주소 바인딩(Address Binding)

프로세스가 논리적 주소를 참조하기 때문에 실제 메모리에 데이터를 읽고 쓰기 위해서는 해당 논리적 주소를 물리적 주소로 매핑하는 과정이 필요하다.

이를 **주소 바인딩**이라고 한다.

주소 바인딩은 프로세스가 메모리에 접근할 수 있도록 하는 중요한 단계
<br>

### MMU

![MMU](https://firebasestorage.googleapis.com/v0/b/portfolio-74c3d.appspot.com/o/CS-study%2F02-1.png?alt=media&token=1d95cdb3-cab7-421b-858d-8d2b85402a14)

MMU 는 CPU와 메모리 사이에 존재하는 하드웨어 장치로, 논리적 주소 -> 물리적 주소 변환을 수행한다.

#### 주요 역할

- 주소 변환: CPU가 생성하는 논리 주소에 Base Register 값을 더해 실제 물리 주소 계산
- 메모리 보호: Bounds Register를 통해 접근 가능한 메모리 범위 제한

---

<br>

## 🔵 메모리 관리 기법 (페이징, 세그멘테이션)

### 페이징(Paging) 이란

페이징은 가상 주소 공간과 물리적 주소 공간을 동일한 크기의 고정 블록으로 나누어 매핑하는 메모리 관리 기법이다.

- 가상 주소 공간을 나눈 고정 크기 블록 -> 페이지(Page)
- 물리 주소 공간을 나눈 고정 크기 블록 -> 프레임(Frame)

> 페이징은 **내부 단편화 발생** 가능

---

### 세그멘테이션(Segmentation) 이란

세그멘테이션은 프로그램의 논리적 구조에 따라 주소 공간을 여러개의 세그먼트로 나누어 메모리를 관리하는 방식이다.

세그먼트는 코드(Code), 데이터(Data), 스택(Stack)과 같이 의미 있는 논리 단위로 나뉜다.

각 세그먼트는 서로 다른 크기를 가질 수 있으며, 연속적인 메모리 공간을 할당받는다.

주소는 `(세그먼트 번호, 오프셋)` 형태로 표현한다.

> 세그멘테이션은 **외부 단편화** 발생 가능

<br>

## 🔵 가상 메모리 (Demand Paging, Page Fault)

### 가상 메모리(Virtual Memory)

실제 메모리 크기보다 요구 메모리가 큰 프로그램을 실행하기 위해 사용하는 메모리 관리 기법이다.

- 모든 데이터를 주 기억장치에 올리지 않고, 필요한 것들만 올려서 사용한다.
- 나머지는 디스크(보조 기억 장치)에 보관되며, 필요할 때만 메모리로 가져온다.
- CPU는 모든 주소를 가상 주소로 인식하고, 실제 주소는 MMU가 변환해서 사용한다.

### 요구 페이징(Demand Paging)

요구 페이징은 프로세스의 페이지 중 실제로 필요한 페이지만 메모리에 올리고, 나머지는 요청이 있을 때 디스크에서 가져오는 방식이다.

1. 처음엔 메모리에 아무것도 올리지 않음
2. CPU가 요청한 주소가 없는 경우(Page Fault) 발생
3. 이때 해당 페이지를 디스크에서 RAM으로 로드

### 페이지 폴트(Page Fault)

페이지 폴트(Page Fault)는 프로세스가 접근하려는 메모리 페이지가 물리적 메모리(RAM)에 존재하지 않을 때 발생하는 이벤트이다.

1. **페이지 폴트 발생**: 프로세스가 메모리에 접근하려 할 때, 해당 가상 주소에 대응하는 페이지가 물리적 메모리에 없으면 페이지 폴트가 발생,

2. **인터럽트 처리**: 페이지 폴트는 운영 체제에 의해 처리되는 인터럽트. 운영 체제는 이 인터럽트를 받고 현재 CPU의 상태를 저장한 후 페이지 폴트 처리 루틴을 실행.

3. **페이지 로딩**: 운영 체제는 필요한 페이지를 찾아 물리적 메모리로 로드함. 이 페이지는 디스크의 스왑 영역이나 해당 파일 시스템에서 가져올 수 있음.

4. **페이지 테이블 업데이트**: 페이지가 메모리에 로드된 후, 페이지 테이블이 업데이트되어 새로운 매핑 정보를 반영.

5. **프로세스 재개**: 페이지 로딩이 완료되면, CPU는 원래의 프로세스를 재개.

---

<br>

## 🔵 캐시 메모리, TLB(Translation Lookaside Buffer)

### 캐시 메모리 (Cache Memory)

**캐시 메모리(Cache Memory)** 는 CPU와 주기억장치(RAM) 사이에 위치한 고속의 임시 저장장치로, 자주 사용하는 데이터를 빠르게 접근하기 위해 사용된다.

    •	CPU가 자주 접근하는 데이터를 임시로 저장하여 속도 향상
    •	작지만 빠름, 용량은 작고, 가격은 비쌈

![Cache Hierarchy](https://firebasestorage.googleapis.com/v0/b/portfolio-74c3d.appspot.com/o/CS-study%2F02-2.png?alt=media&token=fdb1a573-5817-4ba4-b2ba-a4ece02b9f20)

| 계층    | 설명                                                |
| ------- | --------------------------------------------------- |
| L1 캐시 | 가장 빠르고 CPU 내부에 위치. 용량 작음              |
| L2 캐시 | CPU 와 메모리 사이에 위치. L1 보다 느리지만 용량 큼 |
| L3 캐시 | 일부 고성능 CPU에서 제공. L2 보다 크고 느림         |

### TLB (Translation Lookaside Buffer)

**TLB(Translation Lookaside Buffer)** 는 가상 주소 → 물리 주소 변환 시 사용되는 페이지 테이블 캐시이다.

    • MMU 내부에 존재하며, 최근 참조한 페이지 테이블 항목을 저장
    • 페이지 테이블 접근 시간을 줄여주는 역할

#### 작동 과정

    1. CPU가 가상 주소 접근
    2. MMU가 TLB에서 먼저 검색
    3. 있다면 → 바로 물리 주소 반환 (TLB hit)
    4. 없다면 → 페이지 테이블 접근 (TLB miss) 후 TLB에 등록

#### 효과

    • TLB hit → 주소 변환 속도 빠름
    • TLB miss → 페이지 테이블 접근 → 속도 저하

---

<br>

## 🔵 메모리 할당 전략 (First Fit, Best Fit, Worst Fit)

메모리 공간을 요청된 크기에 따라 **어떻게 효율적으로 배분할 것인가**에 대한 전략

1. First Fit (최초 적합)

   • 가장 먼저 발견한 충분한 공간에 할당

   • 빠르지만, 할당된 공간 이후에 작은 공간들이 남아 외부 단편화 발생 가능

2. Best Fit (최적 적합)
   • 가장 크기가 딱 맞는 공간에 할당 (남는 공간이 가장 적은 곳)

   • 공간 낭비가 적지만, 탐색 시간이 길 수 있음

   • 외부 단편화가 많이 발생

3. Worst Fit (최악 적합)

   • 가장 큰 공간에 할당하여 남은 공간이 충분히 크도록 함

   • 큰 공간을 계속 쪼개므로 큰 프로세스가 들어갈 공간이 사라질 수 있음
