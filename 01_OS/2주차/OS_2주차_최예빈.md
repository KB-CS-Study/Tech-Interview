## 주소

🔍 메모리는 주소를 통해 접근하는 매체

### **Logical address(=virtual adderess)**

- 프로세스마다 독립적으로 가지는 주소 공간
- 각 프로세스마다 0번지부터 시작
- CPU가 보는 주소는 logical address

### **Physical address**

- 프로세스가 메모리에 실제 올라가는 위치
- 시스템 전체적으로 공유되는 주소
- 프로세스가 물리적 주소로 접근하려면, 물리적 주소를 가리키고 있는 가상 주소를 물리적 주소로 변환해야 한다

논리적 주소가 필요한 이유 ❓

여러 개의 프로세스가 동시에 실행돼도, **서로의 메모리를 침범하지 않고 안전하게 실행할 수 있게 하기 위해** 필요하다. 만약 모든 프로세스가 직접 물리적 주소를 사용한다면, 여러 개의 프로세스들이 실행되면서 같은 물리적 주소를 접근해서 데이터를 수정하고, 민감 데이터를 쉽게 읽어올 수 있게 된다. 운영체제와 MMU가 논리적 주소를 물리적 주소로 변환하면서, **각 프로세스가 독립적인 메모리 공간을 가지도록 보장**한다.

## 주소 바인딩

🔍 프로세스에서 사용되는 논리적 주소를 실제 메모리의 물리적 주소로 변환하는 과정

언제 수행되느냐에 따라 3가지 유형으로 나뉜다.

### Compile-time Binding (컴파일 시간 바인딩)
- 컴파일 할 때, 물리적 메모리 주소를 결정한다.
- 컴파일 시점에 이미 물리적인 주소가 결정된 상태이므로, 물리적 주소로 갈 때 논리적 주소를 그대로 가져다 쓴다. 그래서 메모리에 다른 위치가 많이 비어있더라도 논리적인 주소가 그대로 물리적인 주소가 되므로 비효율적이다.
- 메모리에 올라갈 물리적 주소를 바꾸고 싶으면 컴파일을 다시 해야 된다.
### Load-time Binding (로드 시간 바인딩)
- 프로그램이 시작돼서 메모리에 올라갈 때 물리적인 주소가 결정이 된다.
- 재배치 가능 코드로 항상 특정 위치에 올라가야 하는게 아니라 메모리의 상황에 따라 비어있는 위치에 어디든 올라간다. ex) 500번대가 비어있는걸 보고, 해당 주소에 올린다.
### Execution-time Binding (실행 시간 바인딩)
- 실행 시 주소가 결정되는 것은 load time binding과 똑같지만 주소가 실행 도중에 바뀔 수가 있다.
- CPU가 메모리를 접근할 때마다 논리적 주소를 물리적 주소로 변환해야 하므로, 이를 빠르게 처리하기 위해 MMU 같은 하드웨어 지원이 필요하다.

## 물리적 메모리 할당

물리적인 메모리의 낮은 주소 부분 : 커널이 상주

물리적인 메모리의 높은 주소 부분 : 사용자 프로세스들이 상주

### 연속 할당

각각의 프로세스가 메모리의 연속적인 공간에 올라간다.

![1](https://github.com/user-attachments/assets/2fd7d088-35a6-4af2-8197-75684609bbd4)

### 고정 분할 방식
- 프로그램이 들어갈 사용자 메모리 영역을 미리 영구적 분할(partition)으로 나눠 놓는다.
- 균일하게, 가변적으로 모두 나눌 수 있다.
- 분할 당 하나의 프로그램이 적재된다.
- 외부 조각, 내부 조각이 발생하므로 비효율적이다.
    - 외부 조각 : 올리려는 프로그램의 크기보다 메모리 조각의 크기가 작아서 사용이 안된 공간
    - 내부 조각 : 올리려는 프로그램의 크기보다 메모리 조각의 크기가 커서 프로그램에게 할당 되고 남는 사용 안되는 공간
### 가변 분할 방식
- 들어갈 메모리 영역을 미리 나누어 놓지 않는 것
- 프로그램이 실행될 때 마다 차곡차곡 메모리에 올려놓는 방식. 이렇게 하더라도 프로그램이 실행되고 종료되는 과정에서 메모리에 구멍이 뚫려 외부 조각이 생길 수 있다.

![2](https://github.com/user-attachments/assets/8524d2ff-d45a-4101-b6c0-9fd83ff63516)

### **Dynamic Storage-Allocation Problem**

지금 실행하려는 프로그램의 크기가 n인데 홀이 여러개 있을 때 어느 홀에다 이 프로그램을 넣어야할 지 결정하는 문제
### First-fit
- 크기가 n 이상인 hole 중에서 제일 처음 발견되는 홀에다가 프로그램을 올리는 것.
- hole을 찾는 오버헤드가 적다.
### Best-fit
- 모든 홀을 다 살펴본 다음에 크기가 n 이상인 가장 작은 hole을 찾아서 할당
### Worst-fit
- 모든 홀을 다 살펴본 다음에 가장 큰 hole에다가 프로그램을 올리는 것.
- first-fit(오버헤드 적음)과 best-fit(적당한 홀)이 worst-fit보다 속도와 공간 이용률 측면에서 효과적이다.
### Compaction
- 외부 조각 문제를 해결하는 한 가지 방법
- 사용 중인 메모리 영역을 한 군데로 몰고 hole들을 다른 한 곳으로 몰아 큰 block을 만드는 것
- 프로세스의 주소가 실행 시간에 동적으로 재배치 가능한 경우에만 수행될 수 있기 때문에 run time binding에서만 실행이 가능하다.
- 전체 프로그램에 영향을 미치기 때문에 복잡하고 비용도 많이 든다.

### 불연속 할당

하나의 프로세스가 메모리의 여러 영역에 분산 되어 올라간다.

### Paging
- 프로세스의 가상 메모리 공간을 동일한 크기의 페이지 단위로 나누고 물리적 메모리도 페이지 크기로 잘라 놓는다.
- 물리적 메모리의 페이지 공간은 프레임이라고 부르고 프레임 하나 당 페이지 하나가 올라간다.
- 페이지 단위로 물리적 메모리에 올려놓거나 backing store에 내려놓는다.
- 외부 조각은 발생하지 않지만 가상 메모리를 자를 때 마지막에 짜투리 공간이 남을 수 있기 때문에 내부 조각은 발생할 수 있다.
- 주소 변환 과정
    - 논리 주소로 페이지 번호 & 페이지 내 오프셋이 주어진다.
    - 페이지 번호를 이용해서 페이지 테이블에서 페이지의 물리적인 베이스 주소를 찾고 여기에 페이지 오프셋을 더해서 최종적인 물리적 주소를 구한다.
- Page table
    - 각각의 논리적인 페이지들이 물리적인 메모리 어디에 위치하는 가를 담고 있다.
    - 모든 프로세스 마다 개별적으로 가지고 있는 정보로 n개의 프로세스가 있으면 페이지 테이블 또한 n개가 존재한다.
    - 용량이 매우 크기 때문에 메인 메모리에 집어 넣는다.
    
➡️ 페이지 테이블을 통한 주소 변환을 위한 메모리 접근 & 주소 변환이 되면 실제 그 데이터를 메모리에서 접근하기 위한 접근 → 총 **두 번**의 메모리 접근이 필요하다.
    
### Segmentation
- 프로세스의 가상 메모리 공간을 의미 단위로 자르는 것
- 일반적으로는 프로세스의 메모리 영역 중 Code, Data, Stack 단위로 자른다.
- 주소 변환 과정
    - 논리 주소로 세그먼트 번호 & 세그먼트 내 오프셋이 주어진다.
    - 세그먼트 번호를 이용해서 세그먼트 테이블에서 세그먼트의 물리적인 베이스 주소를 찾고 여기에 세그먼트 내 오프셋을 더해서 물리적 주소를 구한다.
- 장점
    - 의미 단위이기 때문에 공유와 보안에 있어 paging보다 훨씬 효과적이다.
    - 페이징보다 protection 하기 쉽다.
- 단점
    - 크기가 균일하지 않아 가변 분할 방식에서와 동일한 문제점들이 발생한다.

## TLB
![3](https://github.com/user-attachments/assets/5f4bd6fd-69ee-4417-a268-85964aad8181)
- 논리적 주소를 물리적 주소로 변환하는 속도를 높이기 위한 캐시 메모리
- 메인 메모리와 CPU 사이에 존재하는 계층이다.
- 페이지 테이블에서 빈번히 참조되는 일부 엔트리(전체X)를 캐싱하고 있다. 페이지 테이블 접근 전에 TLB를 먼저 검색한다.
- TLB 전체에서 페이지 번호를 모두 검색해야 해서 전체 검색이 오래 걸리므로, 보통 parallel search가 가능한 associative registers를 이용해서 구현한다.
- 페이지 번호에 해당하는 엔트리가 TLB에 저장이 되어 있으면(TLB hit) → TLB를 통해 바로 주소 변환이 이루어지고 메모리에 한 번만 접근한다.
- 페이지 번호에 해당하는 엔트리가 TLB에 없는 경우(TLB miss) → 페이지 테이블을 통해 일반적인 주소 변환을 하기 때문에 메모리에 두 번 접근한다.

## 가상 메모리

물리적 메모리 크기의 한계를 극복하기 위해 나온 기술
    
➡️ 즉, 물리적 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용한다. 예를 들어, 100MB 메모리 크기에서 200MB 크기의 프로세스를 수행할 수 있도록 하는 것이다.
    
어떻게 가능❓프로세스를 실행할 때, 실행에 필요한 부분만 메모리에 올린다.
    
### Demand Paging
- 현재 필요한(요구되어지는) 페이지만 메모리에 올리는 것
- 동작 과정
    1. 프로세스가 실행을 시작할 때, 페이지 테이블만 로드하고 실제 페이지는 메모리에 올리지 않는다.
    2. CPU가 특정 페이지에 접근하려 하면, 해당 페이지가 메모리에 있는지 확인한다.
    3. 페이지가 없으면 Page Fault(페이지 폴트)가 발생한다. → 해당 페이지를 디스크에서 메모리로 가져온다.
    4. 페이지가 메모리에 로드된 후, 다시 실행을 이어간다.
### Page Fault
- CPU가 요구한 페이지가 메모리에 없는 경우 발생하는 예외
- 동작 과정
    1. CPU가 특정 페이지에 접근하려고 하는데, 페이지가 메모리에 없는 경우 페이지 폴트 예외 발생 → 운영체제(OS)가 개입
    2. 디스크에서 해당 페이지를 찾아서 메모리로 로드한다.
    3. 페이지 테이블을 업데이트하고, 다시 프로세스를 실행한다.
    
➡️ 너무 자주 발생하면 성능 저하가 일어날 수 있다. 이를 방지하려면 적절한 페이지 교체 알고리즘(예: LRU, FIFO 등)을 사용해야 한다.