[0woy, [운영체재 개요, 프로세스 & 스레드]](https://0woy.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%BB%B4%ED%93%A8%ED%84%B0)

## **운영체제의 역할과 구조**

### 운영체제 역할

1.  **CPU 스케줄링과 프로세스** 관리  
    CPU 소유권을 어떤프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환 관리
2.  **메모리** 관리: 한정된 메모리를 어떤 프로세스에 얼만큼 할당할지
3.  **디스크 파일** 관리: 디스크 파일을 어떤 방법으로 보관할지
4.  **I/O 디바이스** 관리: 마우스, 키보드 등과 컴퓨터 간에 데이터 주고 받는 것 관리

### 운영체제 구조
![img](https://github.com/user-attachments/assets/006ab0d2-7906-4f50-a44e-52b8ca6d2c78)

-   GUI: 사용자가 전자장치와 상호 작용할 수 있도록 하는 사용자 인터페이스의 한 형태
-   드라이버: 하드웨어를 제어하기 위한 소프트웨어
-   CUI: 그래픽이 아닌 명령어로 처리하는 인터페이스

---

## 커널 (Kernel)

**하드웨어와 응용 프로그램 사이**에서 **자원을 관리**하는 역할

CPU, 메모리, 디스크, 네트워크, 파일 시스템 등 제어

일반 응용 프로그램이 직접 접근 할 수X, \`커널 모드\`에서만 실행 가능

### 유저 모드 

일반 응용 프로그램이 실행되는 모드

운영체제의 중요한 자원에 직접 접근 불가

시스템 콜을 통해서만 커널 기능을 사용할 수 있음

> 웹 브라우저, 게임, 동영상 플레이어 등  
> 일반 사용자 프로그램은 항상 유저 모드에서 실행

### 커널 모드

운영체제가 실행되는 특권 모드

CPU가 모든 메모리 / 하드웨어 자원에 접근 가능

> 파일 시스템 접근 : 사용자가 파일을 저장하면, 커널이 디스크에 저장  
> 메모리 할당 : 프로그램이 실행될 때, 커널이 메모리를 할당

---

### 유저 모드와 커널 모드 전환 과정

유저 모드에서 커널 모드를 사용하려면 \*시스템콜을 이용해야 함

EX) 파일 읽기 과정 (\`read()\` 함수 호출)

1.  웹 브라우저 (유저 모드)에서 파일을 읽으려 함 : \`read()\` 호출
2.  시스템콜로 커널 모드로 전환
3.  커널이 파일 시스템에서 데이터를 가져옴
4.  파일 데이터를 웹 브라우저에 전달 후 다시 유저 모드로 전환

---

#### **시스템콜**

운영체제가 커널에 접근하기 위한 **인터페이스**이며 **유저 프로그램이** 운영체제의 서비스를 받기 위해 **커널 함수를 호출**할 때 사용

![img](https://github.com/user-attachments/assets/2ce17166-3568-4e74-a417-d482d6f2ec1f)

프로세스나 스레드에서 **운영체제로 요청을 할 때**, \`시스템콜\`과 \`커널\`을 거쳐 운영체제로 전달됨

시스템 콜을 사용하면, 유저 모드에서 실행되는 프로그램이 커널 모드로 전환되어 하드웨어 자원에 접근하거나 보호된 시스템 기능 사용 가능

> 즉, _**시스템 콜은 사용자 프로그램과 커널 사이의 상호작용**_을 가능하게 함

---

## **프로세스** 

### **프로세스 (Process)**

-   cpu **스케줄링의 대상**이 되는 작업
-   **프로그램**이 \`메모리\`에 올라가 \`**인스턴스화\`** 된 것 (실행 중인 프로그램)

|   | _****프로그램****_ | _**프로세스**_ |
| --- | --- | --- |
| **정의, 상태** | 특정 작업을 위해 작성된 코드의 집합   HDD, SSD에 저장된 정적 상태 | 실행 중인 프로그램   메모리에 로드되어 동적으로 작동 |
| **자원 사용** | 저장을 위한 디스크 공간만 必 | CPU, 메모리 주소, 디스크 등   다양한 시스템 자원 사용 |
| **인스턴스화** | 하나의 프로그램 파일로 존재 | 여러 번 실행되면 여러 개 생성 O |
| **특성** | 수동, 정적 엔티티   실행 전까지 어떤 작업도 수행 X | 동적, 활성화된 엔티티    OS에 의해 관리 됨 |

---

### 프로세스 상태

![플로세스 상태](https://github.com/user-attachments/assets/9dfe4602-9a1b-41f2-9790-1c5463424947)


1.  \`생성\`: 프로세스가 생성된 상태 (PCB 할당)
2.  \`준비\`: 메모리 공간이 충분하면, 메모리를 할당 받음, CPU 스케줄러로부터 **CPU 소유권**이 넘어오기를 **기다림**
3.  \`실행\`: CPU 소유권과 메모리를 할당받고, \*Instructions을 수행 중인 생태 (\*_cpu burst_)
4.  \`대기\`: 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태 (ex. I/O 인터럽트)
5.   \`종료\`: 메모리와 CPU 소유권 모두 놓고 가는 상태 (\*비자발적 종료도 존재)

> **Instruction**  
> 컴퓨터가 수행해야 할 작업을 기술한 명령들,  프로그램 실행의 기본 단위  
> CPU는 프로그램 실행 중 각 명령어를 순차적으로 가져오고(fetch), 해석 (decode)후 실행(execute)하는  
> 사이클 반복 , 이러한 명령어는 메모리에서 가져와 실행  
>   
> **cpu burst**  
> 프로세스가 cpu를 독점적으로 사용해 연속적으로 명령어를 실행하는 구간  
> I/O 작업 없이 오직 CPU에서 연산만 수행  
>   
> **비자발적 종료**  
> 부모 프로세스가 자식 프로세스를 강제 시키는 비자발적 종료(abort)  
> 1\. 자식 프로세스에 할당된 자원의 한계치를 넘겼을 때  
> 2\. 부모 프로세스가 종료 됐을 때  
> 3\. 사용자가 \`process.kill\` 등 여러 명령어로 프로세스 종료할 때

---

### 프로세스 메모리 구조

<Img src="https://github.com/user-attachments/assets/bad76b0e-dfa2-447a-810f-c037e5b08c83" width=50%>

운영체제는 프로세스에 위와 같은 구조로 적절한 메모리 할당

| 영역 | 설명 |
| --- | --- |
| _**스택 영역**_ | 1. 함수 호출 시 임시 데이터 저장 공간<br>2. 함수 매개변수, 복귀 주소, 지역 변수 등 저장<br>3. 함수 호출 시 생성 & 종료 시 제거되는 **활성화 레코드** pop/push<br>4. 높은 주소 → 낮은 주소 |
| _**힙 영역**_ | 1. 프로그램 실행 중 동적으로 할당되는 메모리 공간<br>2. 프로그래머가 **직접 관리** 하는 영역<br>3. 메모리 누수를 방지하기 위해 할당 후 **반드시 해제**<br>4. 낮은 주소 → 높은 주소 |
| _**데이터 영역**_ | 전역변수, 정적 변수 저장<br>프로그램 실행 시간 동안 **크기 고정** |
| _**코드 영역(TEXT 영역)**_ | 실행 가능한 기계어로 이루어진 명령어 저장<br>**\`읽기 전용\`** 공간으로, 프로그램 실행 시간 동안 **크기 고정** |


> **데이터 영역 中**   
> **BSS segment**  
> 전역 변수, static & const 로 선언  
> \`0\`으로 초기화 또는 초기화가 **어떤 값으로도 되어 있지 않은** 변수  
>   
> **Data segment**  
> 전역 변수, static & const로 선언  
> \`0이 아닌 값\`으로 초기화 된 변수

---

### 프로세스 제어 블록 (PCB, Process Control Block)

운영체제에서 프로세스에 대한 \`메타데이터\`를 **저장**한 데이터

**프로세스가 생성**되면 운영체제는 해당 PCB를 생성함

프로세스가 생성되면, 프로세스 주소 값들에 메모리가 할당 되고 이 프로세스의 메타데이터들이 PCB에 저장 & 관리

> 프로세스의 중요한 정보를 포함하고 있으므로 일반 사용자가 접근하지 못하도록  
> **커널 스택의 가장 앞 부분**에서 관리됨

---

#### PCB 구조

-   **프로세스 식별자** (PID) : 각 프로세스의 고유한 ID
-   프로세스 **상태**: 실행, 대기, 정지 상태 등
-   **프로그램 카운터**: 다음에 실행할 명령어의 주소
-   **CPU 레지스터**: 누산기 (Accumulator), 스택 포인터, 베이스 레지스터 등
-   **CPU 스케줄링 정보**: CPU 스케줄러에 의해 중단된 시간 등에 대한 정보
-   **I/O 상태 정보**: 프로세스에 할당된 I/O 디바이스 목록
-   **계정 정보**: 프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보

---

## 스레드 (Thread)

프로세스 내에서 실행되는 **가장 작은 실행 단위**

프로세스는 여러 개의 스레드를 가질 수 있음

![스레드](https://github.com/user-attachments/assets/45f3029e-0fe9-4879-a127-5af883361675)


프로세스 내의 스레드들은 Stack을 제외한 **메모리 영역을 공유**

---

## 멀티프로세싱 & 멀티스레딩

멀티프로세스와 멀티스레딩은 **동시에 여러 작업을 처리**하는 방식

### 멀티프로세싱

여러 개의 **독립된 프로세스**가 **동시에 실행**되는 것

#### 특징

-   **독립된 메모리 공간 사용**: 각 프로세스는 **자신만의 주소 공간**(코드, 데이터, 힙, 스택 등)을 가짐
-   **프로세스 간 통신**(\*IPC) **필요**: 파이프, 메시지 큐, 공유 메모리 사용
-   **컨텍스트 스위칭 비용 高** :  프로세스 간 문맥 전환 시 \`캐시 미스\`(Cache Miss) 발생

#### 장점

-   **안정성**: 한 프로세스가 죽어도 다른 프로세스에 영향을 주지 않음
-   **멀티코어** CPU 활용 : 여러 개의 코어에서 병렬로 실행 가능
-   운영체제에서 멀티프로세스를 기본적으로 지원:  프로세스 단위의 자원 관리가 체계적

#### 단점

-   IPC 高 : 데이터를 주고 받으려면 별도 통신 방식 必
-   컨텍스트 스위칭 비용 高: 프로세스 전환 시 메모리 독립성이 유지돼야 하므로 성능 저하
-   메모리 사용량 多: 각 프로세스가 독립된 메모리 공간 차지

#### 예시

-   웹 브라우저: 각 탭을 개별 프로세스로 실행, 하나가 죽어도 다른 탭에 영향X
-   데이터 베이스: 여러 개의 클라이언트 요청을 개별 프로세스로 처리

> **IPC (Inter-Process Communication) ❓**  
> 독립된 프로세스들이 데이터를 주고받는 방법  
> 공유 방식: 공유 메모리, 메시지 큐, 파이프, 소켓 등

---

### 멀티스레딩

프로세스 내 작업을 여러 개의 스레드로 처리하는 기법

스레드끼리 서로 자원을 공유하기 때문에 **효율성이 높음**

프로그램의 성능과 응답성을 향상시킬 수 있으나, **적절한 동기화와 자원 관리 必**

#### 특징

-   프로세스의 자원 (메모리 등) **공유**
-   **독립적**인 작업 수행
-   CPU의 여러 코어를 효율적으로 활용

#### 장점

-   **응답성** 향상: 한 스레드가 작업 중이어도 다른 스레드가 사용자 입력에 응답 가능
-   자원 효율성: 프로세스보다 적은 메모리 & 자원 사용
-   빠른 \*컨텍스트 스위칭: 스레드 간 전환이 프로세스보다 빠름
-   병렬 처리: 멀티코어 환경에서 여러 작업 동시에 처리 가능

#### 단점

-   동기화 문제: 공유 자원에 대한 접근을 조절해야 함
-   디버깅 어려움: 여러 스레드가 동시에 실행되어 버그 추적 복잡
-   데드락 가능성: 스레드 간 자원 경쟁으로 교착 상태 발생 가능

#### 예시

-   웹 서버: 동시에 여러 클라이언트 요청 처리
-   멀티미디어 애플리 케이션: 영상/음향 재생과 기타 작업을 동시에 수행

---

### 멀티프로세싱 VS 멀티스레딩 비교

| **구분** | _**멀티프로세싱**_ | _**멀티스레딩**_ |
| --- | --- | --- |
| **실행 단위** | 여러 프로세스  | 한 프로세스 내 여러 스레드 |
| **메모리 공유** | 독립된 메모리 사용 | 같은 프로세스 내 메모리 공유 |
| **안정성** | 한 프로세스 死, 다른 프로세스 영향X | 한 스레드 死, 전체 프로세스 영향 가능 |
| **속도** | IPC 필요, 상대적으로 느림 | 메모리 공유로 빠름 |
| **컨텍스트 스위칭 비용** | 높음 (메모리 독립) | 낮음 (메모리 공유) |

---

## 컨텍스트 스위칭 (Context Switching)

CPU가 현재 실행 중인 작업(프로세스 또는 스레드)의 상태를 저장하고, 다른 작업의 상태를 복원하는 과정

이 과정에서 PCB 또는 TCB를 사용하여 레지스터, 프로그램 카운터, 스택 등의 정보를 저장 & 복원

### 프로세스 컨텍스트 스위칭

**PCB를 교환** 하는 과정 (프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생)

컴퓨터는 많은 프로그램을 동시에 실행하는 것처럼 보이나, 어떤 시점에서 실행되고 있는 프로세스는 단 한 개.

동시에 실행되는 것처럼 보이는 이유는 컨텍스트 스위칭이 매우 빨라서 그렇게 보임 

![pcb cs](https://github.com/user-attachments/assets/9330d0cc-1df8-40d4-b74a-4d7849484e58)


> 현대 컴퓨터는 멀티 코어의 CPU를 가지기 때문에 한 시점에 한 개의 프로그램은 아님  
> 컨텍스트 스위칭을 설명할 때는 **싱글코어를 기준**으로 설명

#### 과정

1.  현재 프로세스 상태 저장: 레지스터 값, PC, 스택 포인터 등을 PCB에 저장
2.  새로운 프로세스 PCB 로드: PCB 정보를 가져와 CPU에 복원
3.  **메모리 매핑 변경:** 프로세스가 달르면 주소 공간이 다르므로 \*MMU 설정 변경, \*\`TLB FLUSH\`발생
4.  CPU가 새로운 프로세스 실행

---

### 스레드 컨텍스트 스위칭

같은 프로세스 내 실행 중인 스레드를 변경할 때 발생하는 과정

#### 과정

1.  현재 실행중인 스레드의 상태 저장: 레지스터 값, PC, 스택 포인터 등 TBC에 저장
2.  새로운 스레드의 TBC 로드
3.  CPU가 새로운 스레드 실행

### 프로세스 CS VS 스레드 CS 

**스레트 컨텍스트 스위칭의 비용이 더 낮다.**

프로세스CS는 주소 공간을 변경 하는 \`메모리 매핑 변경\` 과정이 발생하는 반면 스레드는 같은 주소 공간 공유
