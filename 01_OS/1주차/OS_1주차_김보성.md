# 📌 운영체제

## ✅ 개념

- 운영체제는 사용자가 컴퓨터를 사용하기 위해 필요한 시스템 소프트웨어
- 우리가 일반적으로 컴퓨터를 사용하면서 모든 프로그램들은 운영체제에서 관리하고 제어 한다고 보면 된다
  - ex) Windows, Linux, Mac OS, iOS 등

## ✅ 목적

### 1. 컴퓨터 시스템의 효율적 운영 (하드웨어 관리도 포함)

- 하드웨어를 잘 제어하고 관리하여 시스템 자원을 효율적으로 활용하기 위함
- 컴퓨터 시스템? (4계층 구조)
  - 사용자 ↔ 응용 프로그램 ↔ 운영체제 ↔ 하드웨어
- 하드웨어란 : 실제 물리적인 장치
  - CPU, 메모리, 디스크, 키보드, 마우스, 모니터 등
  - 하드웨어 자원을 운영체제가 적절히 배분하고, 충돌 없이 관리
    → 운영체제의 성능이 컴퓨터의 전체 성능과 관계가 크다고 볼 수 있음!

### 2. 사용자에게 편의를 제공하는 목적

- 하드웨어나 복잡한 시스템 구조를 몰라도 응용 프로그램만 사용해서 컴퓨터를 쉽게 조작

![image4](https://github.com/user-attachments/assets/46d01d45-379f-4559-96fc-5d5e1f437308)

- 그림처럼 사용자는 그냥 멜론만 클릭해서 사용하면 운영체제가 알아서 하드웨어를 관리하여 쉽게 사용할 수 있도록 해줌!

## ✅ 핵심 역할

### 1. 프로세스 관리

- 실행 중인 프로그램(프로세스)을 생성, 스케줄링, 종료 하는 역할
- 운영체제는 CPU를 누구에게 얼마나 줄지 결정
- 여러 작업을 동시에 진행할 수 있게 보이게 만들어 줌 → 이걸 스케줄링이라고 함

  - 멜론 앱으로 음악, 크롬으로 검색, vscode로 코딩
    → 이 모든 프로세스가 동시에 돌아가도록 CPU 시간 분배
    -> 우선순위랑 상태, 요청 자원등을 보고 CPU가 계속 재분배 해줌!!

    ![image3](https://github.com/user-attachments/assets/78cc42f6-6ca3-4dc7-bb89-2a2adb873f2f)

### 2. 메모리 관리

- RAM을 효율적으로 나누고 보호
  - RAM은 일시적으로 저장하는 휘발성 메모리! → 컴퓨터 끄면 저장한거 사라짐 ㅠ
- 여러 프로세스가 동시에 안정적으로 실행하게 끔 도와줌!
  - 멜론 앱과 크롬이 동시에 실행 되지만 메모리 충돌이 일어나지 않게 해줌

### 3. 파일 시스템 관리

- 데이터를 파일 단위로 저장, 조회, 삭제할 수 있게 쉽게 만듬
- 저장 장치에서의 데이터 관리, 접근 권한 제어 등의 기능 제공
  - 파일 탐색기에서 이름 검색하면 쉽게 찾는 것 처럼!

### 4. 입출력 장치 관리

- 사용자가 키보드, 마우스 등으로 조작 하면 알아서 운영체제가 중간에서 처리 해줌!
  - 장치 드라이버를 통해 대신 처리해줌!
  - 키보드르 눌렀을 때 화면에 글자 뜨는 순서
    → 키보드 입력 → 운영체제가 읽음 → 문자 처리 후 모니터 출력

## ✅ 그 외의 역할

### 5. 네트워크 관리

- 운영체제는 컴퓨터가 다른 컴퓨터들과 **네트워크를 통해 통신할 수 있도록 지원**함
- 네트워크 장비와의 연결을 관리하고, **데이터 전송의 흐름 제어**, **오류 처리**, **보안 설정** 등을 수행

### 예시

- IP 주소 설정, 포트 제어, 네트워크 인터페이스 관리
- 네트워크 연결 상태 확인 (`ping`, `netstat`)
- 서버에서 수신한 요청 처리 및 전송 제어

### 6. 보조 스토리지 관리

- 스토리지 할당, 여유 공간 관리, 디스크 스케줄링
- 하드디스크(HDD), SSD, USB 등 **영구 저장 장치**를 효율적으로 관리함
- 운영체제가 직접 **공간을 할당하고**, **빈 공간을 추적하며**, **디스크 스케줄링 알고리즘**으로 성능 최적화

### 예시

- 디스크 읽기/쓰기 요청을 스케줄링 (FCFS, SSTF 등)
- 파티션 관리, 저장 용량 확인, 파일 삭제 후 공간 회수 등

### 7. 보안 관리

- 시스템 보호 및 오류로 인한 시스템 손상 방지
- **외부 침입**, **악성 코드**, **권한 없는 접근**으로부터 시스템을 보호함
- 사용자 권한과 접근 제어, 암호화, 방화벽 설정 등을 포함

### 예시

- 리눅스의 `chmod`, `sudo` 명령어로 파일 권한 설정
- 시스템 로그인 시 사용자 인증 (ID/PW 확인)
- 안티바이러스, 방화벽, SELinux 같은 보안 모듈

### 8. 명령어 해석 시스템

- 사용자와 시스템 간의 인터페이스, 인터프리터, 쉘 등
- 사용자가 입력한 **텍스트 명령어를 해석해서 실행**하는 인터페이스
- \*쉘(Shell)\*\*이 대표적인 명령어 해석 시스템으로, 사용자와 커널 사이의 인터페이스 역할

### 예시

- 리눅스의 `bash`, `zsh`, Windows의 `cmd`, `PowerShell`
- 사용자가 `ls`, `cd`, `mkdir` 같은 명령어 입력 → 커널에게 전달되어 실제 동작 수행

# 📌 커널

## ✅ 개념

- 운영체제의 핵심!!!
- 하드웨어를 직접 제어하는 역할
- 커널은 커널 공간이라는 곳에 위치!
- 사용자가 쉘(Shell)을 통해 입력한 명령어를 해석하여 하드웨어에 전달해주는 역할
- 위에서 말한 운영체제가 하는 기능들을 사실 커널이 실제로 담당하는 거임!
  - 쉽게 말하면 커널은 운영체제의 심장! → 컴퓨터, 하드웨어 자원을 통제하는 최고 관리자!!
  - 메모리 관리
  - 프로세스 관리 및 CPU 스케쥴링
  - 입출력 장치와 같은 컴퓨터에 연결된 장치들 관리
  - 시스템 콜 인터페이스 및 보안
- CPU에는 두가지 실행 모드가 있음
  - User Mode : 일반 프로그램이 동작하는 제한된 모드
  - Kernel Mode : 운영체제가 동작하는 권한 있는 모드
    → 하드웨어 직접 제어 가능 O

## ✅ 쉘

### 개념

- 사용자와 하드웨어 간의 번역 역할을 담당
- 사람이 이해하기 쉬운 형태로 된 명령어를 입력 → 쉘이 기계가 이해하기 쉬운 형태로 해석
  → 커널에 전달
- 쉘(Shell)은 운영체제의 사용자 인터페이스 중 하나로,**사용자의 명령어를 해석해서 커널에 전달하고**, 그 결과를 다시 사용자에게 보여주는 **중간 관리자** 역할을 함
- CLI (Command Line Interface)**와 **GUI (Graphical User Interface)\*\* 모두 쉘의 일종

### 기능

- 명렁어 해석 기능
  - 대표적인 기능
  - 사용자가 입력한 명령어 → 기계어로 번역 → 커널에서 수행한 결과를 다시 번역 → 사용자
  - 인터프리터 역할 수행!
- 명령어 이력 기능
  - 사용자가 이전에 입력했던 명령어를 화살표 키로 다시 불러올 수 있음
  - `history`, `!!`, `!n` 같은 기능
- 파이프 & 리디렉션 기능
  - 명령어의 출력 결과를 다른 명령어의 입력으로 넘기거나, 파일로 저장할 수 있음
  - 예: `ls | grep txt`, `cat file.txt > output.txt`
- 프로그래밍 기능
  - 쉘 스크립트를 작성하여 반복적으로 수행하는 작업을 프로그램으로 만들 수 있음
- 사용자 환경 설정 기능

  - 명령을 호출하는 경로, 파일의 권한 설정, 환경 변수들을 초기화 파일에 저장
  - 이 파일을 이용해 사용자가 로그인할 때마다 설정이 반영 되게 할 수 있음

- 주요 쉘 종류
  - **sh**: 가장 기본적인 Unix 셸
  - **bash**: 가장 널리 쓰이는 Linux 셸 (Bourne Again SHell)
  - **zsh**: 자동완성, 하이라이팅 등 편의성 강화된 셸
  - **fish**: 사용자 친화적인 modern 셸
  - **PowerShell**: Windows의 셸 (객체 기반, cmd랑 다름)

### 마무리 요약

- 쉘은 **사용자 ↔ 운영체제(커널)** 사이의 대화 통역기 역할을 하며, 명령어 해석, 환경 설정, 스크립트 실행 등 다양한 기능을 제공하는 **강력한 도구**

## ✅ 동작하는 방식

- 응용 프로그램은 직접 하드웨어에 접근 XX
- 응용 프로그램은 커널에게 <시스템 콜>로 요청함
  - 시스템 콜 : 사용자나 응용 프로그램이 컴퓨터 자원을 사용하기 위해서 사용, 함수 형태
  - ex) open()
- 커널은 하드웨어에게 명령을 내리고 사용자에게 전달
  1. 멜론 앱이 파일을 열려고 함
  2. 앱에서 open()이라는 시스템 콜을 요청 → 이를 통해 Kernel Mode로 전환
  3. 커널이 디스크에서 파일을 읽고 앱에 전달 → 하면 다시 User Mode로 전환

![image2](https://github.com/user-attachments/assets/8add1451-2f78-4f46-9913-96ebfeb4c757)

## ✅ 커널의 종류 (운영체제 아키텍처 관점)

- 모놀리식 커널 : 기능이 한 덩어리로 커널 내부에 존재
- 마이크로 커널 : 최소한의 핵심 기능만 커널에 넣고, 나머지는 사용자 영역에서 실행
  ex) 프로세스 관리, 메모리 관리, 프로세스 통신

# 📌 프로세스 vs 스레드

## ✅ 프로세스

### 개념

- 실행중인 프로그램!
- 운영체제가 독립적인 메모리 공간을 할당해서 관리하는 단위

### 예시

- 크롬 실행 → 크롬 프로세스가 생김
- vscode를 실행 → vscode 프로세스가 생김
- 멜론 앱을 실행 → 멜론 프로세스가 생김 (쉽죠?)

### 특징

- 완전히 독립 (서로의 메모리, 데이터 접근 X)
- 하나가 죽어도 다른 프로세스엔 영향 X
- 생성/전환 비용이 큼 (메모리, 리소스까지 따로 생성해야 하니까)

## ✅ 프로세스 상태

- 프로세스는 실행되는 동안 아래와 같은 상태를 가짐

| 상태              | 설명                           |
| ----------------- | ------------------------------ |
| New               | 생성 중인 상태 (아직 실행 전)  |
| Ready             | 실행될 준비가 되어 큐에서 대기 |
| Running           | 실제로 CPU를 점유하고 실행 중  |
| Waiting (Blocked) | I/O 등 외부 작업을 기다리는 중 |
| Terminated        | 실행이 끝난 상태               |

➡ 운영체제는 이 상태 정보를 참고해서 어떤 프로세스에게 CPU를 줄지 결정함

---

## 🧠 **프로세스의 메모리 구조**

### ✅ **프로세스 메모리 구조**

운영체제가 **각 프로세스에게 메모리 공간을 할당**할 때,

이 메모리는 크게 **4개의 주요 영역**으로 나뉩니다:

1. **코드 영역 (Text Segment)**
2. **데이터 영역 (Data Segment)**
3. **힙 (Heap)**
4. **스택 (Stack)**

---

### 1. **코드 영역 (Text Segment)**

- **설명**: 프로그램이 실행되는 **기계어 코드**가 저장되는 영역입니다.
  - 여기에는 **실행할 수 있는 코드**와 **정적 함수들**이 포함됩니다.
- **특징**:
  - **읽기 전용**으로 설정되며, **수정할 수 없다** (보안을 위해)
  - 실행할 때 **프로그램 코드**가 여기에 배치되어 실행됩니다.
  - 프로세스가 시작될 때 로딩되어 **변경되지 않음**

---

### 2. **데이터 영역 (Data Segment)**

- **설명**: 프로그램 내에서 **전역 변수**나 **정적 변수**들이 저장되는 영역입니다.
  - **초기화된 데이터**와 **초기화되지 않은 데이터**로 나눠지기도 합니다.
- **특징**:
  - **초기화된 데이터**: 프로그램 실행 전에 초기값을 가진 변수들.
  - **초기화되지 않은 데이터(BSS)**: 값이 설정되지 않은 전역 변수나 정적 변수들.
  - 프로그램 실행 중 **변경 가능한 영역**이지만, **코드 영역**과는 다르게 값이 바뀔 수 있습니다.

---

### 3. **힙 (Heap)**

- **설명**: **동적 메모리 할당**에 사용되는 영역입니다.
  - 프로그램 실행 중 **`malloc()`**, **`new`** 등을 통해 **동적으로 메모리를 할당**하거나 **`free()`**, \**`delete`*로 해제합니다.
- **특징**:
  - **동적으로 메모리를 할당**하고 해제할 수 있기 때문에, 크기가 **가변적**입니다.
  - **메모리 누수**가 발생할 수 있어, 관리가 **중요**합니다.
  - 힙 영역은 **프로세스가 종료될 때까지 메모리가 계속 할당**될 수 있습니다.

---

### 4. **스택 (Stack)**

- **설명**: **함수 호출 시** 생성되는 **지역 변수**와 **함수 호출 정보**가 저장되는 영역입니다.
  - 함수가 호출될 때마다 **스택 프레임**이 쌓이고, 함수가 종료되면 그 스택 프레임이 **pop**됩니다.
- **특징**:
  - **LIFO(Last In, First Out)** 방식으로 메모리가 관리됩니다.
  - **함수의 인자**, **지역 변수**, **반환 주소** 등이 저장됩니다.
  - **자동으로 메모리가 할당되고 해제**되므로 **수동 관리 필요 없음**.
  - \*스택 오버플로우(Stack Overflow)\*\*가 발생할 수 있음: 너무 많은 함수 호출이나 너무 많은 지역 변수 사용 시.

---

### 💡 **각 영역의 메모리 관리 차이점**

| 영역            | 용도                                    | 특징                                         |
| --------------- | --------------------------------------- | -------------------------------------------- |
| **코드 영역**   | 실행 가능한 프로그램 코드               | 읽기 전용, 수정 불가                         |
| **데이터 영역** | 전역 변수, 정적 변수                    | 초기화된 데이터, 초기화되지 않은 데이터(BSS) |
| **힙**          | 동적 메모리 할당 (`malloc()`, `new` 등) | 크기 가변, 프로세스 종료까지 메모리 유지     |
| **스택**        | 함수 호출과 지역 변수                   | LIFO, 자동 할당 및 해제, 메모리 한계 있음    |

---

### ✅ **한 줄 요약**

> 프로세스의 메모리 구조는 코드 영역, 데이터 영역, 힙, 스택으로 나뉘며,
>
> 각 영역은 **메모리 할당과 관리 방식**이 다르고, **동작 방식**도 각기 다릅니다.

---

## 🧠 **좀비 프로세스 (Zombie Process)**

### ✅ **좀비 프로세스란?**

**좀비 프로세스**는 **실제로 종료된 프로세스**지만, **프로세스 테이블**에서 **완전히 사라지지 않은 상태**인 프로세스를 의미해요.

> 정리하자면:
>
> 프로세스가 **종료되었지만** 그 종료 상태가 **부모 프로세스에 의해 수거되지 않아** 프로세스 테이블에 남아 있는 프로세스입니다.

---

### ✅ **왜 좀비 프로세스가 발생할까?**

1. **자식 프로세스가 종료됨**
2. 자식 프로세스가 종료되면 **종료 상태**(exit code)를 **부모 프로세스**에게 전달해야 해요.
3. 그런데 부모가 **자식의 종료 상태를 수거하지 않으면**, 자식 프로세스는 **프로세스 테이블**에 계속 남아 있게 됩니다.

   ➡ **이 상태의 자식 프로세스가 바로 좀비 프로세스**입니다.

---

### ✅ **좀비 프로세스의 특징**

- **완전히 종료된 상태**이지만, **프로세스 테이블에 여전히 존재**
- 자원을 **소모하지 않지만**, **테이블에서 메모리 공간을 차지**하므로 계속 존재함
- 부모 프로세스가 자식 프로세스의 종료 상태를 확인하고 **`wait()` 시스템 콜**을 호출하지 않으면 계속 존재

---

### ✅ **좀비 프로세스를 해결하는 방법**

1. **부모 프로세스가 자식 프로세스의 종료 상태를 수거**하면 좀비 프로세스는 사라집니다.
   - `wait()` 시스템 콜을 호출하면 부모가 종료된 자식 프로세스의 종료 상태를 받게 되고, 프로세스 테이블에서 해당 자식 프로세스가 제거됩니다.
2. **부모가 자식의 종료 상태를 수거하지 않으면**, 이 자식은 **고아 프로세스**로 변할 수 있으며, 이때 **init 프로세스**(PID 1)가 이를 관리합니다.
   - 부모가 자식의 종료 상태를 **수거하지 않으면** `init` 프로세스가 이 종료 상태를 받아서 좀비 프로세스를 정리합니다.

---

### ✅ **좀비 프로세스 예시**

1. 부모 프로세스 **A**가 있고 자식 프로세스 **B**가 있다고 할 때:
   - **B**가 종료되고, **B**는 종료 상태를 **A**에게 전달해야 함.
   - 그런데 **A**가 **`wait()`** 시스템 콜을 호출하지 않으면 **B**는 종료되었음에도 **프로세스 테이블에 남아** 좀비 상태가 됩니다.

---

### ✅ **한 줄 요약**

> 좀비 프로세스는 종료된 후에도 부모 프로세스가 종료 상태를 수거하지 않으면 프로세스 테이블에 남아 있는 종료된 프로세스입니다.
>
> **`wait()` 시스템 콜**로 부모가 종료 상태를 받아주면 좀비 프로세스는 제거됩니다.

---

## ✅ 프로세스 제어 블록(Process Control Block, PCB)

![image](https://github.com/user-attachments/assets/2ab05f55-ce91-42d4-b2bb-ae61c4fb4cd1)

- 간단하게 생각하면 프로세스를 관리하기 위해서 생기는 블록 같은 것임!
- 프로세스 상태(Process State)
  - new, ready, running, waiting, terminated 상태 중 하나에 해당됨
- 프로그램 카운터(Program Counter)
  - 메모리의 다음 명령어 주소를 저장함
- CPU 레지스터(CPU registers)
  - IR(Instruction Register), DR(Data Register), PC(Program Counter)와 같은 저장공간이 포함됨
- CPU 스케줄링 정보(CPU-scheduling information)
  - 프로세스 실행 순서를 정하는 정보
- 메모리 관리 정보(Memory-management information)

- 통계 정보(Accounting Information)
  - 프로세스의 실행, 시간 제한, 실행 ID 등에 사용되는 CPU양의 정보
- 입/출력 상태 정보(I/O status information

## ✅ 프로세스 상태

- 프로세스는 실행되는 동안 아래와 같은 상태를 가짐

| 상태              | 설명                           |
| ----------------- | ------------------------------ |
| New               | 생성 중인 상태 (아직 실행 전)  |
| Ready             | 실행될 준비가 되어 큐에서 대기 |
| Running           | 실제로 CPU를 점유하고 실행 중  |
| Waiting (Blocked) | I/O 등 외부 작업을 기다리는 중 |
| Terminated        | 실행이 끝난 상태               |

➡ 운영체제는 이 상태 정보를 참고해서 어떤 프로세스에게 CPU를 줄지 결정함

## ✅ 왜 스케줄링이 필요한가?

- 동시에 많은 프로세스가 실행 대기 중이기 때문!
- CPU는 하나 (또는 몇 개)뿐이므로, **공정하게 시간 분배** 필요
- 사용자 경험을 좋게 하기 위해 **우선순위 기반, 응답 시간 보장** 등의 스케줄링 전략 사용

➡ 그래서 운영체제는 스케줄러를 통해 **누구를 먼저 실행할지 결정**함!

## ✅ 스레드

### 개념

- 하나의 프로세스 안에서 작업 단위를 나눈 것!

### 예시

- 멜론 앱(프로세스)안에서
  - 한 스레드는 음악 재생
  - 다른 스레드는 앨범 이미지 다운로드

### 특징

- 같은 프로세스 내부에서 여러 스레드가 실행 됨!
  - 하나의 프로세스 안에서 여러개의 스레드가 존재할 수 있음
- 메모리 공간 공유
  - 프로세스 안이니까 당연히 공유
- 생성/ 전환 비용이 작다
- 공유 메모리로 인한 충돌 가능성 있음
  - 예를 들어 같은 변수에 두개 이상의 스레드가 접근해서 수정하는 경우
    → 데이터가 꼬이게 됨!! (이를 경쟁 상태 “Race Condtion” 이라고 함)
    → 그렇기 때문에 동기화가 필요함!!

### 📝 하나로 모아보기!

| 항목     | 프로세스                | 스레드                           |
| -------- | ----------------------- | -------------------------------- |
| 개념     | 실행 중인 프로그램      | 프로세스 내부 작업 단위          |
| 메모리   | 독립된 메모리 공간      | 같은 공간 공유                   |
| 안정성   | 충돌 적음               | 충돌 가능성 있음 (공유된 데이터) |
| 생성비용 | 큼                      | 작음                             |
| 예시     | 크롬, 멜론 같은 앱 전체 | 음악 재생 + 다운로드 동시에 처리 |

![image](https://github.com/user-attachments/assets/254d19f3-ee54-41a1-bddc-373df2f01f13)

- 그림 설명
  - 이런식으로 하나의 프로레스를 집이라고 생각하고 스레드들은 안에서 일하는 사람들!
  - 집(프로레스)은 서로 독립되어 있고 집안의 사람들(스레드)은 같은 집(자원)을 쓴다!

## ✅ 멀티

### 1. 멀티프로세스

- 그림처럼 여러개의 프로세스(집)를 동시에 실행
  - ex) 멜론 프로세스도 있고 크롬 프로세스도 있는 것
- 근데 실제로는 CPU가 한번에 하나의 작업만 실행 할 수 있기 때문에
  → 운영체제가 CPU 시간을 아주 짧게 나눠서 각 프로세스에 번갈아가며 실행 시킴
  → 그래서 사람의 눈으로는 여러 프로그램이 동시에 돌아가는 것 처럼 보이는 것!!!
- 요새는 멀티코어 CPU 라고 4코어면 4개의 작업을 동시에 실행하여 병렬로 처리 가능

### 2. 멀티스레드

- 그림처럼 여러개의 스레드(사람)이 동시에 일하는 것
  - ex) 멜론 앱 안에서
    - 음악재생
    - 다운로드
    - 이미지 보여주기

### 3. 멀티태스킹

- 운영체제가 여러 작업을 동시에 처리하는 것처럼 만드는 기술! (스케줄링과는 다른 개념)
  - 멀티태스킹은 사용자 입장에서 “여러 작업이 동시에 잘 돌아가는구나~” 생각하면 되는거고
  - 스케줄링은 운영체제 입장에서 “어느 작업을 먼저 실행 시키고 몇 초정도를 줄까?” 라고 생각
    - 한 마디로 멀티태스킹은 그냥 우리가 보는 결과물, 스케줄링은 가능하게 하는 내부 기술

# 📌 컨텍스트 스위칭

## ✅ 개념

- CPU가 현재 실행 중인 작업(프로세스 또는 스레드)의 상태를 저장하고, 다른 작업으로 전환할 때 상태를 복원하는 과정

## ✅ 컨텍스트 스위칭의 흐름

1. 프로세스 A 실행 중 B는 실행을 기다리고 있는 상태
2. 운영체제가 프로세스 B를 실행하겠다고 함
3. 그러면 현재의 A의 상태를 저장
4. B의 상태를 복원하여 실행

- 예시
  → vscode로 코딩 중인데 알림창(크롬 알림)이 뜸
  → CPU가 그러면 잠깐 알림창 쪽으로 전환
  → 작업 상태 저장/불러오기를 하면서 컨텍스트 스위칭 발생

## ✅ 언제 발생하는가?

- 주어진 Time Slice를 다 사용했을 때
  - 무슨 얘기냐면 CPU는 각 프로세스에 일정 시간만 할당함
  - 이 시간이 끝나면 다음 프로세스에게 CPU를 넘겨줘야 하므로 발생
- I/O 작업을 해야할 때
  - 파일 읽기, 프린트 출력 등을 요청할 때
  - CPU는 대기할 필요 없이 다른 작업에게 넘겨주기 때문에 발생
- 다른 리소스를 기다려야 할 때
  - CPU 외에 잠깐 접근할 수 없는 리소스(메모리, 락, DB 등)를 기다려야 한다면?
  - CPU가 현재 프로세스를 멈추고 다른 프로세스 할당해서 발생!
- 인터럽트 (간단 설명 : 일하던 중 끼어들기!)

  - 외부 장치나 시스템 이벤트(키보드 입력, 타이머 알람)가 발생하면
  - 현재 실행 중인 작업을 멈추고 처리할 작업으로 전환할 때 발생

- 공통점
  - CPU를 더 이상 쓸 수 없거나 운영체제가 다른 작업 먼저 처리하겠다고 판단할 때 발생!!!

## ✅ 사용 이유

- 여러 프로세스와 스레드들을 동시에 실행시키기 위해(그렇게 보이기 위해)
- 여러 프로세스와 스레드들이 공정하게 CPU 시간을 나눠 갖기 위해
- 높은 우선순위의 작업이 빠르게 처리될 수 있게

## ✅ 주의할 점 (오버헤드)

- 컨텍스트 스위칭은 상태 저장/복원 때문에 **시간이 소모됨**
- 너무 자주 발생하면 오히려 성능 저하가 생김 → **오버헤드 발생**

### 캐시 오염 (Cache Pollution)

- 컨텍스트 스위칭이 일어나면 CPU 캐시에 저장된 데이터도 바뀌게 됨
- 자주 바뀌면 자주 쓰던 데이터가 밀려나서 캐시 성능이 떨어짐
  → 이게 바로 ‘캐시오염’ 인거임!
- 결국 스위칭이 너무 잦으면 캐시 적중률이 낮아지고 전체 시스템 성능이 하락할 수 있음
