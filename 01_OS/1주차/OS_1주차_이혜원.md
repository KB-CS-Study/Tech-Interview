### `📌 운영체제의 역할 (프로세스 관리, 메모리 관리, 파일 시스템 등)`

1. 운영체제란?
   - `실행 중인 프로그램`(프로세스)을 관리하는 특별한 프로그램
   - 컴퓨터 사용자와 컴퓨터 하드웨어 간의 **중개 역할**을 하는 프로그램
   - 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공
      - 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상을 제공
      - 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행
   - 하드웨어를 관리하고, 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 응용 프로그램과 하드웨어 간의 인터페이스로서 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공해준다.
   - 
2. 운영체제의 역할


    | **구분** | **설명** |
    | --- | --- |
    | **프로세스 관리** | 프로세스 스케줄링 및 동기화 담당, 프로세스 생성과 제거, 시작과 정지, 메세지 전달등 기능 담당 |
    | **기억장치 관리** | 각 프로세스에 적절히 메모리를 할당/회수 |
    | **주변장치 관리** | 입출력 장치 스케줄링 및 전반적인 관리 담당 |
    | **파일관리** | 파일의 생성과 삭제, 변경, 유지 등의 관리 담당 |
    | **사용자/보안 관리** | 권한, 계정, 접근 제어 등 |
    | **디바이스 드라이버** | 하드웨어를 제어할 수 있도록 인터페이스 제공 |

*  📂 **[개발자가 알아야하는 이유]**

- 프로그램이 실행되기 위해 마땅히 필요한 요소를 알아야하기 때문
- 운영체제는 실행 중인 프로그램을(자원) 관리하는 특별한 프로그램
- 웹 서버에서 동시에 요청을 처리하기 때문

### `📌 커널(User Mode vs Kernel Mode)`

1. 커널이란?
   - 운영체제의 핵심
   - 프로그램과 하드웨어 사이를 연결해주는 관리자이자 통제자 역할
   - 사용자 요청(System Call)을 받아서 하드웨어 자원에 접근하고 제어

   | **역할** | **설명** |
       | --- | --- |
   | **자원 관리자** | CPU, 메모리, 입출력장치, 디스크 등을 적절히 배분 |
   | **명령 중계** | 우리가 요청한 걸 하드웨어가 알아듣게 중계 |
   | **보호자** | 사용자 프로그램이 하드웨어를 직접 만지지 못하게 함 |
   | **시스템 콜 처리** | 우리가 호출한 기능(ex. 파일 저장)을 실행해줌 |
2. User Mode
   - 응용 프로그램이 실행되는 영역
   - 자원 접근이 제한된 안전한 공간
      - 메모리, 디바이스 등 직접 접근 불가
   - 하드웨어 자원이 필요할 경우, 커널에 System Call 해야 함
   - 우리가 사용하는 브라우저, 게임, 워드프로세서 등은 User Mode에서 실행 됨
3. Kernel Mode
   - 운영체제 커널이 실행되는 특권 영역
   - 모든 자원(CPU, 메모리, 드라이버)에 접근 가능
   - 응용 프로그램이 요청한 작업을 커널이 대신 수행해줌

*  📂 **[개발자가 알아야하는 이유]**

- CPU, 메모리, 파일 등 모든 자원 접근은 커널을 통해서만 이루어짐
- 실제 파일 저장, 스케줄링, 장치 제어 등을 커널이 관리하기 때문
- 성능 이슈나 병목이 커널과 연결될 수 있음 (ex. 컨텍스트 스위칭, 스케줄링)

### `📌 프로세스 vs 스레드 (멀티 프로세스, 멀티 스레드)`

1. 프로그램
   - 메모리에 올라오지않은 정적인 상태
2. 프로세스 : 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
   - 운영체제로부터 시스템 자원을 할당받는 작업의 단위

![image.png](attachment:4fd6cc0e-8437-4427-b721-346ebbfba4e7:image.png)


![image.png](attachment:15fbe609-90e7-4665-a05d-813f50e90e54:image.png)

1. 멀티 프로세스 : 하나의 응용 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(태스크)를 처리하도록 하는 것
   - 장점 : 여러 개 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산 되지 않는다
   - 단점 : `컨텍스트 스위칭` 에서의 오버헤드 프로세스는 각각의 독립된 메모리 영역을 할당 받았기 때문에 프로세스 사이에 공유하는 메모리가 없어, `컨텍스트 스위칭` 이 발생하면 캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 한다
2. 스레드 : 프로세스 내에서 실행되는 여러 흐름의 단위
   - 프로세스가 할당받은 자원을 이용하는 실행의 단위
3. 멀티 스레드 : 하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것이다. 윈도우, 리눅스 등 많은 운영체제들이 멀티 프로세싱을 지원하고 있지만 멀티 스레딩을 기본으로 하고 있다.
   - 대표적 멀티 스레드 응용 프로그램 : 웹서버
4. 멀티 프로세스 대신 멀티 스레드를 사용하는 이유
   - 스레드는 프로세스 내의 메모리를 공유하기 때문에 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들기 때문에 자원 효율성 증대
      - 프로세스는 독립적
   - 프로세스 간의 통신보다는 스레드 간의 통신 처리 비용이 적으므로 작업들 간의 통신 부담이 줄어든다
      - 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문
      - `컨텍스트 스위칭` 시 스레드는 Stack 영역만 처리하기 때문

📂 **[개발자가 알아야하는 이유]**

- 멀티스레드를 사용하는 이유는 사용자와 상호작용하는 애플리케이션에서 단일 스레드로 Network 또는 DB와 같은 긴 작업을 수행하는 경우 해당 작업을 처리하는 동안 사용자와 상호 작용이 불능인 상태가 될 수 있기 때문이다.

### `📌 PCB(Process Controll Block)`

![image.png](attachment:318d4fef-9266-4cff-aaf8-9bd812f77910:image.png)

- 프로세스 메타데이터들을 저장해 놓는 곳(프로세스 전체에 대한 정보를 담음)
- 하나의 PCB안에는 하나의 프로세스의 정보가 담겨있다.
- CPU에서 프로세스의 상태에 따라 교체 작업이 이루어지기 떄문에 PCB가 필요
- Linked List 방식으로 관리됨

1. **PCB에 저장되는 정보**

| **항목** | **설명** |
| --- | --- |
| Process ID (PID) | 프로세스 고유 식별 번호 (중복 없음) |
| Process State | 현재 프로세스 상태 (준비, 실행, 대기 등) |
| Process Priority | 스케줄링 우선순위 등 관련 정보 |
| CPU Registers | 현재 프로세스의 레지스터 상태 저장 (AX, BX, SP, BP 등) |
| Owner | 해당 프로세스를 실행한 사용자(계정) 정보 |
| Memory Management Info | 메모리 상한/하한, 페이지 테이블 등 메모리 관련 정보 |
| I/O Info | 열려 있는 파일, 사용 중인 입출력 장치 등 |
| Program Counter (PC) | 다음에 실행될 명령어의 주소 |

📂 **[개발자가 알아야하는 이유]**

- 앞으로 다시 수행할 Block 상태의 프로세스의 상태 값을 PCB에 저장해두기 때문에 알아야한다.
   - CPU에서는 프로세스의 상태에 따라 교체 작업이 이루어지며, 인터럽트가 발생해서 할당받은 프로세스가 Block 상태가 되고 다른 프로세스를 running으로 바꿔진다.

### `📌 TCB(Thread Control Block)`

1. TCB란?
   - 스레드의 상태를 저장하고 관리하기 위한 데이터 구조
   - 스레드마다 하나씩 존재
2. TCB 구조

| **항목** | **설명** |
| --- | --- |
| **TID (Thread ID)** | 스레드 고유 번호 |
| **스레드 상태** | 실행 중 / 준비 / 대기 등 |
| **레지스터 값** | CPU 레지스터 (일반/스택/PC 등) |
| **스택 포인터** | 각 스레드는 독립된 스택을 가짐 |
| **우선순위** | 스케줄링 시 우선순위 판단 기준 |
| **프로그램 카운터 (PC)** | 다음에 실행할 명령어 위치 |
| **(소속 프로세스 ID)** | 자신이 속한 프로세스와의 연결 정보 |

3. PCB와 다른 점
- PCB: 프로세스 1개당 1개
- TCB : 스레드 1개당 1개(스레드 수만큼 존재)
- 스레드들은 ‘한 프로세스의 자원’을 공유하고, 실행 흐름 정보는 따로 관리하기 위해 자신만의 TCB를 가진다.

📂 **[개발자가 알아야하는 이유]**

- 프로세스 자원은 공유하지만, 실행 상태(레지스터, 스택 등)는 독립적으로 관리된다
- 멀티스레드 환경에서 발생할 수 있는 자원 충돌이나 동기화 문제를 방지할 수 있다
- 서버나 병렬 처리 시스템을 개발할 때, 공유 자원 접근에 주의를 기울여 안정적인 코드를 작성할 수 있다

### `📌 Context Switching`

1. `컨텍스트 스위칭` : CPU가 현재 실행 중인 Task(프로세스, 스레드)의 Context(상태)를 저장하고, 다음 실행할 프로세의 상태를 복원하는 작업
   - 다음에 진행할 Task의 상태 및 Register 값들에 대한 정보를 읽어 새로운 Task의 Context 정보로 교체하는 과정
   - 이전 프로세스 상태를 PCB에 보관하고, 다음 프로세스 정보를 PCB에 읽어서 레지스터에 적재
   - 이 과정을 통해 CPU는 **마치 동시에 여러 작업을 처리하는 것처럼** 보이게 됨 (시분할)
   - 단점 : Overhead(비용) 발생해 효율(성능) 떨어진다.
      - Context Switching 시 해당 CPU는 아무런 일을 하지 못하기 때문
2. `Context Switching`이 발생하는 이유
   - **멀티태스킹** 환경에서 CPU는 한 번에 하나의 프로세스만 실행 가능
   - 하지만 여러 프로세스를 번갈아 가며 빠르게 실행시켜 사용자에게 “동시 실행”처럼 보이게 함
   - CPU는 주기적으로 또는 이벤트 발생 시 **작업을 전환**해야 함 → 이때 `Context Switching` 발생
3. `Context Switching` 수행 과정
   - 프로그램 실행 -> 프로세스 생성 -> 프로세스 주소 공간에 (코드, 데이터, 스택) 생성 -> 이 프로세스의 메타데이터들이 PCB에 저장
- OS와 PCB가 복잡할수록 Context Switch가 길어짐
- 하드웨어 지원에 따라 시간이 달라짐
- 일부 하드웨어는 CPU당 여러 개의 레지지스터 세트를 제공

*  📂 **[개발자가 알아야하는 이유]**

- 컴퓨터가 매번 하나의 Task만 처리할 수 있으면, 반응 속도가 느려 사용하기 불편하기 때문에 Context Swtiching이 필요하게 됨
- 컨텍스트 스위칭은 지연을 야기하므로, 실시간 시스템에서 제어 대상이 됨

### `📌 IPC(Inter Process Communication)`

![image.png](attachment:7b5f4829-c835-4cf7-80ce-4a05b4214910:image.png)

1. IPC란?
- 서로 다른 프로세스끼리 데이터를 주고 받는 방식
- 독립된 메모리 공간을 갖는 프로세스들이 IPC를 통해 데이터를 주고 받음

2. IPC 종류

| **방식** | **설명** | **특징** |
| --- | --- | --- |
| **1. 파이프 (Pipe)** | 부모-자식 프로세스 간 단방향 통신 | 간단하지만 제한적 (단방향, 같은 부모) |
| **2. 이름 있는 파이프 (Named Pipe / FIFO)** | 별도의 이름을 가진 파이프, 다른 프로세스 간 통신 가능 | 파일 시스템 기반, 양방향 가능 |
| **3. 메시지 큐 (Message Queue)** | 커널이 메시지를 큐 형태로 중간 보관 | 느리지만 구조적 데이터 전송 가능 |
| **4. 공유 메모리 (Shared Memory)** | 두 프로세스가 같은 메모리 공간 일부를 공유 | 가장 빠름, 동기화 필요 (세마포어 같이 사용) |
| **5. 소켓 (Socket)** | 네트워크 통신 기반 IPC (localhost 포함) | 원격/로컬 둘 다 가능, TCP/UDP 선택 가능 |
| **6. 시그널 (Signal)** | OS가 보내는 이벤트 알림 (ex: Ctrl+C) | 데이터 전달 X, 상태 알림 용도 |

3. IPC 통신모델

| **항목** | Message Passing | Shared Memory |
| --- | --- | --- |
| **정의** | 커널이 두 프로세스 간 메시지를 전달해주는 방식 | 두 프로세스가 메모리 공간 일부를 공유하여 직접 접근 |
| **속도(성능)** | 느림 (커널을 통해 전달) | 빠름 (직접 메모리 접근) |
| **안정성** | 안전함 (OS가 관리) | 위험할 수 있음 (직접 접근) |
| **동기화 처리** | OS가 자동으로 처리 (동기화 문제 적음) | 개발자가 직접 처리 필요 (경쟁 조건 발생 가능) |
| **커널 관여도** | 높음 (모든 통신이 커널을 거침) | 낮음 (초기 공유 메모리 설정 이후 직접 처리) |
| **통신 형태** | 간접적 (운영체제가 중개) | 직접적 (메모리 공간 공유) |
| **예시 시스템** | 메시지 큐, 파이프, 소켓 등 | POSIX Shared Memory, mmap 등 |
| **주 사용처** | 안정성이 중요한 시스템 (간단한 제어, 제어 신호) | 성능이 중요한 시스템 (대용량 데이터 처리 등) |

*  📂 **[개발자가 알아야하는 이유]**

- 서로 다른 프로그램이나 시스템 구성 요소 간에 데이터를 안전하게 주고받고, 병렬 처리나 멀티프로세스 환경에서 협업이 가능해지기 때문

## 💬 면접 질문 정리

1. 프로세스가 무엇인가요?

A. 운영체제로부터 시스템 자원을 할당받는 작업의 단위입니다.

2. 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.

A. 프로그램은 실행되지 않은 정적 코드이고, 프로세스는 프로그램이 실행되어 메모리에 올라간 독립적인 실행 단위 입니다. 스레드는 프로세스 내에서 실행되는 작업 흐름으로, 여러 스레드는 같은 프로세스의 자원을 공유할 수 있습니다.

| **구분** | **설명** |
| --- | --- |
| 프로그램 (Program) | 실행되지 않은 정적인 상태의 코드 |
| 프로세스 (Process) | 실행 중인 프로그램. OS가 자원을 할당해서 독립적으로 수행 |
| 스레드 (Thread) | 프로세스 내부에서 실행되는 작업의 흐름(실행 단위) |

3. PCB가 무엇인가요?

A. PCB(Process Controll Block), 프로세스 메타데이터들을 저장해 놓는 곳입니다. 하나의 PCB안에는 하나의 프로세스의 정보가 담겨있습니다. CPU에서 프로세스의 상태에 따라 교체 작업이 이루어지기 때문에 PCB가 필요합니다.

4.. 그렇다면, 스레드는 PCB를 갖고 있을까요?

A. 아니요. 스레드는 소속된 프로세스의 PCB를 공유하고 있지만, 자기 실행 흐름에 필요한 TCB는 개별적으로 갖고 있습니다. 그래서 레지스터, 스택 등의 정보를 관리합니다.

5.  컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?

A. 현재 실행 중인 작업의 상태를 저장하고, 다음 실행할 작업의 상태를 불러온 뒤, 새 작업으로 CPU를 전환합니다. 해당 작업들을 계속 반복하면서 CPU가 마치 여러 작업을 동시에 처리하는 것처럼 보이게 합니다.

6. 프로세스와 스레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?

A. 스레드 간 컨텍스 스위칭이 발생할 때 훨씬 가볍고 빠릅니다. 왜냐하면, 프로세스는 주소 공간까지 바꿔야하지만 스레드에서 발생할 때는 스택과 레지스터 정도만 바꾸면 되기 때문입니다. 그래서 고성능 서버나 병렬처리에서는 멀티스레드를 많이 사용합니다.

8. 컨텍스트 스위칭은 언제 일어날까요?

A. CPU는 동시에 한가지 작업만 처리할 수 있지만, 사용자가 시스템의 수많은 작업을 “동시에” 하길 원할 때 일어납니다. 운영체제가 작업 간의 전환을 할 때 CPU에게 일을 시키기 때문입니다.

9. IPC가 무엇이고, 어떤 종류가 있는지 설명해 주세요.

A. IPC는 서로 다른 프로세스가 데이터를 주고 받기 위한 통신 방식입니다. 대표적으로 파이프, 메시지 큐, 공유 메모리, 소켓 등이 있으며, 각각의 방식은 통신 방향, 성능, 범용성 측면에서 차이가 있습니다.

10. Shared Memory가 무엇이며, 사용할 때 유의해야 할 점에 대해 설명해 주세요.

   A. 두 프로세스 간 공유된 메모리를 생성 후 이용하는 것입니다. 성능이 좋지만, App에서 직접 동기화를 해줘야하기에 이 점을 유의해야 합니다.

11. 메시지 큐는 단방향이라고 할 수 있나요?

   A. 네 단방향 통신 구조입니다. 사용할 데이터에 번호를 붙이면서 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있습니다.


참고자료 : https://www.youtube.com/watch?v=C26akmY9a_Q

https://github.com/VSFe/Tech-Interview/blob/main/02-OPERATING_SYSTEM.md

https://jeong-pro.tistory.com/93

[https://github.com/Songwonseok/CS-Study/blob/main/OS/PCB Context Switching.md](https://github.com/Songwonseok/CS-Study/blob/main/OS/PCB%20Context%20Switching.md)