### [1주차] 운영체제 개요 + 프로세스 & 스레드

- 컴퓨터 구성 요소
- 운영체제의 역할
- 커널(User Mode vs Kernel Mode)
- 프로세스의 구조
- 프로세스 vs 스레드
- 멀티프로세싱(Multiprocessing)
- 멀티스레딩(Multithreading)
- 컨텍스트 스위칭

---

<br>

## 🔵 컴퓨터 구성 요소: Top-Level View

![컴퓨터 구성 요소](https://firebasestorage.googleapis.com/v0/b/portfolio-74c3d.appspot.com/o/CS-study%2F01-1.png?alt=media&token=3bd5b739-b1d0-4808-9bc0-7f301e1d1169)

컴퓨터 시스템은 CPU, 메모리, I/O 모듈이 **System Bus** 를 통해 연결되어 있으며, 운영체제는 이 자원들을 효율적으로 관리한다.

### 주요 구성 요소

#### 1. CPU (Central Processing Unit)

- **PC**: 다음에 실행할 명령어의 주소
- **IR**: 현재 실행 중인 명령어
- **MAR**: 접근할 메모리 주소
- **MBR**: 메모리에서 읽거나 쓸 데이터
- **I/O AR, I/O BR**: 입출력 주소 및 버퍼
- **Execution Unit**: 실제 연산 수행

#### 2. Main Memory

- 명령어와 데이터를 저장하는 공간
- 주소를 통해 위치 지정

#### 3. I/O Module

- CPU와 장치 간 데이터 전달
- 버퍼로 속도 차 조절

#### 4. System Bus

- 주소 버스, 데이터 버스, 제어 버스로 구성

---

<br><br>

## 🔵 운영체제의 역할

운영체제는 하드웨어 자원(CPU, 메모리, 파일 등)을 효율적이고 안정적으로 관리하는 시스템 소프트웨어이다. 주요 역할은 다음과 같다:

### 1. 프로세스 관리

운영체제는 여러 프로세스가 공정하게 CPU를 사용할 수 있도록 스케줄링하고, 상태를 추적하며, 컨텍스트 스위칭을 통해 프로세스를 전환한다.

#### 프로세스 상태와 전이

![프로세스 상태](https://firebasestorage.googleapis.com/v0/b/portfolio-74c3d.appspot.com/o/CS-study%2F01-2.png?alt=media&token=c45f13d0-e8f8-40cd-83a0-802184c06d02)

- **New**: 생성 중
- **Ready**: 실행 준비 완료, 대기 중
- **Running**: 명령어 실행 중
- **Blocked**: 이벤트 대기 중
- **Exit**: 종료됨

**상태 전이 예시**

- `Admit`: New → Ready
- `Dispatch`: Ready → Running
- `Timeout`: Running → Ready
- `Event Wait`: Running → Blocked
- `Event Occurs`: Blocked → Ready
- `Release`: Running → Exit

#### PCB (Process Control Block)

운영체제는 각 프로세스를 추적하기 위해 PCB를 사용한다.  
PCB는 다음 정보를 포함한다

| 항목            | 설명                          |
| --------------- | ----------------------------- |
| Process State   | 현재 상태 (Ready, Running 등) |
| Process ID      | 고유한 식별자                 |
| Program Counter | 다음 실행할 명령어 주소       |
| CPU Registers   | 레지스터 값 저장              |
| Memory Info     | 메모리 주소 범위 등           |
| I/O Info        | 열려 있는 파일/디바이스 등    |

#### 운영체제의 프로세스 관리 구조

운영체제는 단순히 PCB 하나로만 프로세스를 관리하는 것이 아니라,  
**메모리 / 입출력 / 파일 시스템**에 대한 정보를 포함한 **다양한 제어 테이블**을 함께 사용한다.

![운영체제 테이블 구조](https://firebasestorage.googleapis.com/v0/b/portfolio-74c3d.appspot.com/o/CS-study%2F01-3.png?alt=media&token=8d0a495e-3278-4c4c-abe1-16b653ed1c21)

위 그림은 OS가 내부적으로 유지하는 **Control Tables** 구조를 나타낸 것이다.

- **Memory Tables**: 각 프로세스가 사용하는 메모리 영역과 접근 권한 정보 저장
- **I/O Tables**: 어떤 장치를 어느 프로세스가 사용하는지 정보 기록
- **File Tables**: 열려 있는 파일, 파일 포인터, 접근 모드 등 저장
- **Primary Process Table**: 현재 실행 중인 모든 프로세스들의 PCB를 보관

이러한 구조는 **링크드 리스트** 형태로 구성되며,  
운영체제가 동시에 실행 중인 프로세스를 **효율적으로 관리**하기 위해 사용된다.

> 각 프로세스는 독립된 **Process Image**를 가지고 있으며,  
> 이는 코드, 데이터, 스택, PCB 정보를 포함한 프로세스의 전체 상태를 의미한다.

---

### 2. 메모리 관리

운영체제는 프로세스마다 메모리 공간을 분리하고 보호하며, 가상 메모리를 통해 더 큰 주소 공간을 제공한다.

- 주소 변환(MAR, MBR)
- 프로세스 간 메모리 보호
- 물리 메모리 ↔ 가상 메모리 관리

---

### 3. 파일 시스템 관리

운영체제는 파일 생성/삭제, 이름 지정, 접근 권한 등 파일 관련 기능을 제공한다.  
파일 시스템은 디스크 상의 데이터에 대한 추상화 계층을 제공하며, 사용자가 파일을 디렉토리 구조로 관리할 수 있도록 한다.

---

<br><br>

## 🔵 커널(User Mode vs Kernel Mode)

### 커널이란?

- 커널은 운영체제의 핵심으로, **프로세스, 메모리, 파일, I/O 등의 자원을 직접 제어**함
- 사용자 프로그램은 커널을 직접 조작할 수 없고, **시스템 콜(System Call)** 을 통해 간접적으로 요청함

### 쉘(Shell)이란?

- **쉘은 사용자와 커널 사이의 인터페이스**
- 사용자가 명령어를 입력하면, 쉘은 이를 **시스템 콜로 번역**해 커널에 전달함
- 크게 두 종류
  - **Command-line Shell**: bash, zsh 등
  - **Graphical Shell**: Windows Explorer, macOS Finder 등 GUI 기반

### User Mode vs Kernel Mode

| 구분      | User Mode                     | Kernel Mode                          |
| --------- | ----------------------------- | ------------------------------------ |
| 권한 수준 | 제한적                        | 모든 하드웨어 자원 접근 가능         |
| 코드 실행 | 사용자 애플리케이션           | 운영체제 커널 코드                   |
| 예시      | 일반 앱, 프로세스             | 시스템 콜 처리, 드라이버 실행 등     |
| 전환 방법 | 시스템 콜 (trap), 인터럽트 등 | 사용자 프로그램에 제어 반환 (return) |

> 사용자 프로그램이 시스템 자원을 사용하려면 커널 모드로 전환이 필요함

### 커널의 주요 역할

커널은 항상 메모리에 상주하는 운영체제의 핵심이 되는 부분입니다. 컴퓨터 자원을 관리하는 자원 관리자로서 대표적으로 다음 4가지 기능을 가지고 있다. 커널은 사용자가 물리적인 하드웨어에 접근하고 사용할 수 있도록 하기 위한 목적을 가지고 있고, 사용자가 쉘(Shell)을 통해 입력한 명령어를 해석하여 하드웨어에 전달해주는 역할을 한다.

1. **메모리 관리**

   각 프로그램이 어디에서, 무엇을, 얼마나 사용하는지를 추적하고. 메모리 자원을 할당하는 역할을 한다.
   가상 메모리를 사용할 수 있도록 한다.

2. **프로세스 관리 및 CPU 스케쥴링**

   사용자가 시스템에 로그인 함과 동시에 수많은 프로세스가 실행되는데, 커널은 CPU의 시간 자원을 배분하는 역할 - 어떤 프로세스가 언제, 얼마나 사용할지 - 을 하여 여러 개의 프로세스가 동시에 동작하는 것처럼 보이게 합니다.

3. **디바이스 관리**

   컴퓨터에 연결된 장치들을 드라이버라는 매개체를 통해서 제어하고 관리한다.

4. **시스템 콜 인터페이스 및 보안**

   시스템 콜을 제공하여 응용 프로그램 - 프로세스의 서비스 요청을 수신한다.

### 커널 구조 유형

| 구조          | 특징                                     | 예시 운영체제  |
| ------------- | ---------------------------------------- | -------------- |
| 모놀리식 커널 | 모든 기능이 하나의 커널 내에 포함        | Linux, Unix    |
| 마이크로커널  | 최소 기능만 커널에, 나머지는 사용자 공간 | Minix, QNX     |
| 하이브리드    | 두 구조의 장점을 절충                    | Windows, macOS |

### 시스템 콜 예시

- `fork()` : 새로운 프로세스 생성
- `exec()` : 다른 프로그램 실행
- `read()`, `write()` : 파일 I/O
- `kill()` : 프로세스 종료 요청

---

<br><br>

## 🔵 프로세스의 구조

### 프로세스 vs 프로그램

- **프로그램**: 하드디스크에 저장된 정적인 명령어 집합
- **프로세스**: 실행 중인 프로그램, 메모리에 적재된 상태

> 하나의 컴퓨터에서 여러 프로세스가 동시에 실행될 수 있으며, 각 프로세스는 자신만의 코드, 데이터, 스택, 레지스터를 가진다.

프로세스는 메모리에 다음과 같은 형태로 구성된다. 이를 **프로세스 이미지 (Process Image)** 라고 하며, 운영체제는 이 전체 상태를 관리한다.

![프로세스 이미지](https://firebasestorage.googleapis.com/v0/b/portfolio-74c3d.appspot.com/o/CS-study%2F01-5.png?alt=media&token=2bb7fa23-4d83-4f0b-bce6-0bb7c08d4fde)

| 영역           | 설명                                                                                                |
| -------------- | --------------------------------------------------------------------------------------------------- |
| **PCB**        | 프로세스의 상태를 저장하는 커널 영역                                                                |
| **Text(Code)** | 실행할 프로그램의 명령어 (코드 영역)<br>→ Private User Address Space 내부에 포함됨                  |
| **Data**       | 전역 변수(static 변수 포함) 저장<br>→ Private User Address Space 내부에 포함됨                      |
| **Heap**       | 동적으로 할당되는 메모리 영역 (e.g., malloc)<br>→ Private User Address Space 내부에 포함됨          |
| **Stack**      | 함수 호출 시 지역 변수, 리턴 주소 등이 저장되는 영역<br>→ User Stack과 Kenel Stack 두 부분으로 나뉨 |

> 운영체제는 이 정보를 기반으로 **프로세스를 메모리에 적재하고**, 필요한 시점에 **스케줄링/복원/삭제** 등을 수행한다.

---

<br><br>

## 🔵 프로세스 vs 스레드

### 프로세스(Process)

- **자원 소유의 단위 (Unit of Resource Ownership)**
- **스케줄링/실행의 단위 (Unit of Execution)**
- 하나의 프로세스는 고유한 **코드, 데이터, 스택, PCB**를 가진다.
- 운영체제는 각 프로세스를 독립적으로 관리한다.

### 스레드(Thread)

- **실행의 단위만 분리됨** (Dispatching Unit)
- 자원은 **프로세스와 공유**, 스택은 **스레드마다 개별**
- 하나의 프로세스 내에서 여러 스레드가 생성되어 실행될 수 있음

> 즉, **자원은 프로세스 단위로 소유**, **실행은 스레드 단위로 분화**됨

### 프로세스 vs 스레드 비교

| 항목               | 프로세스                              | 스레드                                |
| ------------------ | ------------------------------------- | ------------------------------------- |
| 자원 소유          | 독립적으로 가짐                       | 동일 프로세스 내 자원 공유            |
| 실행 단위          | 독립적인 실행 흐름                    | 프로세스 내의 실행 흐름               |
| 메모리 공간        | 각각 독립적                           | 코드/데이터 영역은 공유, 스택만 개별  |
| 문맥 교환 비용     | 크다                                  | 작다                                  |
| 생성/종료 오버헤드 | 큼                                    | 작음                                  |
| 안정성             | 하나가 죽어도 다른 프로세스 영향 없음 | 하나가 죽으면 전체 프로세스 영향 가능 |

### 스레드의 장점과 단점

#### 장점

- 자원 공유로 **문맥 교환 비용이 작음**
- **빠른 통신 및 협업** 가능 (shared memory)
- 병렬 처리를 통해 **멀티코어 활용 효율적**

#### 단점

- **동기화 문제(Race condition)** 발생 가능
- **하나의 스레드 오류로 전체 프로세스가 중단될 수 있음**
- 디버깅과 유지보수가 복잡함

---

<br><br>

## 🔵 멀티프로세싱(Multiprocessing)

- **여러 개의 프로세스**를 생성하여 동시에 실행하는 방식
- 각 프로세스는 **독립적인 주소 공간**과 자원을 가짐
- 일반적으로 **멀티코어 CPU에서 병렬 처리**를 위해 사용됨

> 하나의 CPU에서 멀티프로세싱을 할 경우는 시분할 방식(time sharing),  
> 멀티코어 CPU에서는 진짜 동시 실행(parallel execution)이 가능

---

<br><br>

## 🔵 멀티스레딩(Multithreading)

### 정의

- 하나의 프로세스 내에서 **여러 실행 흐름(스레드)** 을 가지는 것
- 각 스레드는 **독립적인 실행 스택**을 가지지만, **공통 주소 공간을 공유**함

### 운영체제별 스레드 지원 방식

| 운영체제             | 설명                                                         |
| -------------------- | ------------------------------------------------------------ |
| **MS-DOS**           | 하나의 프로세스에 하나의 스레드만 지원                       |
| **UNIX (old)**       | 여러 프로세스는 가능, 하지만 프로세스당 1스레드              |
| **Modern UNIX 계열** | 하나의 프로세스에서 여러 스레드 지원 (ex. Linux, Solaris 등) |

### 스레드의 구조

#### 하나의 스레드는 다음 정보를 가짐

- **Execution State**: running, ready 등
- **Thread Context**: 스레드 실행 시 CPU 레지스터 저장
- **Execution Stack**: 지역 변수 저장
- **Static Storage for Local Variables**
- **Memory/Resource 접근**: 같은 프로세스의 스레드끼리는 공유

> 즉, 프로그램 코드/데이터는 공유하고, **스택과 context는 개별**

### 멀티프로세싱 vs 멀티스레딩

| 항목           | 멀티프로세싱                   | 멀티스레딩                       |
| -------------- | ------------------------------ | -------------------------------- |
| 실행 단위      | 여러 프로세스                  | 하나의 프로세스 내 여러 스레드   |
| 주소 공간      | 각각 독립                      | 공유됨                           |
| 메모리 사용량  | 크다                           | 상대적으로 작다                  |
| 문맥 교환 비용 | 크다                           | 작다                             |
| 통신 방식      | IPC (Pipe, Socket 등)          | 공유 메모리                      |
| 안정성         | 하나가 죽어도 나머지 영향 없음 | 하나가 죽으면 전체 프로세스 위험 |

---

- **멀티프로세싱 예시**: 웹 서버에서 여러 클라이언트를 처리할 때, 아예 독립된 서버 인스턴스를 띄우는 방식
- **멀티스레딩 예시**: 게임 프로그램에서 그래픽 처리, 사운드, 물리 엔진을 각각 스레드로 처리

### 싱글 스레드 vs 멀티 스레드 모델

<p align="center">
  <img src="https://firebasestorage.googleapis.com/v0/b/portfolio-74c3d.appspot.com/o/CS-study%2F01-7.png?alt=media&token=d3a4c6f5-00d8-4367-b341-3aaeb214ec9c" width="45%" />
  <img src="https://firebasestorage.googleapis.com/v0/b/portfolio-74c3d.appspot.com/o/CS-study%2F01-8.png?alt=media&token=610f4412-a9e8-4cb3-8ffc-7177aeb36e3d" width="45%" />
</p>

- **Single Threaded Process**
  - PCB + User Stack + Kernel Stack + User Address Space
- **Multithreaded Process**
  - 하나의 PCB + 여러 TCB + 각 스레드별 스택
  - 코드/데이터/주소 공간은 공유됨

> 멀티스레드 프로세스는 `PCB + TCB1 + TCB2 + ...` 의 형태로 관리됨

---

<br><br>

## 🔵 컨텍스트 스위칭

### 컨텍스트 스위칭이란

CPU가 하나의 프로세스/스레드 실행을 중단하고, 다른 프로세스/스레드로 전환할 때의 작업 전체

이 과정에서 이전 작업의 상태(context)를 저장하고, 다음 작업의 상태를 복원하는 작업이 수행됨

### 컨텍스트 스위칭이 필요한 이유

- **멀티태스킹**: 여러 작업을 동시에 실행하는 것처럼 보이게 하기 위해

- **시분할 시스템**: 각 프로세스에 CPU 시간을 분배하기 위해

- **인터럽트 처리**: I/O 이벤트가 발생하면 다른 프로세스로 전환

- **우선순위 변경**: 더 중요한 프로세스를 우선 실행하기 위해

### 프로세스 컨텍스트 스위칭 과정

![프로세스 컨텍스트 스위칭](https://firebasestorage.googleapis.com/v0/b/portfolio-74c3d.appspot.com/o/CS-study%2F01-9.png?alt=media&token=e640fa10-471b-4670-9955-0a9e68a664a2)

    1.	현재 실행 중인 프로세스(p0)에 인터럽트 or 시스템 콜 발생
    2.	운영체제가 p0의 실행 상태를 PCB0에 저장
    3.	스케줄러가 다음 실행할 프로세스(p1)를 선택
    4.	p1의 실행 상태를 PCB1에서 복원
    5.	CPU 제어권을 p1에게 넘김 → p1 실행 시작

이후에도 p1이 인터럽트를 받으면 다시 p0 등으로 전환될 수 있음

### 컨텍스트 스위칭 시 저장되는 정보

- 프로그램 카운터 (PC)
- 레지스터 값 (R0~Rn)
- 스택 포인터 (SP)
- 프로세스 상태
- 메모리 관련 정보 (페이지 테이블 등)

### 컨텍스트 스위칭의 오버헤드

- 문맥 전환에는 시간과 자원이 소모됨
- 빈번한 스위칭은 오히려 성능 저하를 유발할 수 있음
- 스케줄링 알고리즘이 이를 효율적으로 조절해야 함

> 따라서, 운영체제는 스케줄링 알고리즘을 통해 스위칭 빈도와 시점을 최적화하려고 함
