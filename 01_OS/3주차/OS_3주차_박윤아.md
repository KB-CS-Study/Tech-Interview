[[tistory] CPU 스케줄링](https://0woy.tistory.com/entry/CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81) 

[[tistory] 인터럽트 & 시스템 콜](https://0woy.tistory.com/entry/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-Interrupt-%EC%8B%9C%EC%8A%A4%ED%85%9C)
## **개요**

### **워크로드에 대한 가정**

일련의 프로세스들이 실행되는 상황 (워크로드) 가정

1.  모든 작업은 같은 시간 동안 실행됨
2.  모든 작업은 동시에 도착함
3.  각 작업은 시작되면 완료될 때까지 실행
4.  모든 작업은 CPU만 사용 (＝ I/O 수행 X)
5.  각 작업의 실행 시간은 사전에 알려짐

### 스케줄링 평가 항목 (scheduling metric)

#### \-  반환 시간 (turnaround time)

작업이 \`완료\`된 시각에서 작업이 시스템에 \`도착\`한 시간을 **뺀 시간**으로 정의

![1](https://github.com/user-attachments/assets/42c558cd-0ea4-49a7-b520-d89c58e225de)


위 가정에서 모든 작업은 동시에 도착한다고 가정했으므로, \`arrival = 0\`  
_**∴ 작업 반환 시간 = 작업 완료 시각**_

> 📌 반환 시간은 **성능 측면**에서의 평가 기준  
> 다른 평가 기준으로는 \`공정성\`(Fairness)이 있음.  
> 성능과 공정성은 스케줄링에서 **상충되는 목표**임

### 성능 vs 공정성

CPU 스케줄링에서 성능과 공정성은 시스템 성능을 평가하는 두 가지 핵심 지표  
각각 효율성과 공정성 측면에서 상호 보완적 역할을 함

Jain's Fariness Index : 자원 할당의 공정성을 측정하기 위해 널리 사용되는 지표 

| **항목** | **반환 시간** | **Jain's Fairness Index** |
| --- | --- | --- |
| **측정 대상** | 개별 프로세스의 실행 시간  | 전체 시스템의 자원 분배 패턴 |
| **민감도** | 대기 시간, 실행 시간 변화에 민감 | 극단적 불공정 사례에 덜 민감 |
| **사용 사례** | 실시간 시스템, 배치 처리 | 클라우드 자원 관리, QoS 보장 |

-   \`TAT\`: 프로세스 제출부터 완료까지의 총 시간
-   \`JFI\`: 모든 프로세스가 받은 CPU 시간의 균등성을 0~1 범위로 정량화 (1에 가까울 수록 공정)

> **극단적 불공정 사례에 둔감 ❓**  
> 한 프로세스를 제외한 나머지 프로세스들이 균등하게 자원을 받으면 = JFI는 높게 나옴

---

## CPU 스케줄링 알고리즘

CPU 스케줄러는 CPU 스케줄링 알고리즘에 따라 프로세스에서 해야 하는 일을 스레드 단위로 CPU에 할당

프로그램이 실행될 때는 CPU 스케줄링 알고리즘이 어떤 프로그램에 CPU 소유권을 줄 것인지 결정

**목표:** \`CPU 이용률 ↑\`, \`주어진 시간에 多일\`, \`준비 큐 프로세스는 少\`, \`응답시간↓\`

---

## 비 선점형 방식

비 선점형 (non-preemptive) 은 **프로세스가 스스로 CPU를 포기**하는 방식  
강제로 프로세스 중지하지 않음

∴ 컨텍스트 스위칭으로 인한 부하 적음

### 1) 선입 선출 (First In First Out, FIFO)

가장 먼저 온 것을 가장 먼저 처리하는 알고리즘

길게 수행되는 프로세스 때문에 준비 큐에서 오래 기다리는 현상 (convoy effect)이 발생

![2](https://github.com/user-attachments/assets/a2b95270-9a4d-49e6-abe7-06a1afb00fc4)


-   간발의 차이로 A, B, C 순서대로 도착했다고 가정 (도착 시간 = 0)
-   각 작업들은 10초 동안 실행  
    ∴ 평균 반환 시간 = \`(10+20+30)/ 3 = 20\` 

![3](https://github.com/user-attachments/assets/d8137733-718d-492c-8bac-c283e3cb186d)


실행 시간이 모두 같지 않을때 위 그림의 평균 반환 시간은 \`(100+110+120)/3 =110\`

짧은 시간 동안 자원을 사용할 프로세스들이 자원을 오랫동한 사용하는 프로세스의 종료를 기다리는 현상인  
👉 Convoy effect 발생

그렇다면, 작업 실행 시간이 다른 경우 좋은 알고리즘은 ?

---

### 2) 최단 작업 우선 (Shortest Job First, SJF)

실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘

-   긴 시간을 가진 프로세스가 실행되지 않는 현상 (starvation) 발생
-   **평균 대기 시간이 가장 짧음**
-   실제로는 실행 시간을 알 수 없기 때문에 **과거의 실행 시간을 토대**로 추측

> **처음 실행되는 프로세스인 경우 예측은 어떻게 할까 ❓**
>   
> 1\. \`기본값\` 할당: 운영체제가 사전에 설정한 고정값 (ex: 10ms) 사용  
> 2\. \`부모 프로세스\`의 실행 시간 상속: 부모 프로세스의 평균 실행 시간을 초기 값으로 사용  
> 3\. \`동적 평균값\`활용: 현재 시스템에서 실행된 모든 프로셋의 평균 실행 시간을 초기 추정치로 사용

![4](https://github.com/user-attachments/assets/d60083d5-2afd-450f-aac5-4bc5ae0896e0)


모든 작업이 동시에 도착하는 경우, SJF는 최적의 스케줄링 알고리즘임  
평균 반환 시간 = (10+20+120)/3 =50

모든 작업이 동시에 도착하지 않으므로 임의의 시간에 도착한다면? (가정 2 완화)

-   A: t=0 시간에 도착
-   B,C: t=10 시간에 도착

![5](https://github.com/user-attachments/assets/2333698b-b83d-40b6-85f3-4a6668e58a1f)


도착시간이 다르다면, 위그림과 같이 A가 끝날 때까지 B, C는 기다릴 수밖에 없음

이전의 FIFO 알고리즘에서 확인한 \`Convoy\` 문제 발생  
평균 반환 시간 = (100+ (110-10)+(120-10)) /3 = 103.33

---

### 우선순위

SJF 스케줄링의 경우 긴 시간을 가진 프로세스가 실행되지 않는 현상 발생.

**오래된 작업일수록 우선순위를 높이는** 방법을 통해 단점 보완한 알고리즘

---

## 선점형 방식

선전형(preemptive) 방식은 현대 운영체제가 쓰는 방식

현재 사용하고 있는 프로세스를 알고리즘에 의해 **중단**시키고 **강제로** 다른 프로세스에 **CPU** **소유권을 할당**하는 방식

> 📌 즉, 스케줄러는 컨텍스트 스위칭을 수행하고, 실행 중인 프로세스 중단 & 다른 프로세스 실행 및 재개 가능

### 1) 최소 잔여시간 우선 (Shortest Remaining First, SRF)

중간에 실행시간이 더 짧은 작업이 들어와도 기존 작업을 모두 수행하고 다음 작업을 실행하는 SJF에 \`**선점형\`** 기능 추가

-   새로운 작업이 시스템에 들어옴
-   스케줄러는 남아 있는 작업과 새로운 작업의 잔여 실행 시간 계산
-   **가장 적은 잔여 실행** 시간을 가진 작업 스케줄

![6](https://github.com/user-attachments/assets/2686324c-7f23-4b59-ad5e-69a647fce416)


새로운 가정(작업마다 임의의 시간에 도착함) 하에서, _**SRF가 최적의 알고리즘**_  
∵ 모든 작업들이 동시에 도착할 경우 SFJ가 최적의 결과를 도출

---

#### 새로운 평가 기준 - 응답 시간

작업의 실행 시간을 미리 알고 있고, 작업이 오직 CPU만 활용하면서 평가 기준이 반환 시간만 존재하는 경우,  
SRF는 최고의 알고리즘임

**시분할 시스템**의 등장으로 **사용자는 터미널에서 작업**하게 되어 시스템에게 **상호작용을 원활**히 하기 위한 **성능** 요구

> **시분할 시스템❓**  
> 한 대의 컴퓨터를 여러 사용자가 동시에 사용할 수 있도록 설계된 시스템  
>   
> \- 다중 사용자 환경: 각 사용자는 자신의 프로그램 실해 & 다른 사용자와 독립적 작업  
> \- 시간 슬라이싱: CPU 처리 시간을 작은 단위로 나누어 사용자에게 순차적 할당  
> \- 실시간 상호작용: 사용자는 터미널을 통해 명령 입력 & 즉각 응답

**응답 시간** (reponse time)이라는 새로운 평가 기준 생김

![1](https://github.com/user-attachments/assets/760a25c2-76cf-4934-ae5b-5d6b270fa607)


\`응답 시간\`: 작업이 도찰할 때부터 처음 스케줄 될 때까지의 시간

이전의 알고리즘은 응답 시간과 상호작용 측면에서는 나쁜 방법임

그렇다면, 응답 시간에 민감한 스케줄러는 어떻게 만들까?

---

### 2) 라운드 로빈 (Round Robin, RR)

각 프로세스는 **동일한 일정 시간**을 주고, 그 시간 안에 끝나지 않으면 다시 **준비 큐의 뒤로 이동**하는 알고리즘

-   현대 컴퓨터가 쓰는 스케줄링
-   우선순위 스케줄링의 일종
-   일정 시간 = 타임 슬라이스 = 스케줄링 퀀텀
-   로드밸런서에서 트래픽 분산 알고리즘으로 사용

![2](https://github.com/user-attachments/assets/a7510bb0-3ab7-4b1d-a7d4-1d45b591e1b8)


타임 슬라이스의 길이는 RR에서 매우 중요

짧을 수록 응답 시간 기준으로 RR 성능은 좋아지지만, 너무 짧게 지정하면 **컨텍스트 스위칭 비용**이 전체 성능에 영향O

---

### 3) 다단계 큐

-   우선순위에 따른 준비 큐를 여러 개 사용
-   큐마다 RR이나 FIFO 등 다른 스케줄링 알고리즘을 적용
-   큐 간의 **프로세스 이동X**

![3](https://github.com/user-attachments/assets/7affa046-3b1e-4142-88d2-5da0946b4227)


**기아 문제**: 낮은 우선순위 큐에 있는 프로세스가 높은 우선순위 프로세스들로 인해 실행 x

**유연성 부족**: 한 번 할당된 큐 변경x, 동적 환경에서 적응력 떨어짐

---

### 4) 다단계 피드백 큐 (Multi-Level Feedback Queue, MLFQ)

다단계 큐의 확장 형태, 프로세스가 큐 간에 이동할 수 있는 기능 추가

-   처음에는 높은 우선순위 큐에서 실행
-   실행 시간이 길어지면 낮은 우선순위 큐로 이동
-   짧은 작업은 빠르게 끝내고, 긴 작업은 낮은 우선순위에서 실행
-   현대 운영체제에서 가장 많이 사용하는 스케줄링 방식 中 하나

![4](https://github.com/user-attachments/assets/64de0266-785f-4de3-b73f-d199a7856321)

---

## 인터럽트 (Interrupt)

프로그램을 실행하는 도중 예기치 못한 상황이 발생할 경우  
**CPU가 현재 수행 중인 작업을 일시 중단**하고, **다른 작업을 수행**하도록 하는 메커니즘  
  

### 구조

하드웨어 장치마다 \`컨트롤러\`라고 불리는 작은 CPU 존재

컨트롤러는 장치로부터 출입하는 데이터를 임시로 저장하기 위한 \`Local Buffer\`라는 \`작은 메모리\`를 가짐

> ex) 디스크 = 디스크 컨트롤러 / 메모리= 메모리 컨트롤러

---

### 개념

가정 : 디스크에서 데이터를 읽어오는 작업 中

디스크 컨트롤러가 디스크에서 내용을 읽어 로컬 버퍼에 저장.

저장하는 작업의 완료 여부는 CPU가 체크하는 것이 아닌, 장치의 컨트롤러가 **인터럽트 신호 발생**하여 CPU에게 전달

>  📌 컨트롤러들이 **CPU의 서비스가 필요할 때 이를 통보**하는 방법 = 인터럽트

-   기본적으로 CPU는 매 시점 메모리 명령을 하나씩 읽어와 수행, 이때마다 인터럽트 발생 여부 확인
-   인터럽트가 발생한 경우,  CPU 라인 옆에 \`인터럽트 라인 (Interrupt Line)\`을 통해 하던 작업을 멈추고  
    인터럽트 관련 작업 처리
-   운영체제의 커널에는 인터럽트가 들어왔을 때 해야 할 일에 대한 코드 보관
-   할 일을 쉽게 찾아가기 위해 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야할 코드가 위치한 부분을 가리키고 있는 자료구조 사용 (= **인터럽트 벡터** (Interrupt Vector))
-   실제 처리해야할 코드는 **인터럽트 처리 루틴**(Interrupt Service Routine) 혹은 **인터럽트 핸들러**(Interrupt Handler) 라고 불리는 곳에 저장

---

### 인터럽트 종류

#### 1\. 하드웨어 인터럽트

**외부장치**나 **하드웨어의 동작**에 의해 발생하는 인터럽트

CPU외부에서 발생하는 신호에 의해 처리됨

-   **I/O 인터럽트**: I/O 장치의 작업 완료나 오류 발생 시 CPU에 서비스 요청
-   **전원 이상 인터럽트**: 정전이나 전원 공급의 이상이 있을 때 발생
-   **기계 고장 인터럽트**: CPU의 기능적 오류나 하드웨어 고장 시 발생
-   **외부 신호 인터럽트**: 타이버나 사용자의 의도적인 신호에 의해 프로그램 중단되는 경우

#### 2\. 소프트웨어 인터럽트

프로그램 **내부에서 특정 명령어를 실행**하거나 **예외 상황**이 발생했을 때 소프트웨어적으로 발생하는 인터럽트

주로 트랩(trap)이라는 용어로 불림

-   **시스템 호출 (System Call)**: 응용 프로그램이 운영체제의 서비스를 요청할 때 발생
-   **예외 상황 (Exception)**: 0으로 나누기, 유효하지 않은 명령어 실행 등 프로그램 실행 중 오류 발생 시

#### 3\. 마스커블 인터럽트 (Maskable Interrupt)

CPU가 인터럽트의 우선순위에 따라 **처리를 지연**시킬 수 있는 인터럽트

#### 4\. 비마스커블 인터럽트 (Non-Maskable Interrupt)

즉시 처리되어야 하며, CPU에 의해 무시되거나 지연될 수 없는 **높은 우선순위의 인터럽트**

---

### 하드웨어 인터럽트 VS 소프트웨어 인터럽트

| **구분**  | **하드웨어 인터럽트** | **소프트웨어 인터럽트** |
| --- | --- | --- |
| **발생 원인**  | 외부 하드웨어 장치 | 프로그램 내부에서 발생 |
| **비마스커블 인터럽트 유/무** | 有 (전원 오류, 치명적 하드웨어 장애) | 無 (OS 제어 가능) |
| **마스킹 가능 여부** | 일부 가능 (마스커블 인터럽트만) | 가능 (OS 관리 가능) |

> **소프트웨어 인터럽트 中 예외(Exception)가 비마스커블이 될 순 없나 ❓**
>
> 예외는 예상치 못한 오류 상황에서 발생함  
> 예외에도 CPU가 반드시 처리해야 하는 것과 무시할 수 있는 것 존재  
> 하지만, **_결국 OS에서 핸들링할 수 있기 때문_**에 \`완전한\` 비마스커블 인터럽트라고 보기 어려움  
>   
> ∵ \`0으로 나누기\`의 경우, OS가 이를 처리할지 프로세스를 종료할지 결정

---

## 인터럽트 작동 원리

#### 1\. 인터럽트 발생

-   **하드웨어** 요청: 외부장치 (키보드, 마우스 등) 에서 이벤트가 발생하면, 해당 장치의 컨트롤러가 CPU에 인터럽트 요청
-   **소프트웨어** 요청: 프로그램이 운영체제의 서비스를 요청할 때 발생

즉, 장치 컨트롤러가 인터럽트 요청 (Interrupt Request, IRQ) 신호 전송

이때, 인터럽트 번호 (Interrupt Number 또는 Vector Number) 함께 전달

> ex) 타이머 인터럽트 = 0x20번 / 키보드 인터럽트: 0x21번

#### 2\. 인터럽트 신호 수신

 CPU는 **인터럽트 핀**인 특정 핀을 통해 인터럽트 신호 수신  
해당 신호는 CPU가 현재 작업을 중단하고 인터럽트를 처리해야 함을 알림

#### 3\. 현재 상태 저장

CPU는 현재 실행중인 프로그램의 상태 (레지스터, 프로그램 카운터 등)를 스택에 저장 (in PCB)  
👉 추후 작업 재개 시 필요

#### 4\. 인터럽트 벡터 테이블 조회

-   CPU는 인터럽트 번호를 기반으로 인터럽트 벡터 테이블에 접근
-   IVT 는 **RAM 또는 ROM**의 특정 **고정된 위치**에 존재

#### 5\. ISR 실행

해당 인터럽트 벡터가 가리키는 메모리 주소에서 **ISR의 실제 물리적 주소**를 읽음

-   보통 \`세그먼트:오프셋\` 형식으로 저장

> ex) ISR의 주소가 0X1234:5678, 물리 주소: 0x1234 x16 + 0x5678

CPU가 해당 **ISR 코드로 점프**하여 실행 시작

> **ISR 코드로 점프 ❓**
>   
> CPU가 IVT를 참조해서 ISR 시작 주소를 알아내고, 그 위치로 코드 실행 흐름을 옮긴다는 의

#### 6\. ISR 실행 종료, 상태 복원

ISR 끝에는 \`IRET(Interrupt Return)\` 명령어 존재

이전에 저장한 PC, 레지스터 등을 스택에서 복원하고 원래 작업으로 복귀

---

## 인터럽트 벡터 테이블 (Interrupt Vector Table, IVT)

하드웨어 또는 소프트웨어 인터럽트가 발생했을 때

CPU가 **어떤 코드** (= ISR, 인터럽트 서비스 루틴) 로 **이동해야 하는지를 알려주는 주소 목록이 저장**된 테이블

### IVT가 필요한 이유

-   유연성: ISR 주소를 테이블에서 나중에 바꿀 수 있음
-   모듈화: 키보드, 마우스, 타이머 등 장치별 ISR을 따로 분리
-   운영체제 제어권 확보: BIOS ISR → OS가 덮어씌워 커스터마이징 가능
-   보안성 & 안정성: 커널이 ISR 제어 가능

### IVT 구조 (실모드 기준)

-   위치: 메모리의  **0x0000 ~ 0x03FF** (1KB), **RAM의 가장 앞부분에 존재**
-   구조: **256개**의 인터럽트에 대해 각각 **4byte** (2byte: offset + 2byte: 세그먼트)  
    \-> _256 x 4 =1024 byte = 1KB_
-   내용: 각 인터럽트 번호에 대응하는 ISR의 실제 주소 (세그먼트:오프셋) 저장

> ex) 인터럽트 번호 0x21이 발생한 경우  
> 1\. CPU는 IVT에서 0x21 x 4 = \`0x84\` 오프셋 부터 4byte 읽음  
> 2\. 그곳에 저장된 세그먼트:오프셋 주소 로 즉시 점프  
> 3\. 해당 ISR 실행

---

### 실 모드 VS 보호 모드

현대 운영체제는 전부 **보호모드** 사용

CPU 부팅 시에는 실모드로 시작되지만, OS가 로딩되면 바로 보호모드로 전환

| **항목** | **실모드** | **보호모드** |
| --- | --- | --- |
| **메모리 주소 방식** | 세그먼트:오프셋 (최대 1MB) | 32비트, 64비트 선형 주소, 페이징 가능 |
| **메모리 보호**  | X (모든 코드 모든 영역 접근) | O (프로세스 별 메모리 보호) |
| **멀티태스킹** | X | O |
| **예외 처리** | 제한적 | 세밀한 예외, 인터럽트, 페이지 폴트 처리 |
| **IVT** | **IVT 고정 (RAM 상단 1KB)** | **IDT, 위치 자유 + 보안** |
| **보안성** | 낮음 (모든 코드 하드웨어 제어) | 높음 (커널만 핵심 자원 접근) |
| **사용 시기** | DOS 시절 (~1990년대 초) | 현대 OS 전부 사용 (Window, Linux 등) |

---

### 보호 모드에서 인터럽트 처리 (IVT > IDT)

보호 모드에서는 IDT (Interrupt Descriptor Table)라는 구조 사용

<Img src="https://github.com/user-attachments/assets/b325e123-cc53-4456-88af-63ce67c18eb5" width="50%" />


-   인터럽트 번호와 ISR 주소 매핑은 동일
-   구조 & 접근 권한 상이

#### 특징

-   위치: 메모리 어디든 가능 (IDTR 레지스터로 지정)
-   크기: 256개 엔트리 (0~255 인터럽트)
-   구조: 각 엔트리는 8byte 또는 16byte, 세부 권한/ 세그먼트 정보 포함
-   보안: 커널이 IDT 설정, 사용자 모드는 수정 불가
-   역할: 인터럽티 + 예외 처리
-   저장: CPU 내부 레지스터인 IDTR가 위치 & 크기 저장

---

## 커널 (Kernel)

-   하드웨어와 응용 프로그램 사이에서 자원을 관리하는 역할
-   CPU, 메모리, 디스크, 네트워크, 파일 시스템 등 제어
-   일반 응용 프로그램이 직접 접근 할 수X, \`커널 모드\`에서만 실행 가능

### 유저 모드 

-   일반 응용 프로그램이 실행되는 모드
-   운영체제의 중요한 자원에 직접 접근 불가

**시스템 콜을 통해서만 커널 기능을 사용**할 수 있음

> 웹 브라우저, 게임, 동영상 플레이어 등  
> 일반 사용자 프로그램은 항상 유저 모드에서 실행

### 커널 모드

-   운영체제가 실행되는 특권 모드
-   CPU가 모든 메모리 / 하드웨어 자원에 접근 가능

> 파일 시스템 접근 : 사용자가 파일을 저장하면, 커널이 디스크에 저장  
> 메모리 할당 : 프로그램이 실행될 때, 커널이 메모리를 할당

---

## 시스템 콜

운영체제가 커널에 접근하기 위한 **인터페이스**이며 **유저 프로그램이** 운영체제의 서비스를 받기 위해 **커널 함수를 호출**할 때 사용

![1](https://github.com/user-attachments/assets/f446b7e9-bbc4-4e24-99e3-17f65bb0fab0)


프로세스나 스레드에서 **운영체제로 요청을 할 때**, \`시스템콜\`과 \`커널\`을 거쳐 운영체제로 전달됨

시스템 콜을 사용하면, 유저 모드에서 실행되는 프로그램이 커널 모드로 전환되어 하드웨어 자원에 접근하거나 보호된 시스템 기능 사용 가능

> 즉, _**시스템 콜은 사용자 프로그램과 커널 사이의 상호작용**_을 가능하게 함

---

### 시스템 콜 수행 과정

1.  사용자 프로그램이 시스템 콜 요청 (read(), wirte() 등)
2.  이 함수는 내부적으로 **시스템 콜 번호 & 인자**를 **레지스터에 설정**
3.  \`**syscall**\` 명령어 (소프트웨어 인터럽트) 실행
4.  CPU는 IDT에서 0x80에 해당하는 ISR을 찾아서 **커널모드** 전환
5.  커널의 시스템 콜 핸들러가 시스템 콜 번호 확인 후 해당 함수 실행
6.  작업이 끝나면 결과를 레지스터에 담고 사용자 모드 복귀

| **명령어** | **설명** |
| --- | --- |
|  **int 0x80** | 전통적인 x86 방식 |
| **syscall** | x86\_64 전용, 더 빠름 |
| **sysenter / sysexit** | Intel 고속 시스템 콜 (Window, Linux) |
| **svc** | ARM 아키텍처에서 시스템 콜 |
