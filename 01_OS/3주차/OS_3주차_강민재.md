### [3주차] CPU 스케줄링 + 인터럽트 & 시스템 콜

- CPU 스케줄링 알고리즘
- 인터럽트(Interrupt) 개념 및 종류
- 시스템 콜(System Call)과 사용자 모드 vs 커널 모드

---

<br>

## 🔵 CPU 스케줄링 알고리즘

### CPU 스케줄링이란?

하나의 CPU 코어는 한 번에 하나의 프로세스만 실행 가능하다.

언제 어떤 프로세스에 CPU를 줄 지 결정하는 것이 CPU 스케줄링이다.

#### 스케줄링의 목적

| 지표                 | 설명                                       | 중요 대상          |
| -------------------- | ------------------------------------------ | ------------------ |
| Response time        | 입력 -> 출력까지 걸리는 시간               | 사용자 입장        |
| Throughput           | 단위 시간 당 완료된 프로세스의 수          | 시스템 입장        |
| Processor efficiency | CPU가 유효한 작업을 수행한 비율            | 운영체제 입장      |
| Fairness             | 모든 프로세스가 공평하게 CPU 기회를 얻는가 | 전체 프로세스 입장 |

#### CPU 스케줄러가 스케줄링을 결정하는 타이밍

    1. Running -> Waiging: I/O 요청 시

    2. Running-> Ready: interrupt 발생 시

    3. Waiting -> Ready: I/O 완료 시

    4. Process 종료 시

> 1번, 4번만 발생: 비선점형(non-preemptive) 스케줄링
>
> 2번, 3번도 포함: 선점형(preemtive) 스케줄링

### 비선점형 스케줄링

프로세스가 CPU를 점유하면 **끝날 때까지** 유지하는 스케줄링이다.

필요한 경우에만 문맥 교환이 발생하므로 오버헤드가 적다.

배치 순서에 따라 효율성 차이가 크다.

### 선점형 스케줄링

운영체제가 CPU를 강제로 회수 가능한 스케줄링이다.

짧은 작업을 먼저 처리하는 것이 가능하므로 효율적이다.

하지만 잦은 문맥교환으로 오버헤드가 커질 가능성이 있다.

---

### FCFS (First-Come-First-Served)

프로세스를 **도착한 순서대로 처리하는 방식**이다.

구현이 간단하고 직관적이지만, 대기 시간이 길어질 수 있는 단점이 있다.

특히 긴 작업이 먼저 도착하면 **후속 작업들이 오래 기다리는 문제**가 발생한다.

---

### RR (Round-Robin)

**모든 프로세스에 동일한 시간 할당량(time quantum)을 주고 순차적으로 실행하는 방식**이다.

시간이 다 되면 CPU를 다음 프로세스에게 넘긴다.

공정성이 뛰어나며, 대화형 시스템에 적합한 방식이다.

단, 시간 할당량이 너무 크거나 작으면 성능 저하가 발생할 수 있다. 시스템의 response time을 최소화할 수 있는 q값을 찾아야 한다.

---

### SJF (Shortest Job First)

**처리 시간이 가장 짧은 작업부터 실행하는 방식**이다.

평균 대기시간이 짧아 효율적이다.

단, 정확한 실행시간을 예측하기 어렵기 때문에 실제 적용이 까다롭다.

-> 예측이 잘못된 경우 response time이 지연된다.

-> 긴 작업은 계속 뒤로 밀려, 최악의 경우 starvation 발생

---

### SRT (Shortest Remaining Time)

SJF의 선점형 버전이다.

**남은 실행 시간이 가장 짧은 작업을 우선 실행**한다.

새로운 작업이 도착할 때마다 비교하여 CPU를 선점할 수 있다.

짧은 작업 처리에 유리하지만, 문맥 교환이 자주 일어날 수 있다.

단, 짧은 작업이 계속 들어오면 긴 작업은 계속 밀리면서

-> starvation이 발생할 수 있고,

-> 긴 작업의 응답 시간은 매우 나빠진다.

---

### HRRN (Highest Response Ratio Next)

**우선순위를 (대기시간 + 서비스시간) / 서비스시간으로 계산하여 가장 높은 비율을 선택**하는 방식이다.

```math
Ratio = (timeSpentWating + expectedServiceTime) / expectedServiceTime
```

긴 작업도 우선순위가 점점 높아지기 때문에 starvation을 방지할 수 있다.

비선점형 방식이며, 공정성과 효율성을 함께 고려하는 방식이다.

---

### MLQ (Multi-Level Queue)

**프로세스를 우선순위나 성격에 따라 여러 개의 큐로 나누고, 각 큐마다 다른 스케줄링 알고리즘을 적용**하는 방식이다.

큐 간 이동은 없으며, 큐 간 우선순위는 고정되어 있다.

예: 시스템 프로세스 큐 > 사용자 큐 등.

---

### MLFQ (Multi-Level Feedback Queue)

MLQ의 확장형으로, **프로세스가 다른 큐로 이동할 수 있도록 피드백을 주는 방식**이다.

CPU 사용 시간이 길어지면 낮은 우선순위로 이동하며, 짧은 작업은 높은 우선순위를 유지한다.

복잡하지만 다양한 작업 특성에 유연하게 대응 가능하다.

---

<br>

## 🔵 인터럽트(Interrupt) 개념 및 종류

interrupt: 프로세서의 정상적인 명령 실행 흐름을 중단하고, 예외 상황이나 외부 이벤트를 처리할 수 있도록 해주는 메커니즘이다.

### 인터럽터의 종류

| 구분             | 설명                                                                                                                                                                                                                                                                        |
| ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Program          | 프로그램 실행 중 발생하는 인터럽트 <br> -> 산술 오버플롱, 0으로 나누기, 잘못된 명령어 실행, 접근 허용되지 않은 메모리 참조 등                                                                                                                                               |
| Timer            | 프로세서 내부의 타이머에 의해 발생. 운영체제가 주기적으로 수행해야 하는 작업들을 트리거 함 <br> -> 시분할 스케줄링                                                                                                                                                          |
| I/O              | 입출력 컨트롤러가 보내는 신호. 입출력 작업이 완료되었거나 에러가 발생했을 때 발생 <br> -> 대부분의 I/O는 CPU보다 속도가 느림 <br> -> 따라서 CPU는 I/O 장치의 완료를 기다려야 할 때가 있음 <br> -> 이 때문에 인터럽트 기반 I/O처리를 사용하여 CPU가 효율적으로 작동하도록 함 |
| Hardware Failure | 전원 장애, 메모리 오류 등 하드웨어 문제로 인해 발생하는 인터럽트 <br> -> 전원 이상, 메모리 패러티 에러 등                                                                                                                                                                   |

---

### 인터럽트 핸들러

![interrupt handler](https://firebasestorage.googleapis.com/v0/b/portfolio-74c3d.appspot.com/o/CS-study%2F03-1.png?alt=media&token=5e3e609f-e0ee-42eb-8f6c-219a08f88f90)

**interrupt handler는 특정 I/O 장치를 처리하기 위한 프로그램**이다.

일반적으로 운영체제 내부에 포함된 코드로, 인터럽트가 발생하면 해당 핸들러로 제어가 넘어가 해당 작업을 처리한다.

---

### 명령 주기에서 인터럽트 처리 흐름

CPU는 보통 Fetch -> Execute 순서로 명령을 수행하지만, 이 중간에 인터럽트가 발생할 수 있다.

![interrupt cycle with interrupts](https://firebasestorage.googleapis.com/v0/b/portfolio-74c3d.appspot.com/o/CS-study%2F03-2.png?alt=media&token=ee96f017-85b2-4841-9ae9-d733320a1894)

#### 명령어 수행 흐름

1. START → Fetch Stage

   • 다음 명령어를 메모리에서 가져온다.

2. Execute Stage

   • 가져온 명령어를 실행한다.

   • 실행 중에는 인터럽트가 비활성화(Interrupts Disabled) 되어 있어 인터럽트를 무시한다.

3. Interrupt Stage

   • 명령 실행이 끝난 후, 인터럽트 발생 여부를 확인한다.

   • 인터럽트가 발생했다면:

   • Interrupt Handler의 주소를 **Program Counter(PC)** 에 설정한다.

   • 실제 핸들러 코드는 다음 Fetch 단계에서 실행된다.

4. Fetch Stage (인터럽트 핸들러 코드)

   • 이제 PC가 가리키는 인터럽트 핸들러의 첫 명령을 가져와 실행함으로써,

   • 키보드 입력 처리, I/O 완료 처리 등 인터럽트에 따른 적절한 작업이 수행된다.

---

### 인터럽트 발생 시 메모리와 레지스터의 변화

![changes in memory and registers](https://firebasestorage.googleapis.com/v0/b/portfolio-74c3d.appspot.com/o/CS-study%2F03-3.png?alt=media&token=ddd46dea-7df2-447d-b404-a571c315b5b7)

**인터럽트 발생 흐름**

1. 인터럽트 발생 (I/O, Timer, 프로그램 오류 등)
2. 현재 명령어 실행 완료
3. 레지스터(PC, PSW 등) 상태 저장 -> 스택에 PUSH
4. 인터럽트 핸들러 주소를 PC에 로드
5. 인터럽트 핸들러 실행 시작

**인터럽트 종료 후 복귀 흐름**

1. 인터럽트 처리 완료
2. 저장해 두었던 레지스터 상태 POP + 복구
3. 원래 사용자 프로그램으로 복귀 (PC를 복원하여 재시작)

---

<br>

## 🔵 시스템 콜(System Call)과 사용자 모드 vs 커널 모드

### 모드란 무엇인가

운영체제는 보안과 안정성을 위해 CPU 실행 권한을 두 가지로 나눈다.

| 구분      | 사용자 모드 (User Mode)         | 커널 모드 (Kernel Mode)               |
| --------- | ------------------------------- | ------------------------------------- |
| 실행 주체 | 일반 사용자 프로그램            | 운영체제(커널)                        |
| 권한      | 제한됨 (I/O 접근 불가 등)       | 전체 시스템 자원 접근 가능            |
| 가능 작업 | 단순 연산, 사용자 앱 로직 등    | 파일 시스템 접근, 메모리 관리, I/O 등 |
| 예시      | 계산기 앱, 웹 브라우저          | 시스템 콜 처리, 드라이버, 스케줄러 등 |
| 전환 방법 | 시스템 콜 또는 인터럽트 발생 시 | 시스템 콜 종료 후 복귀                |

사용자 모드에서는 커널 기능을 직접 실행할 수 없고, 반드시 시스템 콜을 통해서만 접근 가능하다.

---

### 시스템 콜이란?

사용자 프로그램이 운영체제의 기능을 사용하고 싶을 때 호출하는 인터페이스이다.

즉, **사용자 모드 → 커널 모드로 전환하기 위한 공식적인 방법**이다.

---

### 시스템 콜 동작 흐름

```text
[User Mode]
사용자 프로그램 실행
↓
시스템 콜 요청 (e.g. write())
↓
트랩(Trap) 발생 → 커널 모드 진입
↓
[Kernel Mode]
운영체제가 요청 처리
↓
결과 반환 및 사용자 모드 복귀
```
