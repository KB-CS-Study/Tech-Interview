# **CPU 스케줄링이란?**

Ready queue에 대기하는 프로세스 중 누구에게 CPU를 줄 것인가를 결정하는 작업

크게 두 가지 작업으로 나눌 수 있다.

1. 당장 어떤 프로세스에게 CPU를 줄 것인지를 결정 → 스케줄링 알고리즘을 이용하여 Ready Queue에서 실행할 프로세스를 선택한다.
2. 특정 프로그램에 CPU를 준 다음에는 CPU를 특정 시점에 가져갈 것인지, 해당 작업을 끝낼 때까지 기다릴 것인지도 결정 → 선점형 스케줄링과 비선점형 스케줄링을 구분하여 운영한다.

# CPU 스케줄링이 필요한 경우

1. Running → Blocked
    - 프로세스가 실행 중 I/O 작업이 필요하여 스스로 CPU를 반납하고 Blocked 상태로 이동하는 경우
    - ex) 파일 읽기/쓰기, 프린터 사용 등의 I/O 요청
2. Running → Ready
    - 실행 중이던 프로세스가 할당된 시간을 다 써서 CPU를 강제로 반납해야 하는 경우
    - ex) 라운드 로빈 스케줄링에서 타이머 인터럽트 발생
3. Blocked → Ready
    - I/O 작업이 끝나고 인터럽트가 발생해서 Blocked 상태였던 프로세스가 Ready 상태로 이동하는 경우
    - ex) 디스크에서 데이터 읽기 완료 후 인터럽트 발생
4. Terminated
    - 실행 중이던 프로세스가 정상적으로 종료되었을 때
    - ex) 프로그램이 끝까지 실행되어 종료되거나, 강제 종료된 경우

➡️ 1, 4번 : CPU를 자진 반납하는 비선점형 스케줄링

2, 3번 : CPU를 강제로 빼앗는 선점형 스케줄링

# CPU 스케줄링의 성능 평가

## 시스템 입장

- CPU utilization(이용률)
    - 전체 시간 중에서 CPU가 일을 한 시간의 비율 → 최대한 쉬지 않게 해야 잘 쓰는 것
- Throughput(처리량)
    - 주어진 시간동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 완료했는지 → 주어진 시간 동안 많이 처리하면 좋다.

## 프로세스 입장

- Turnaround time (소요 시간, 반환 시간)
    - 프로세스가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간
- Waiting time(대기 시간)
    - 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합
- Response time(응답 시간)
    - 프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간

# CPU 스케줄링 알고리즘

## 비선점형 스케줄링

한 프로세스가 CPU를 할당받으면, 스스로 종료하거나 I/O 작업을 위해 대기 상태로 바뀔 때까지 CPU를 계속 사용한다. 즉, 다른 프로세스가 CPU를 빼앗을 수 없다.

장점 : Context Switching이 적어 오버헤드가 적다.

단점 : 프로세스의 배치에 따라 효율성 차이가 많이 나게 된다. (긴 작업이 먼저 실행되면 대기 시간이 길어질 수 있다.)

### FCFS

- 먼저 온 순서대로 처리하는 방식
- 장점 : 구현이 간단하다.
- 단점 : 먼저 온 작업에 따라 기다리는 시간의 차이가 크다.
    
    → Convoy effect : CPU를 오래 쓰는 프로세스가 먼저 와서 CPU를 할당 받으면, 나머지 프로세스들은 전부 기다려야한다. 
    

### 비선점형 SJF

- 실행 시간이 가장 짧은 프로세스에게 가장 먼저 CPU를 할당하는 방식
- 일단 CPU를 잡으면 더 짧은 프로세스가 들어와도 CPU 실행이 완료될 때까지 CPU를 선점 당하지 않는다.
- 장점: 실행 시간 짧은 작업이 먼저 실행되므로 평균 대기 시간이 감소한다.
- 단점 : CPU 사용 시간이 긴 작업은 계속 뒤로 밀려나게 된다.
    
    → Starvation
    

### 비선점형 Priority

- 우선 순위가 제일 높은 프로세스에게 CPU를 할당하는 방식
- 일단 CPU를 잡으면 더 높은 우선 순위를 가진 프로세스가 들어와도 CPU 실행이 완료될 때까지 CPU를 선점 당하지 않는다.
- 장점 : 긴급한 작업을 빨리 실행할 수 있다.
- 단점 : 우선순위가 낮은 프로세스는 계속 실행되지 못할 수 있다.
    
    → Starvation
    

## 선점형 스케줄링

한 프로세스가 CPU를 할당받아 실행 중이더라도, 우선순위가 높은 프로세스가 등장하면 해당 프로세스에게 cpu를 빼앗길 수 있다.

장점 : 처리 시간이 매우 긴 프로세스의 CPU 사용 독점을 막을 수 있어 효율적인 운영이 가능하다.

단점 : Context Switching이 자주 발생해 오버헤드가 증가한다.

### 선점형 SJF(SRTF)

- 실행 시간이 가장 짧은 프로세스에게 가장 먼저 CPU를 할당하는 방식
- CPU를 잡았다 하더라도 더 짧은 프로세스가 들어오면 CPU를 뺴앗긴다.
- 장점: 실행 시간 짧은 작업이 먼저 실행되므로 평균 대기 시간이 감소한다.
- 단점 : CPU 사용 시간이 긴 작업은 계속 뒤로 밀려나게 된다.
    
    → Starvation
    

### 선점형 Priority

- 우선 순위가 높은 프로세스에게 가장 먼저 CPU를 할당하는 방식
- CPU를 잡았다 하더라도 더 높은 우선 순위를 가진 프로세스가 들어오면 CPU를 뺴앗긴다.
- 장점 : 긴급한 작업을 빨리 실행할 수 있다.
- 단점 : 우선순위가 낮은 프로세스는 계속 실행되지 못할 수 있다.
    
    → Starvation
    

### Round Robin

- 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 가지고 할당 시간이 끝나면 프로세스는 강제로 중단되고 ready queue에 줄을 다시 선다.
- 장점 : 모든 프로세스가 공평한 실행 기회를 가지기 때문에 응답 시간이 빠르다.
- 단점 : 타임 퀀텀이 너무 짧으면 Context Switching이 자주 발생해 오버헤드가 증가하고 타임 퀀텀이 너무 길면 비선점형처럼 동작하게 되어 짧은 작업이 오래 기다릴 수 있다.

### Multilevel Queue

- Ready queue를 우선 순위에 따라 여러 개로 분할한다.
    - 빠른 응답을 필요로 하는 대화형 작업은 전위 큐에 넣는다.
    - 계산 위주의 작업은 후위 큐에 넣는다.
- 각 큐는 특성에 맞는 독립적인 스케줄링 알고리즘을 갖는다.
    - 전위 큐 → 사용자의 요구에 바로바로 응답을 줄 수 있는 Round Robin 기법
    - 후위 큐 → 긴 작업들을 효율적으로 처리하기 위한 FCFS 기법
- 큐 사이의 스케줄링이 필요하다.
    - 고정 우선 순위 방식 : 
    전위 큐에 있는 프로세스에게 우선적으로 CPU가 할당되고, 전위 큐가 비어 있는 경우에만 후위 큐에 있는 프로세스에게 CPU가 할당된다.
        
        → Starvation 발생 가능
        
    - 타임 슬라이싱 방식 :
        
        각 큐에 CPU time을 적절한 비율로 할당한다.
        
        → ex) 80%는 전위 큐, 20%는 후위 큐
        
- 장점 : 중요하거나 빠른 응답이 필요한 작업을 우선 처리 가능하다.
- 단점 : Starvation 발생 가능

### Multilevel Feedback Queue

- 프로세스가 여러 개로 분할된 Ready Queue내에서 다른 큐로 이동이 가능하다.
→ Multilevel Queue는 큐 간 이동이 불가능한 반면, Feedback Queue는 동적으로 이동이 가능하다.
- 우선 순위가 낮은 큐에서 오래 기다렸으면 우선 순위가 높은 큐로 승격하는 방식을 사용한다.
- 장점 : Starvation 완화 가능
- 단점 : 구현이 복잡하다.

# 인터럽트란?

CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외 상황이 발생하여 처리가 필요한 경우에 CPU에게 알리는 일종의 이벤트

좁은 의미의 인터럽트 : 하드웨어 인터럽트

넓은 의미의 인터럽트 : 하드웨어 인터럽트 + 소프트웨어 인터럽트

※ 인터럽트 관련 용어

- 인터럽트 벡터
    - 인터럽트 번호에 대응하는 ISR의 주소를 저장해 놓은 테이블
    - 인터럽트가 발생하면 CPU는 인터럽트 벡터를 참조해 어떤 ISR을 실행할지 결정한다.
- 인터럽트 처리 루틴(ISR)
    - 해당 인터럽트가 발생했을 때 실행되는 함수

# 인터럽트의 종류

## 하드웨어 인터럽트

외부 하드웨어 장치로부터 발생하는 인터럽트

하드웨어 인터럽트가 발생하면 CPU는 현재 작업을 잠시 멈추고 인터럽트 처리 루틴을 수행한다.

예시 :

- 키보드 입력 : 사용자가 키를 누르면 키보드 컨트롤러가 인터럽트를 발생시켜 CPU가 입력 데이터를 읽도록 요청함
- 마우스 이벤트 : 마우스 클릭이나 이벤트 발생 시 마우스 장치가 인터럽트를 발생시켜 이벤트를 처리하도록 함
- 타이머 인터럽트 : 일정 시간마다 프로세스의 CPU 사용 시간이 끝났음을 알리기 위한 인터럽트
- 하드디스크 입출력 완료 인터럽트 : 디스크 읽기/쓰기 요청이 완료되면 디스크 컨트롤러가 인터럽트를 발생시켜 CPU에게 알림

## 소프트웨어 인터럽트(Trap)

프로그램 내부 명령어에 의해 발생하는 인터럽트

소프트웨어 인터럽트는 2가지가 있다.

- Exception : 프로그램이 오류를 범하여 예외가 발생한 경우
    - 예시 : 0으로 나누기, 페이지 폴트, 잘못된 명령어 실행, 오버플로우
- System call :  프로그램이 커널 함수를 호출하는 경우
    - 예시 : 파일 입출력 함수 호출(read, write, open), 프로세스 생성(fork), 새로운 프로그램 실행(exec), 프로세스 종료(exit)

# 시스템 콜

사용자 프로그램이 운영체제에게 I/O 요청을 하는 것

→ 모든 입출력 명령은 특권 명령으로 mode bit이 0인 상태여야 한다. 그래서 I/O 장치에 접근하려면 운영체제를 통해서 해야 한다.

동작 흐름

1. 사용자 프로그램에서 시스템 콜 호출
2. 하드웨어적으로 **mode bit = 0 →** 커널 모드로 전환
3. 운영체제가 요청받은 작업 수행 
4. 작업이 끝나면 **mode bit = 1 →** 사용자 모드로 복귀
5. 사용자 프로그램은 결과를 받아서 다음 작업 진행

## 사용자 모드 vs 커널 모드

|  | 사용자 모드(User Mode) | 커널 모드(Kernel Mode) |
| --- | --- | --- |
| **mode bit 값** | 1 | 0 |
| 권한 수준 | 제한적 (일반 프로그램 실행만 가능) | 최고 권한 (모든 자원 접근 가능) |
| 가능한 작업 | 사용자 애플리케이션 실행 | 입출력 제어, 메모리 관리, 파일 시스템 접근 등 운영체제 핵심 기능 |
| 실행 주체 | 사용자 프로그램 (예: 메모장, 게임 등) | 운영체제의 커널 코드 |
| I/O 접근 | 직접 접근 불가 (시스템 콜로 요청해야 함) | 직접 접근 가능 |
| 전환 방법 | 시스템 콜 또는 인터럽트를 통해 커널 모드로 전환 | 작업 완료 시 다시 사용자 모드로 복귀 |