# ✅ CPU 스케쥴링

## 💡 개념

- OS가 CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 정해주는 작업
    - CPU 사용권을 공정하고 효율적으로 배분하는 전략

## 💡 목적

- 프로세스들에게 자원을 최대한 공평하게 배분하며 처리율과 CPU 이용률 증가
- 오버헤드, 응답시간, 대기시간을 최소화하기 위한 기법
- CPU는 한 순간에 하나의 프로세스만 처리 가능하다는 걸 알아야함!
    - 메모리에 여러 프로세스를 올려놓고 CPU의 가동시간을 적절히 나누어 각각의 프로세스에게 분배하여 실행하기 때문에 우리 눈에는 동시에 이루어지고 있는 것 처럼 보임
        
        → 이게 바로 시분할!
        

## 💡 구성 요소 상세 설명

![image.png](attachment:61150aeb-0eb3-41ad-901b-b401c88c2401:image.png)

### 1. **Pull of Job in Disk**

- 아직 메모리에 올라오지 않은 **잠자는 작업(Job)** 들이 저장된 공간이야.
- **디스크에 있는 실행 대기 중인 프로그램들**이라고 보면 돼.

---

### 2. **Long-term Scheduler (장기 스케줄러)**

> "메모리에 누구를 올릴까?"
> 
- 디스크에 있는 Job 중에서 몇 개를 선택해서
    
    → Ready Queue(레디 큐)로 올리는 역할
    
- → **멀티프로그래밍 수준 조절**: 너무 많이 올리면 과부하, 너무 적게 올리면 자원 낭비

📌 실행 빈도: 드물다 (과도한 교체 방지)

---

### 3. **Ready Queue (레디 큐)**

- **CPU 사용을 기다리는 프로세스**들이 대기하는 공간!
- 여기에 있는 애들은 **이미 메모리에 올라온 상태**
- CPU 할당받기 직전 단계라고 보면 됨!

---

### 4. **Short-term Scheduler (단기 스케줄러)**

> "Ready Queue 중 누가 CPU를 쓸까?"
> 
- 레디 큐 안에 있는 프로세스들 중에서 **하나를 선택해서 CPU에 올리는 역할**
- **CPU 스케줄링 알고리즘(RR, FCFS 등)** 이 여기서 동작함!

📌 실행 빈도: 매우 자주 (CPU 교체 시마다 실행됨)

---

### 5. **Dispatcher (디스패처)**

- 선택된 프로세스를 실제로 **CPU에 할당**하는 **“실행자”** 역할
- → **컨텍스트 스위칭**도 여기서 수행돼!

---

### 6. **CPU**

- 실제 계산, 연산, 명령어 수행이 일어나는 곳!
- **프로세스가 실행되는 중심 무대**야

---

### 7. **I/O / Waiting Queue (대기 큐)**

- 실행 중인 프로세스가 **입출력(I/O)** 요청을 하거나
- **자원을 기다려야 할 때**, 여기로 이동함

→ 예: 파일 읽기, 프린터 사용, 사용자 입력 등

---

### 8. **Mid-term Scheduler (중기 스케줄러)**

> "CPU는 안 쓰고 I/O만 기다리는 프로세스는 잠깐 치워두자!"
> 
- CPU를 안 쓰는 대기 상태의 프로세스를
    
    → **Swap Out** 해서 메모리에서 제거하거나
    
    → 다시 Ready Queue로 **Swap In** 할지 결정함
    
- 시스템 과부하 조절에 도움 줌!

---

### 9. **END**

- 프로세스가 작업을 마치면 → 종료됨
- 메모리에서 제거되고 자원 회수됨!

---

## 💡 스케쥴링 종류!

## 비선점

- 프로세스가 입출력 요구 등으로 CPU를 자진 반납할 때까지 CPU에 의한 실행을 보장해줌
- 모든 프로세스에 대한 요구를 공정하게 처리할 수 있지만, 짧은 작업을 수행하는 프로세스가 긴 작업 종료 시까지 대기해야할 수도 있다. (**convey 현상**)
- 처리시간 편차가 적은 특정 프로세스 환경에 용이

### 종류

- FCFS ( 선입선출, First-Come-Firs-Serverd )
- SJF ( 최단 작업 우선, Shortest Job First )
- Priority Scheduling ( 우선순위 스케쥴링 )

### FCFS

- 프로세스 도착순으로 CPU를 배정
- 끝날 때까지 CPU 점유, 간단하지만 비효율

![image.png](attachment:431999c5-3ad2-448d-8c3f-865fc16d2df8:image.png)

### SJF

- 대기하는 작업 중 CPU Burst Time이 가장 작은 작업에 CPU를 할당
- 평균 대기 시간에 있어서는 최적의 알고리즘
- Burst Time이 동일할 경우 FCFS로 도착순으로 처리
    - 하지만 실제로는 CPU의 Burst Time은 미리 알기 어렵다! 장기 스케쥴링은 작업시간에 대한 에측치를 사용할 수 있지만 단기 스케쥴링은 미리 알기 어렵기에 예측치 사용이 어렵다!
    - Burst Time : CPU가 일을 수행하는 시간
- 또한 긴 시간을 필요로 하는 프로셋가 우선순위가 계속 밀려 실행되지 못하고 무기한으로 대기하게 되는 기아 현상이 일어날 수 있다!

![image.png](attachment:b192832b-2738-494a-8ca6-b1dd4491d8c8:image.png)

### Priority

- 설정에 따라 선점형/비선점형 **모두 구현 가능!!**
- 우선순위를 기반으로 먼저 실행 시킴!
- 그리고 SJF 처럼 기아가 발생할 수 있는 문제에 대해서 오래 기다린 프로세스에게 우선순위를 높여 방지하는 방식을 사용할 수 있음!
    - 이 방법을 노화! (Aging) 이라고 함
        - ex) 우선순위가 원래 5였지만 시간일 갈수록 5 → 4 → 3  → .. 줄어드는 방식

![image.png](attachment:ad18c3a5-4221-4261-a77b-07adce1ed91d:image.png)

---

## 선점

- CPU를 쓰고 있는 프로세스가 있더라도, 타임슬라이스를 다 썼거나 더 중요한 프로세스가 생기면 운영체제가 강제로 중단시키고 CPU를 뺏어가는 방식!
    - 예시
        - 운영체제가 너 멜론 10분만 써라고 줬는데 다 쓰면 다른 프로세스로 CPU넘김
        - 키보드, 마우스로 인한 입력이 있을 경우 하드웨어 인터럽트 발생
            
            → CPU는 실행 중인 작업을 멈추고 키보드 이벤트 처리 후 원래 작업으로 복귀
            
- 비교적 응답이 빠름!
    - 하지만 처리 시간을 예측하기 힘들고 높은 우선순위 프로세스들이 계속 들어오는 경우 오버헤드 발생 가능성 있음
- 실시간 응답환경, Deadline 응답환경 등 우선순위가 높은 프로세스를 빠르게 처리해야 할 경우 유용

### 종류

- RR   ( 라운드 로빈 스케쥴링 )
- SRTF ( 남은시간이 가장 짧은 프로세스 먼저, Shortest Remaining Time First)
- MLQ ( 다단계 큐 스케쥴링 )
- MLFQ ( 다단계 피드백 큐 스케쥴링 )

### RR

- 각각의 프로세스에 동일한 할당 시간을 부여해서 해당 시간 동안만 CPU를 이용하게 함
    - 사진 보면 나오 듯이 시간 할당 크기를 20으로 했다면 최대 20 만큼만 사용
        
        → 다음 프로세스로 넘겨줘야함
        
    - 대신 20보다 작다면 그냥 실행하고 비켜주면 됨! 그렇게 순서대로 돌아가면서 실행
- 할당 시간 내에 처리를 완료하지 못하면 강제 중단 후 다음 작업으로 넘어가므로 선점형 방식

![image.png](attachment:f21e2f4b-14fc-4bf0-a647-a6baf747d2bb:image.png)

### SRTF

- 남은 실행 시간이 가장 짧은 프로세스를 먼저 실행시키는 선점형 알고리즘
- 사진처럼 도착 시간에 왔을 때 남은 시간이 더 적은 프로세스가 실행 되도록 함
- 평균 대기 시간을 줄일 수 있지만 역시 다음 프로세스의 CPU burst time을 예측하는 것이 어렵다는 문제가 존재

![image.png](attachment:05e9e031-c208-4b4a-aed9-ecd3b246fc88:image.png)

### MLQ

- Ready Queue를 여러개로 나누고, 프로세스의 특성에 따라 고저오딘 큐에 배정해서 실행하는 방식
- 큐 자체가 여러개!
- 각 큐는 **독립적인 스케줄링 알고리즘**을 가지고 있음!
    
    → 그래서 유연성이 없음!! 
    
    - 예시로 사용자 프로그램이 I/O 많이 해도, 큐를 바꿀 수 없음

```jsx
[ 시스템 프로세스 큐 ]      → RR
[ 인터랙티브 프로세스 큐 ] → SJF
[ 배치 작업 큐 ]           → FCFS
```

| 항목 | 내용 |
| --- | --- |
| **프로세스는 한 번 큐에 들어가면 못 바꿈** | 큐 간 이동 ❌ |
| **각 큐마다 다른 알고리즘** | 큐1: RR, 큐2: FCFS 등 가능 |
| **우선순위가 큐 간에 고정됨** | 시스템 > 사용자 > 백그라운드 |

📌 **큐 간에도 우선순위가 있음!**

→ 시스템 큐가 비어야 인터랙티브 큐로 넘어가고,

→ 인터랙티브가 끝나야 배치 작업이 실행돼

---

### MLFQ

- MLQ에서 업그레이드!
- MLQ의 단점인 유연성이 부족한 것을 보완
- 프로세스의 행동에 따라 큐를 바꿔가며 실행할 수 있는 방식
    - 매우 현실적이고, 배치 작업 모두에 적합!
    - 하지만 그만큼 설계가 복잡하고 구현하기 어려움

```jsx
[ Level 0 큐 ] → 높은 우선순위, RR(타임슬라이스 작음)
[ Level 1 큐 ] → 중간 우선순위, RR(타임슬라이스 큼)
[ Level 2 큐 ] → 낮은 우선순위, FCFS

↔ CPU 많이 쓰면 밑으로,  
↔ I/O 자주 하면 위로 올라감
```

| 항목 | 내용 |
| --- | --- |
| **큐 이동 가능** | 행동에 따라 동적으로 이동함 |
| **실제 OS에서 많이 사용** | Windows, Unix 등 |
| **기아 방지 가능 (Aging 내장)** | 오래 기다리면 위로 올려줌 |

---

## 💡 프로세스 상태 전이

![](https://velog.velcdn.com/images%2Fmooh2jj%2Fpost%2F7457fade-4d88-4768-a10e-88cb32904c61%2Fimage.png)

- **생성(New)**
    - 제일 첫번째로 New에서 Ready로 전이되는 과정
    - 프로세스가 생성되고 나서 생성된 프로세스는 **준비(Ready) 상태**에 머뭅니다.
    - 준비 상태는 CPU를 점유하고 있는 상태가 아니라, CPU를 점유하길 **희망하는 상태**입니다. 준비 상태에서 실행 상태로 넘어가려면 작업 스케줄러가 선택해 주어야만 합니다.
    
- **디스패치(Dispatch)**
    - 디스패치란 준비 상태에서 실행 상태로 전이되는 과정
    - 이는 작업 스케줄러가 해당 프로세스를 선택하여 실행되어지는 것으로, 이때 실행된 프로세스가 CPU를 점유하게 됩니다.
    
- **인터럽트(Interrupt)**
    - 인터럽트 신호를 받게되면, 실행중이던 프로세스는 준비 상태로 전이되고, 우선순위(Priority)가 높은 프로세스를 실행 상태로 전이시킵니다.
    - 실행 중인 프로세스 → 준비 / 준비 한 것들 중 우선순위가 높은 프로세스 → 실행
    
- **입출력 혹은 이벤트 대기(I/O or event wait)**
    - 실행 중인 프로세스가 **I/O 작업이 필요하면** 실행 중인던 것이 대기 상태로 전환!
    - 이때 CPU는 다른 Ready 상태 프로세스에게 넘어감
        - 그래서 대기 상태에 있는 프로세스는 입출력이 끝날때 까지 선택 될 수 없음!
    
- **입출력 혹은 이벤트 완료(I/O or event completion)**
    - 아까 I/O 실행해서 Blocked 상태가 된 것을 Ready 상태로 변경!
    - 그러면 이제 CPU 스케쥴러에게 선택 될 수 있음!!

# ✅ 인터럽트 개념 및 종류

## 📝 인터럽트

### 개념

- 프로그램을 실행하는 도중에 **예기치 않은 상황이 발생**할 경우 **현재 실행중인 작업을 중단**하고
    
    발생된 상황을 처리한 후 다시 실행중인 작업으로 **복귀하는 것**!!
    
- 하드웨어/소프트웨어가 CPU에게 도움을 요청하는 방식

### 1. **외부 인터럽트 (External Interrupt)**

→ **하드웨어 외부 환경**에 의해 발생

| 종류 | 설명 |
| --- | --- |
| **전원 이상 인터럽트** | 정전, 전원 불안정 시 발생 |
| **기계 착오 인터럽트** | CPU 외의 하드웨어 오류 (ex. 메모리 고장 등) |
| **외부 신호 인터럽트** | 타이머, 사용자 입력(키보드, 마우스 등) |
| **입출력 인터럽트** | I/O 장치에서 처리 완료되었음을 알릴 때 발생 |

📌 보통 **비동기적**으로 발생!

---

### 2. **내부 인터럽트 (Internal Interrupt) / 트랩(Trap)**

→ **프로그램 실행 중 발생하는 예외 상황**

| 종류 | 설명 |
| --- | --- |
| **프로그램 오류** | 0으로 나누기, 오버플로우, 접근 권한 오류 등 |
| **잘못된 명령어** | 존재하지 않는 명령어 실행 |
| **주소 지정 오류** | 없는 메모리 주소 접근 |
| **페이지 폴트 등** | 가상 메모리 접근 실패 등도 포함됨 |

📌 이건 CPU가 **코드 실행 중**에 발생하니까 **동기적**

- 트랩이라고도 하는 이유는 CPU가 프로그램 실행 중 발생한 예외 상황을 직접 감지하기 때문!

---

### 3. **소프트웨어 인터럽트 (Software Interrupt)**

→ **사용자/OS가 의도적으로 발생시킴**

| 종류 | 설명 |
| --- | --- |
| **시스템 콜(System Call)** | 사용자 프로그램이 커널 기능 요청할 때 발생 |
| **감시 프로그램 호출** | Supervisor 호출, 운영체제 기능 요청 |
| **시분할 처리 전환** | 사용자 프로그램 간 전환 시 발생 가능 (타이머 인터럽트 포함될 수 있음) |

### 💡 인터럽트 동작 순서 (보완 완료!)

1. **인터럽트 요청**
→ 하드웨어 장치나 오류 상황에서 **인터럽트 라인 세팅**
2. **명령어 실행 중단**
→ 현재 수행 중인 Micro Operation까지 마무리 후 중단
3. **CPU 모드 전환: 사용자 모드 → 커널 모드**
4. **컨텍스트 저장**
→ **PC, 레지스터 등** 현재 상태를 **커널 스택에 저장**
5. **인터럽트 벡터 조회**
→ 누가 보냈는지 식별, ISR 주소로 분기
6. **ISR(인터럽트 서비스 루틴) 실행**
→ 실제로 필요한 작업 수행 (입출력 확인, 데이터 수신 등)
→ 도중엔 `IF = 0` 으로 설정해서 또 다른 인터럽트 막음
7. **상태 복구**
→ 커널 스택에서 이전 컨텍스트 불러오기
8. **모드 복귀 + 프로그램 재개**
→ 커널 모드 → 사용자 모드
    
    → 원래 프로그램 이어서 실행
    

### 💡 중첩 인터럽트도 가능!

ISR 수행 중 **우선순위가 더 높은 인터럽트**가 들어오면?

→ 다시 인터럽트 루틴 호출됨 (재귀적으로 위 과정을 반복)

### 💡 인터럽트에도 우선순위가 필요한가??

> 여러 장치에서 동시에 인터럽트를 요청할 수 있기 때문이야!
> 
> 
> 근데 CPU는 한 번에 **하나만 처리**할 수 있으니 인터럽트도 우선순위 따지면서 발생!
> 

| 상황 | 누가 먼저? |
| --- | --- |
| **전원 꺼짐 직전** vs **USB 데이터 수신 완료** | 당연히 전원! (데이터 날아가면 안 되니까) |
| **디스크 오류** vs **키보드 입력** | 디스크 오류가 먼저! (시스템 보호가 더 중요) |

### 인터럽트 일반적인 우선순위 (높음 → 낮음)

```
전원 이상(Power fail)
> 기계 착오(Machine Check)
> 외부 신호(External)
> 입출력(I/O)
> 명령어 잘못
> 프로그램 검사(Program Check)
> 소프트웨어 인터럽트 (SVC)
```

- 보통 **외부 > 내부 > 소프트웨어** 순서로 생각하면 됨

### 우선순위 판단 방법 2가지

### 1. **소프트웨어적 방법 (Polling)**

| 항목 | 설명 |
| --- | --- |
| 작동 방식 | 인터럽트 요청 플래그를 차례대로 검사 |
| 장점 | 구현이 쉽고 융통성 있음 |
| 단점 | 느리다 (많은 장치 있을수록 순차 검사로 인해 시간 소모) |

---

### 2. **하드웨어적 방법 (Vectored Interrupt)**

| 항목 | 설명 |
| --- | --- |
| 작동 방식 | 인터럽트 벡터를 통해 장치가 직접 ISR 주소 전달 |
| 장점 | **속도 빠름** (장치별 고유 벡터 존재) |
| 단점 | 회로 복잡, 유연성 낮음 |

하드웨어 방식 2가지

- **Daisy Chain**
    - 모든 장치를 직렬로 연결 → 앞쪽(상위)에 있을수록 우선순위 높음
    - ex
    
    ```
    [장치1]──[장치2]──[장치3]──[CPU]
    ```
    
    - 인터럽트가 동시에 발생할 경우
    - 장치1이 먼저 CPU에게 말을 걸 기회를 얻고 장치1이 요청했으면 장치2, 3은 기다려야 함!
    - 장점
        - 회로가 단순함
        - 저렴하고 설계 쉬움
    - 단점
        - 앞쪽 장치가 말 안 하면 뒷쪽은 절대 기회 없음
        - 우선순위 바꾸기 어려움
- 병렬 방식
    - 각 장치가 자신만의 우선순위 비트를 가지고 있고, CPU가 이걸 한꺼번에 검사해서 가장 높은 우선순위를 가진 장치를 선택
    - ex
    
    ```jsx
    장치	우선순위 비트 (높을수록 중요)
    장치1	011
    장치2	101
    장치3	001
    ```
    
    → 장치2가 제일 높으니까 장치2의 ISR 먼저 실행!
    
    - 장점
        - 빠름! (CPU가 바로 판단 가능)
        - **유연성 있음** (우선순위 변경 가능)
    
    - 단점
        - 회로 복잡
        - 구현 비용 큼

---

### IF(인터럽트 플래그)

- CPU가 **인터럽트를 받을 준비가 되어 있는 지를 제어하는 플래그 비트**
    - **IF = 1**: 인터럽트 허용 상태 (Interrupt Enable)
    - **IF = 0**: 인터럽트 금지 상태 (Interrupt Disable)
        - **IF = 0**이면 아무리 우선순위가 높은 인터럽트라도 **외부에서는 못 들어옴!!**
- ISR 실행 중 **다른 인터럽트가 들어오면 방해될 수 있음**
- 그래서 ISR 실행 중에는 **IF 값을 0으로 설정해서 인터럽트 차단** 가능!
- 다 처리 후에 다시 IF=1로 복구

- 예외사항!!!!
    
    → 내부 인터럽트 (Trap)는 예외!!!
    
    - 예를 들어, **0으로 나누기, 페이지 폴트** 등은
        
        → **CPU 내부에서 발생하니까 IF 상태랑 관계 없음**
        

---

# ✅ 시스템 콜 (사용자 vs 커널모드)

## 개념

사용자 프로그램이 운영체제에게 **하드웨어 자원이나 시스템 기능을 요청하는 공식적인 방법**

저번에 했던 내용

- 사용자는 직접 하드웨어에 직접 접근이 불가능!
- 그래서 운영체제가 사용자와 하드웨어에서 일함!
- 시스템 콜은 운영체제에게 요청하는 역할!

## 사용자 모드 vs 커널 모드

| 항목 | 사용자 모드(User Mode) | 커널 모드(Kernel Mode) |
| --- | --- | --- |
| 권한 | 제한됨 (하드웨어 직접 접근 ❌) | 모든 시스템 자원에 접근 가능 |
| 실행 주체 | 사용자 프로그램 | 운영체제 (커널) |
| 예 | 게임, 크롬, VSCode 등 | 메모리 관리, 파일 시스템, 스케줄링 등 |

![image.png](attachment:3a6f4ce5-fed4-40e3-84a5-0ecf467bd065:image.png)

할 수 있는 영역이 나눠져 있음!

그리고 시스템 콜이 실행 되면 Trap 명령어를 통해 모드가 변환!

## 동작 흐름

1. 사용자 프로그램에서 `read()` 호출
2. → **Trap** 명령으로 **커널 모드 진입**
3. → 운영체제가 파일을 읽음
4. → 결과를 사용자 프로그램에 전달
5. → **다시 사용자 모드로 복귀**

```jsx
사용자 모드
   ↓  (시스템 콜 호출: write, read 등)
Trap (인터럽트 명령어로 커널 진입)
   ↓
커널 모드에서 처리
   ↓
결과 반환 및 사용자 모드 복귀
```

위에 처럼 사용자에서 커널 갈때만 Trap 사용!

커널 모드 → 사용자 모드

- **Trap 안 씀!** → 단순히 컨텍스트 복원 (iret, sysret, return 등)

## **시스템콜 종류**

시스템콜은 크게 6가지로 분류할 수 있다

1. **프로세스 제어 (Process Control)**
    - 끝내기(exit), 중지 (abort)
    - 적재(load), 실행(execute)
    - 프로세스 생성(create process) - fork
    - 프로세스 속성 획득과 속성 설정
    - 시간 대기 (wait time)
    - 사건 대기 (wait event)
    - 사건을 알림 (signal event)
    - 메모리 할당 및 해제
    
2. **파일 조작 (File Manipulation)**
    - 파일 생성 / 삭제 (create, delete)
    - 열기 / 닫기 / 읽기 / 쓰기 (open, close, read, wirte)
    - 위치 변경 (reposition)
    - 파일 속성 획득 및 설정 (get file attribute, set file attribute)
    
3. **장치 관리 (Device Manipulation)**
    - 하드웨어의 제어와 상태 정보를 얻음 (ioctl)
    - 장치를 요구(request device), 장치를 방출 (relese device)
    - 읽기 (read), 쓰기(write), 위치 변경
    - 장치 속성 획득 및 설정
    - 장치의 논리적 부착 및 분리
    
4. **정보 유지 (Information Maintenance)**
    - getpid(), alarm(), sleep()
    - 시간과 날짜의 설정과 획득 (time)
    - 시스템 데이터의 설정과 획득 (date)
    - 프로세스 파일, 장치 속성의 획득 및 설정
    
5. **통신 (Communication)**
    - pipe(), shm_open(), mmap()
    - 통신 연결의 생성, 제거
    - 메시지의 송신, 수신
    - 상태 정보 전달
    - 원격 장치의 부착 및 분리
    
6. **보호 (Protection)**
    - chmod()
    - umask()
    - chown()

### 시스템 콜 성능 이슈

시스템 콜은 모드 전환 비용 + 컨텍스트 스위칭 비용이 있음

- 사용자 → 커널 → 사용자 모드로 복귀할 때
    
    → **상태 저장/복원**, **캐시 무효화** 등이 발생
    
    → 그래서 **시스템 콜 호출은 최소화하는 것이 성능에 유리**