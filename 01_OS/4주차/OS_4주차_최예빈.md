# 데이터의 접근

컴퓨터 시스템에서 데이터 연산은 저장 공간과 실행 공간이 아래와 같은 흐름으로 동작하면서 이루어 진다.

1. 저장 공간에 데이터가 있다.
2. 연산할 데이터를 실행 공간으로 가져온다.
3. 실행 공간에서 연산한다.
4. 연산 결과를 저장 공간에 반영한다.

![Image](https://github.com/user-attachments/assets/2d39c5a1-6c1b-422d-9249-c4c24ae52206)

데이터를 읽기만 하는 경우라면 누가 먼저 데이터를 읽든 문제가 되지 않지만 데이터를 수정하는 경우에는 순서에 따라 결과가 달라지기 때문에 순서가 중요하다.

# 경쟁 상태

둘 이상의 프로세스(또는 스레드)가 동시에 같은 데이터에 접근하거나 조작할 때

**→** 수행 순서에 따라 결과가 달라지는 현상 발생

운영체제에서 경쟁 상태가 발생하는 예시 3가지

- 커널 수행 중 인터럽트가 발생한 경우
  - 커널이 `count`를 증가하려는 도중 인터럽트 발생
  - 인터럽트 핸들러도 `count`를 감소하면서 동일한 변수에 접근
  - 증감 연산 순서 꼬임 → 결과적으로 하나의 연산이 반영되지 않음
- 프로세스가 시스템 콜을 하여 커널모드로 진입해서 작업을 수행하는 도중에 문맥 교환이 발생할 경우
  - 프로세스 A가 커널모드에서 `count`를 증가하는 중 context switch 발생
  - 프로세스 B가 동일한 `count`를 조작하고, 다시 A로 복귀
  - A는 이전 값 기준으로 증가 → B의 연산 결과를 덮어씀
- 멀티 프로세서에서 공유 메모리 내의 커널 데이터에 접근할 경우
  - CPU 2개가 동시에 커널의 공유 데이터(`count`)에 접근
  - 동시 조작 시 원자성 보장 실패 → 예상과 다른 결과

➡️ 공유 데이터의 동시 접근은 데이터의 불일치 문제를 발생시킴

# 임계 구역 문제

임계 구역(critical section) : 각 프로세스에 존재하는 공유 데이터에 접근하는 코드

➡️ 데이터의 일관성을 유지하기 위해서는 하나의 프로세스가 임게 구역에 있을 때 다른 모든 프로세스는 임계 구역에 들어갈 수 없어야 한다.

이를 보장하기 위한 3가지 충족 조건

- 상호 배제 (Mutual Exclusion)
  - 어떤 프로세스가 임계 구역 부분을 수행 중이면 다른 모든 프로세스는 그의 임계 구역에 들어가면 안 된다.
- 진행 (Progress)
  - 아무도 임계 구역에 있지 않은 상태에서 임계 구역에 들어가고자 하는 프로세스가 있으면 임계 구역에 들어가게 해줘야 한다.
- 유한 대기 (Bounded Waiting)
  - 프로세스가 임계 구역에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 임계 구역에 들어가는 횟수에 한계가 있어야 한다.
  → 특정 프로세스의 무한 대기 상태를 방지

## 피터슨 알고리즘

위 3가지 조건을 모두 충족하는 대표적인 임계 구역 문제 해결 알고리즘

사용하는 변수

- `flag[i]`: 프로세스 i가 임계 구역에 들어가고 싶다는 의지 표현
- `turn`: 임계 구역에 들어갈 차례인 프로세스

![Image](https://github.com/user-attachments/assets/61017091-fbd3-4d27-8bee-fbcb63f43d9f)

장점

- 이론적으로 세 가지 조건(상호 배제, 진행, 한정 대기)을 모두 충족
- 공유 변수만으로 해결 → 간단한 구조

단점

- 두 개의 프로세스에만 적용 가능
- Busy waiting 발생 → CPU 자원 낭비
- 그래서 실제 운영체제에서는 거의 사용되지 않음 (대신 Mutex, Semaphore 등 사용)

# 세마포어

공유 자원 접근 시 동기화를 보장하여 경쟁 상태를 방지하기 위한 하드웨어 기반 동기화 도구

구성 요소

- `S`: 임계 구역에 들어갈 수 있는 최대 허용 프로세스의 개수
- `P(wait)` 연산: 자원 획득 시도
- `V(signal)` 연산: 자원 반환

⭐ 세마포어 변수는 직접 접근 불가 → 오직 P/V 연산으로만 조작 가능

## Busy Waiting

- 초기 세마포어 구현 방식
- 프로세스가 임계 구역에 진입 불가 시, 무한 루프로 계속 대기
- CPU 자원 낭비 발생 (아무것도 하지 않으면서 CPU 점유)

![Image](https://github.com/user-attachments/assets/196702c3-ab6a-402c-ad12-99c14bea6423)

## **Block WakeUp 방식**

- Busy Waiting의 단점을 보완
- 자원이 없을 경우:
  - 프로세스를 **Block 상태로 전환**하여 **대기 큐에 넣음**
  - 자원이 해제되면 OS가 프로세스를 **Wake Up**시켜 Ready 상태로 전환

![Image](https://github.com/user-attachments/assets/44f34945-1901-40d7-ad40-939921be519e)

## Busy Waiting vs Block-WakeUp

| 항목          | Busy Waiting                    | Block-WakeUp                        |
| ------------- | ------------------------------- | ----------------------------------- |
| 대기 방식     | 무한 루프                       | 프로세스를 Block 상태로 전환        |
| CPU 자원 사용 | 낭비 많음                       | 효율적 사용                         |
| 오버헤드      | 없음                            | WakeUp 시 오버헤드 발생             |
| 적합한 상황   | Critical Section이 매우 짧을 때 | Critical Section이 길거나 무거울 때 |

## 세마포어의 종류

- Counting Semaphore
  - 0이상의 정수값을 가지는 세마포어
  - 다수의 자원에 대한 접근을 제어할 때 사용
  - 자원의 개수를 추적하여 자원 사용을관리
- Binary Semaphore
  - 0 또는 1 값만 가질 수 있는 세마포어
  - 단일 자원에 대한 접근을 제어할 때 사용
  - 한 번에 한 스레드만 자원 접근 가능

# 뮤텍스(Mutex)

Mutual Exclusion(상호 배제)의 줄임말로 한 번에 하나의 프로세스만 공유 자원에 접근하도록 보장한다.

- Lock(잠금) - Unlock(해제) 방식의 락 매커니즘을 사용한다.
- 오직 임계 구역을 사용하는 프로세스만 락을 해제할 수 있음 (타인은 해제 불가)
- 락을 획득한 프로세스만 임계 구역에 진입 가능
- 다른 프로세스는 락이 해제될 때까지 대기
- 기본 연산
  - **Lock**
    → 임계 구역 **진입 시도**
    → 이미 Lock 상태라면 **대기**
  - **Unlock**
    → 임계 구역 **사용 완료 알림**
    → 다른 대기 중인 프로세스가 Lock 획득 가능

## 뮤텍스 vs 세마포어

공통점 : 여러 프로세스 또는 쓰레드가 임계 영역을 동시에 접근하지 못하도록 막는 메커니즘
| **구분** | **뮤텍스 (Mutex)** | **세마포어 (Semaphore)** |
| --- | --- | --- |
| **동기화 대상의 갯수** | **하나**: 하나의 자원에 대해서만 동기화. | **하나 이상**: 여러 자원에 대해서도 동기화 가능. |
| **소유와 책임** | **소유 가능**: 뮤텍스를 잠근 스레드만 해제할 수 있음. 공유 자원의 소유자. | **소유 불가능**: 세마포어는 소유하지 않으며, 세마포어를 잠근 스레드가 아닌 다른 스레드도 해제 가능. |
| **상태** | **두 가지 상태**: Lock과 Unlock만 있음 | **여러 가지 상태**: 세마포어 값에 따라 여러 상태가 가능. |
| **프로세스/스레드의 접근** | **상호 배제**: 하나의 스레드만 자원에 접근 가능. | 자원에 여러 프로세스나 스레드가 동시에 접근할 수 있음. |
| **사용 용도** | **단일 자원 보호**: 공유 자원이 하나일 때 사용. | **여러 자원 보호**: 여러 자원이 있을 때 사용. |

# 데드락

여러 프로세스가 서로가 가진 자원을 기다리며 무한히 대기에 빠지는 상태
※ 여기서 자원은 하드웨어, 소프트웨어 등을 모두 포함하는 개념

예시

- 시스템에 2개의 테이프 드라이브가 있을 때:
    - 프로세스 **P1**이 드라이브 A를 사용 중이고 드라이브 B를 요청
    - 프로세스 **P2**가 드라이브 B를 사용 중이고 드라이브 A를 요청
        
        → 서로가 상대 자원을 기다리며 무한 대기 상태 발생 = 데드락
        

## 데드락 발생 조건

- 상호 배제 **(Mutual Exclusion)**
    - 하나의 자원은 오직 하나의 프로세스만 사용 가능해야 함
        
        → 동시에 여러 프로세스가 자원을 사용할 수 없음
        
- 비선점 **(No Preemption)**
    - 자원을 강제로 뺏을 수 없음
        
        → 자원을 가진 프로세스가 스스로 반납해야만 자원을 회수 가능
        
- 보유 대기 **(Hold and Wait)**
    - 자원을 가진 프로세스가 다른 자원을 요청하며 대기
        
        → 이미 가지고 있는 자원은 계속 보유한 채로 기다림
        
- 순환 대기 **(Circular Wait)**
    - 자원을 기다리는 프로세스들 사이에 원형 대기 상태 발생
        
        → 예: P0 → P1 → P2 → P0처럼 서로가 서로의 자원을 기다림
        

## 데드락 해결 방법

- 데드락 예방 (Prevention)
- 데드락 회피 (Avoidance)
- 데드락 탐지 및 회복 **(Detection & Recovery)**
- 데드락 무시 (Ignore)

### 데드락 예방

자원 할당 시 데드락의 4가지 필요 조건 중 하나를 원천적으로 차단하는 방법 (미연에 방지)

- 상호 배제 : 자원 자체의 특성이어서 방지 불가
- 보유 대기 : 모든 자원을 한꺼번에 요청하게 함 or 자원이 필요한 경우 기존 자원을 반납한 후 요청
- 비선점 : 자원을 기다리는 프로세스에게 우선순위를 부여
- 순환 대기 :  자원에 고유한 순서(번호)를 부여하고, 프로세스가 항상 번호 순서대로 요청

단점 : 자원이용률 저하, 처리율 감소, starvation 발생

### 데드락 회피

자원의 부가 정보를 활용해서 데드락 가능성이 없는 경우에만 자원을 할당

### **은행원 알고리즘**

- 기본 개념
    - 자원 요청이 들어오면, 지금 그 자원을 할당해도 시스템이 안전 상태를 유지할 수 있는지를 확인
    - 안전 상태: 모든 프로세스가 최대 자원 요구량까지 자원을 할당받고도 결국 모두 종료될 수 있는 상태
- 가정 조건
    - 모든 프로세스는 자원의 최대 요구량을 미리 시스템에 알려야 함
    - 프로세스는 자원을 모두 할당받으면 유한 시간 내에 자원을 반납함 (즉, 무한정 점유하지 않음)
- 동작 과정
    - 프로세스가 자원을 요청
    - 시스템이 요청을 허용하면 안전 상태가 유지되는지 시뮬레이션
    - 안전 상태라면 요청을 허용
        
        → 프로세스는 자원을 얻고 작업을 진행
        
    - 프로세스가 종료되면 자원을 반납
    - 반복하며 모든 프로세스가 종료 가능한 경우 = 안전 상태
- 단점
    - 프로세스의 최대 자원 요구량을 미리 알아야 함
    - 자원의 낭비가 발생할 수 있음

### 데드락 탐지 및 회복

데드락의 발생을 허용하되, 시스템이 주기적으로 상태를 검사하여 데드락을 탐지하고, 발생 시 적절한 회복 조치를 수행하는 방식

- 탐지 기법
    - 자원 할당 그래프
        - 프로세스와 자원을 정점으로 구성
        - 요청과 할당 관계를 간선으로 표현
        - 그래프에 사이클이 존재하면 데드락 가능성 존재
    - Allocation, Request, Available 등을 이용하여 탐색
- 회복 기법
    - 프로세스 종료
        - 데드락에 연루된 프로세스를 하나씩 또는 전체 종료
    - 자원 선점
        - 일부 프로세스에서 자원을 강제로 회수하여 다른 프로세스에 할당
        - 선점 대상 선정 기준:
            - 회복 비용이 적은 프로세스
            - 쉽게 재시작 가능한 프로세스 등

### 데드락 무시

데드락이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않는 방식

- 데드락이 매우 드물게 발생하므로 데드락에 대한 조치 자체가 더 큰 오버헤드일 수 있음
- 만약, 시스템에 데드락이 발생한 경우 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 프로세스를 죽이는 등의 방법으로 대처함
- UNIX, Windows 등 대부분의 OS에서 채택하였음