## 동기화 문제 (Race Condition, Deadlock) + 세마포어 & 뮤텍스

### Race Condition(경쟁 조건)

> 둘 이상의 프로세스 or 스레드가 동시에 공유 자원에 접근하면서, 실행 순서나 타이밍에따라 결과가 달라지는 문제 상황
>
- 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태
- 동시 접근 시 자료의 일관성을 해치는 결과가 나타남
    - 순서에 따라 결과가 달라지는 문제
- 문맥 교환(Context Switching)이 적절하지 않은 시점에 발생하면, 공유 자원의 상태가 꼬일 수 있음
- Race Condition(경쟁 조건)에 처한 경우 실행할 때마다 다른 결과를 얻는다.
- 동기화 문제

**Race Condition이 발생하는 사례**

1. 커널 작업 중에 인터럽트 발생
    - 문제점 : 커널모드에서 공유 데이터를 조작하던 중 인터럽트가 발생하여, 동일한 데이터를 조작하는 경우
    - 해결법 : 커널모드에서 작업을 수행하는 동안 인터럽트를 비활성화시켜  CPU 제어권을 빼앗기지 않도록 함
2. 커널 모드로 진입 후 Context Swtiching이 발생
    - 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간 초과되어 CPU 제어권을 빼앗기고, 다른 프로세스가 동일한 자원을 조작할 수 있는 상태
    - 해결법: 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함 (선점 방지 or 동기화 기법)
3. 멀티 프로세서 환경에서 공유 메모리 접근
    - 문제점 : 멀티프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우 일관성이 깨질 수 있음
    - 해결법 : 해당 자원에 대한 lock/unlock을 사용하여 상호 배제를 구현

📂 **[개발자가 알아야하는 이유]**

- Race Condition 발생 시 Data Integrity(데이터 무결성)이 깨져서 프로그램 오류 발생
- 멀티스레드 & 비동기 환경에서 S**pring + 멀티스레드 환경**, **DB 트랜잭션**, **서버 API 동시 요청**에서 쉽게 발생하는 문제

**💡 Q.** **Race Condition 이 무엇인가요?**

A. 둘 이상의 프로세스나 스레드가 동시에 공유 자원에 접근하면서, 실행 순서나 타이밍에 따라 프로그램 결과가 달라지는 현상입니다. 동기화 없이 동시에 접근할 경우 데이터 무결성이 깨지거나 예측 불가능한 결과가 발생할 수 있습니다.

### Deadlock(교착 상태)

> 두개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태
>
- 무한히 다음 자원을 기다리게 되는 상태
- 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생
- 두 프로세스가 서로 원하는 자원이 상대방에 할당되어 있어서 무한정 wait 상태에 빠지는 현상

### 1. Deadlock prevention(예방)

- Mutual exclusion(상호 배제)
    - 한번에 하나의 프로세스만 자원을 사용할 수 있다
    - 즉, 공유 자원은 동시에 여러 프로세스가 사용할 수 없다
    - ex) 프린터 같은 자원은 동시에 두 개의 작업이 사용할 수 없다. 한 작업이 끝나야 다음 작업 시작
- Hold and wait(점유 대기)
    - 자원을 가지고 있으면서, 다른 자원이 풀리길 기다리는 상황
    - 프로세스가 적어도 하나의 자원을 점유하고 있고, 추가로 다른 자원을 요청하면서 기다리는 상황
    - ex) 파일을 점유한 프로세스가 네트워크 연결이 필요해서 기다리는 상황
- No preemption(비선점)
    - 다른 프로세스가 자원을 빼앗을 수 없음
    - 한번 어떤 프로세스가 자원을 가지면 스스로 반납하기 전까지 다른 프로세스가 사용 할 수 없다
    - ex) 내가 문서를 작업하는 동안에는 다른 사람이 강제로 문서를 작업하러 가져갈 수 없음. 작업이 끝나고 나서야 문서를 넘겨줌
- Circular wait(순환 대기)
    - 프로세스들이 원형으로 자원을 기다리는 상태
    - A→ B → C → A 이렇게 서로가 서로의 자원을 기다리는 꼬리물기 상태

| **조건** | **설명** |
| --- | --- |
| 상호 배제 | 자원을 동시에 여러 프로세스가 사용할 수 없다 |
| 점유 및 대기 | 자원을 점유한 채로 추가 자원을 기다린다 |
| 비선점 | 자원을 강제로 빼앗을 수 없다 |
| 순환 대기 | 프로세스들이 원형으로 자원을 기다린다 |
- 4가지 상태 모두 만족시 Deadlock(교착 상태) 발생

### 2. Deadlock avoidance(회피)

> 자원 요청에 대한 부가정보를 이용해서 자원 할당이 Deadlock으로부터 safe한 지 동적으로 조사해서 안전한 경우에만 할당
>

![0415-1.png](..%2F..%2F..%2F..%2FDocuments%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%2F0415-1.png)

- Safe State(안전 상태)

  : 모든 프로세스가 자원을 요청하더라도 Deadlock 없이 처리할 수 있는 상태

    - 시스템이 DeadLock을 피할 수 있다
    - 안전한 자원 할당 상태라서, 어떤 프로세스가 자원을 더 요청하더라도 결국은 모두 작업을 마치고 자원을 반환할 수 있음
    - Unsafe State(비안전 상태)
        - 언제든지 Deadlock이 발생할 수 있는 잠재적인 상태
        - 관리 안하면 Deadlock이 생길 수 있는 위험한 구역
            - 자원이 부족하거나 할당 순서에 따라 발생할 수도 있음
    - Deadlock(교착 상태)
        - 실제로 Deadlock이 발생해서 프로세스들이 자원을 서로 기다리며 멈춰버린 상태
        - Unsafe state의 부분 집합
        - 프로그램이 더이상 진행 될 수 없고, 실제로 Deadlock이 발생한 상태

  c. Deadlock Detection and recovery

    - Deadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock 발견시 recover

  d. Deadlock Ignorance

    - Deadlock을 시스템이 책임지지 않음
    - UNIX를 포함한 대부분의 OS가 채택

### Avoidance Algorithms

| **자원 종류** | **사용하는 기법** |
| --- | --- |
| **단일 인스턴스** (자원 1개) | **Resource Allocation Graph (자원 할당 그래프)** |
| **다중 인스턴스** (자원 여러 개) | **Banker’s Algorithm (은행원 알고리즘)** |
1. **Resource Allocation Graph (자원 할당 그래프)**


![0415-2.png](..%2F..%2F..%2F..%2FDocuments%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%2F0415-2.png)
- T1 → R1 요청, R2 점유
- T2 → R3 요청, R1 점유
- T3이 계속 멈춰있다면 T1, T2가 계속 기다리는 Deadlock 위험 상태

![0415-3.png](..%2F..%2F..%2F..%2FDocuments%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%2F0415-3.png)



- 그래프에 cycle이 없으면 deadlock이 아니다
- 그래프에 cycle이 있으면
    - 리소스 유형당 하나의 인스턴스만 있는 경우 사이클이 발생해도 데드락이 발생하지 않음
    - 리소스 유형별로 여러 인스턴스가 있는 경우 Deadlock 가능성(O)

1. **Banker’s Algorithm (은행원 알고리즘)**

> 다중 인스턴스 자원을 가진 시스템에서 Deadlock을 회피하기 위한 자원 할당 시뮬레이션 알고리즘
>
- Unsafe State 상태
- **“지금 이 자원을 할당해줘도 안전한 상태인가?”**
- 은행에서 모든 고객이 만족하도록 현금을 할당하는 과정과 동일
    - 다수의 인스턴스를 갖는 경우
    - 자원 할당 그래프 기법보다 다소 효율성이 떨어짐

  | **용어** | **의미** |
      | --- | --- |
  | **Max** | 각 프로세스가 필요한 **최대 자원 수** |
  | **Allocation** | 현재 할당된 자원 수 |
  | **Need** = Max - Allocation | 남은 필요 자원 |
  | **Available** | 현재 시스템에 남아 있는 자원 수 |
    - 방법
        - 프로세스 시작 시 자신이 필요한 각 자원의 최대 개수를 미리 선언
        - 각 프로세스가 자원을 요청하면
            - 요청 수락 시 안정 상태에 머무는지 판단하여 수락
            - 불안정이 예상되면 다른 프로세스가 끝날 때까지 대기

    - 단점 : 각 프로세스가 미리 Max를 선언해야 하기에 실제 환경에서는 반영되기 어렵고, 매번 안전성 검사를 해야 하므로 성능 부담된다

### **3. Deadlock Detection(탐지)**

- 교착상태 발생을 허용하고 발생 시 원인을 규명하여 해결하는 방법
- 예시) 자원할당 그래프

### **4. Deadlock Recovery(회복)**

- 교착상태 발견 후 환형대기를 배제시키거나 자원을 중단하는 메모리 할당 기법
- 예시) 선점, 프로세스 중지 (희생자 선택의 원칙 : 최소 비용으로 중지시키는 방법을 찾아야 함)

### Race Condition VS Deadlock

- `Race Condition`: 동시에 접근해서 꼬임 (데이터 오류)
- `Deadlock` : 서로 기다리다가 멈춤 (프로그램 멈춤)

| **구분** | **Race Condition (경쟁 상태)** | **Deadlock (교착 상태)** |
| --- | --- | --- |
| **정의** | 여러 프로세스/스레드가 **공유 자원에 동시에 접근**하면서 순서에 따라 결과가 달라지는 문제 | 프로세스/스레드가 **서로 자원을 점유하고 대기**하면서 무한히 기다리는 상태 |
| **원인** | 동기화 부족, Lock 없이 공유 자원 접근 | 순환 대기, 점유 및 대기, 비선점 등 4가지 조건 충족 시 발생 |
| **결과** | 잘못된 값, 예기치 않은 동작 (ex. 데이터 손상) | 프로그램이 멈춤 (무한 대기, 시스템 정지) |
| **발생 시기** | 주로 자원 **쓰기/읽기 동시 접근 시** | 주로 **서로 다른 자원을 점유하고 대기할 때** |
| **예시** | 두 스레드가 하나의 계좌 잔액을 동시에 수정해서 값이 꼬이는 경우 | 프로세스 A는 프린터를, B는 파일을 점유하고 서로 상대 자원을 요청하며 무한 대기 |
| **방지 방법** | 락, 원자적 연산, 동기화 | Deadlock 예방 알고리즘, Lock 순서 지정, 자원 선점 정책 |
| **문제 성격** | 데이터의 **일관성 문제** | 프로그램의 **진행 불가(정지) 문제** |

📂 **[개발자가 알아야하는 이유]**

- 멀티스레드 환경에서 자주 발생하는 문제
- 백엔드 시스템의 동시 처리 환경에서 lock을 걸게 될 때, 락의 순서나 해제 조건이 잘못되면 서로 자원을 기다리면서 영원히 멈추는 상태가 될 수 있다
- 개발자가 lock을 신중하게 다루지 않는다면 프로그램이 멈추거나 응답되지 않는 버그가 생길 수 있음

**💡Q.** **Deadlock이 무엇인지 설명해주시고 해결할 수 있는 방안에 대해 알려주세요**

**A. Deadlock이란** 교착상태란 뜻으로 서로 필요한 자원 사용을 위해 상대방의 종료를 기다리며, 무한 대기에 빠지는 상황입니다.  해결 방안은 4가지가 있습니다.

1. **예방 (Prevention)**
- 기존 Deadlock이 프로세스들끼리 자원 사용시 서로 상호 배제한단 것이 문제가 되었으니, 자원을 공유하게 하여 대기에 빠지지 않도록 함
- 교착상태의 필요조건을 부정함으로써 교착상태가 발생하지 않도록 미리 예방하는 방법
- 환형 대기, 비선점, 점유와 대기, 상호 배제 4가지 부정
1. **회피 (Avoidance)**
- 프로세스에 대한 교착 상태 가능성을 미리 판단하며 배제하지 않고 적절하게 피해나가는 방법
- 예시) **은행원 알고리즘** 처럼 사전에 필요로 하는 최대 자원을 파악하여 교착상태를 최대한 피함
1. **탐지 (Detection)**
- 교착상태 발생을 허용하고 발생 시 원인을 규명하여 해결하는 방법
- 예시) 자원할당 그래프
1. **회복 (Recovery)**
- 교착상태 발견 후 환형대기를 배제시키거나 자원을 중단하는 메모리 할당 기법
- 예시) 선점, 프로세스 중지 (희생자 선택의 원칙 : 최소 비용으로 중지시키는 방법을 찾아야 함)

**💡  Q. 데드락(교착상태) 발생 조건에 대해서 설명해주세요.**

A. 상호배제, 점유와 대기, 비선점형, 원형대기입니다.

**💡 Q. 은행원 알고리즘에 대해 설명해주세요**

A. 멀티프로세스 환경에서 Deadlock을 회피하기 위해 사용되는 자원 할당 알고리즘입니다. 자원 요청이 들어왔을 때, 지금 그 요청을 수락해도 모든 프로세스가 종료할 수 있는 Safe State인지 시뮬레이션해서 판단합니다.

**💡Q. Race Condition과 Deadlock의 차이에 대해서 설명해주세요**

A. Race Condition은 실행 순서에 따라 결과가 달라지는 데이터 문제이고, Deadlock은 서로 자원을 기다리며 진행이 멈추는 상태 문제입니다.

### Semaphore(세마포어)

> 소프트웨어상에서 Critical Section 문제를 해결하기 위한 동기화 도구
>

![0415-4.png](..%2F..%2F..%2F..%2FDocuments%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%2F0415-4.png)

- 한번에 여러 개의 스레드가 공유 자원에 접근하는 것을 조절하는 동기화 기구
    - 공유된 자원의 데이터는 한번에 하나의 프로세스만 접근할 수 있도록 제한을 둬야 한다
- 공유 자원에 동시에 접근할 수 있는 최대 개수를 지정
- 서버 동시 접속 수 제한
- pool 기반 리소스 관리 (ex. DB connection pool)
- **공유 프린터**, **버스 좌석**, **주차장** 같은 **제한된 자원 관리**

```java
import java.util.concurrent.Semaphore;

public class Example {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3); // 최대 3개까지 동시에 접근 가능

        for (int i = 0; i < 10; i++) {
            final int threadNum = i;
            new Thread(() -> {
                try {
                    semaphore.acquire(); // 들어갈 수 있는지 확인
                    System.out.println("Thread " + threadNum + " entered");
                    Thread.sleep(1000); // 자원 사용 중
                    System.out.println("Thread " + threadNum + " exiting");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release(); // 자원 반환
                }
            }).start();
        }
    }
}
```

- 10개 Thread 중 동시에 3개만 실행되도록 제어해줌

### 임계구역(Critical Section)

> 여러 프로세스가 데이터 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분
>

공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에, 한 프로세스가 임계구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야 한다.

### Mutext(뮤텍스)

> Critical Section(임계영역)을 가진 Thread들의 Running time간 서로 겹치지 않고 단독으로 실행되게 하는 기술
>

![0415-5.png](..%2F..%2F..%2F..%2FDocuments%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%2F0415-5.png)

- 상태가 0, 1여서 이진 세마포어라고 부르기도 한다
- lock : 현재 임계 구역에 들어갈 권한을 얻어옴
- unlock: 현재 임계 구역을 모두 사용했음을 알림

### Mutex Algorithm

1. Dekker Algorithm(데커 알고리즘)

> flag와 turn 변수를 통해 임계 구역에 들어갈 프로세스/스레드를 결정하는 방식
>
- flag : 프로세스 중 누가 임계영역에 진입할 것인지 나타내는 변수
- turn : 누가 임계구역에 들어갈 차례인지 나타내는 변수

```java
while(true) {
    flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
    while(flag[j]) { // 프로세스 j가 현재 임계 구역에 있는지 확인
        if(turn == j) { // j가 임계 구역 사용 중이면
            flag[i] = false; // 프로세스 i 진입 취소
            while(turn == j); // turn이 j에서 변경될 때까지 대기
            flag[i] = true; // j turn이 끝나면 다시 진입 시도
        }
    }
}

// ------- 임계 구역 ---------

turn = j; // 임계 구역 사용 끝나면 turn을 넘김
flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
```

1. Peterson Algorithm(피터슨 알고리즘)

> Dekker와 유사하지만, 상대방 프로세스/스레드에게 진입 기회를 양보하는 것에 차이가 있음
>

```java
while(true) {
    flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
    turn = j; // 다른 프로세스에게 진입 기회 양보
    while(flag[j] && turn == j) { // 다른 프로세스가 진입 시도하면 대기
    }
}

// ------- 임계 구역 ---------

flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
```

1. Bakery Algorithm(제과점 알고리즘)

> 여러 프로세스/스레드에 대한 처리가 가능한 알고리즘. 가장 작은 번호표를 가지고 있는 프로세스가 임계 구역에 진입한다.
>

```java
while(true) {
    
    isReady[i] = true; // 번호표 받을 준비
    number[i] = max(number[0~n-1]) + 1; // 현재 실행 중인 프로세스 중에 가장 큰 번호 배정 
    isReady[i] = false; // 번호표 수령 완료
    
    for(j = 0; j < n; j++) { // 모든 프로세스 번호표 비교
        while(isReady[j]); // 비교 프로세스가 번호표 받을 때까지 대기
        while(number[j] && number[j] < number[i] && j < i);
        
        // 프로세스 j가 번호표 가지고 있어야 함
        // 프로세스 j의 번호표 < 프로세스 i의 번호표
    }

    // ------- 임계 구역 ---------

    number[i] = 0; // 임계 구역 사용 종료
}
```

| **구분** | **세마포어 (Semaphore)** | **뮤텍스 (Mutex)** |
| --- | --- | --- |
| 목적 | 자원 수 제한 (N개 접근 허용) | 하나만 접근 허용 (1개 제한) |
| 값 | 0 이상 | 0 또는 1 |
| 소유권 | 없음 | 있음 (락 잡은 스레드만 해제 가능) |
| 예시 | 주차장(여러 명 동시에 사용) | 화장실 열쇠(한 명만 사용) |

📂 **[개발자가 알아야하는 이유]**

- 현대 OS는 Deadlock을 처리하지 않기 때문에 실무에서는 개발자가 Deadlock이 발생하지 않도록 lock 획득 순서를 정하거나, timeout, retry, DB 트랜잭션 설계 등으로 처리하는 게 일반적
- 멀티스레드 환경의 synchronization(동기화)를 해결하기 위한 대표 도구가 Semaphore와 Mutex
- Critical Section을 안전하게 보호하기 위함

**💡 Q. 이진 세마포어와 뮤텍스의 차이에 대해 설명해 주세요**.

A. 이진 세마포어는 값이 0 or 1인 세마포어로 **자원의 접근 가능 여부를 제어**하며, **소유권이 없고** 어떤 스레드인지 release할 수 있습니다. 반면, 뮤텍스는 lock()을 획득한 스레드만 unlock()으로 해제할 수 있는 **소유권 기반 동기화 기구**이며, 임계 구역을 보호하기 위해 스레드 간 상호 배제를 보장합니다.

**💡 Q. 왜 현대 OS는 Deadlock을 처리하지 않을까요?**

A. Deadlock 회피 알고리즘이 성능에 큰 부담을 주기 때문입니다. 예를들어 은행원 알고리즘처럼 자원 요청마다 시스템 전체 상태를 시뮬레이션 하는 방식은 매우 복잡하고 느리며 실시간으로 반응해야 하는 OS에 적합하지 않습니다. 그래서 실무에서는 개발자가 Deadlock이 발생하지 않도록 lock 획득 순서를 정하거나, timeout, retry, DB 트랜잭션 설계 등으로 처리하는 게 일반적입니다.

**💡 Q. Peterson's Algorithm 이 무엇이며, 한계점에 대해 설명해 주세요.**
A. 피터슨 알고리즘이란 듀 풇새수 건 소프트웨어 동기화를 위한 상호 배제 알고리즘입니다. 두 프로세스만을 동기화 가능한 알고리즘이기 때문에 다중 프로세스 환경에서는 구현이 복잡해지고 성능이 떨어집니다. 또한, 메모리 일관성 문제, 확장성, busy waiting 한계로 인해 잘 사용되지 않습니다.