# 동기화 문제 (Race Condition, Deadlock)

## Race Condition

여러 개의 프로세스가 공유자원에 동시 접근할 때 실행 순서에 따라 결과값이 달라질 수 있는 현상

→ 같은 코드를 수행해도 레이스 컨디션이 발생하여 결과가 달라질 수 있기 때문이다. 경쟁 상태의 근본적인 원인은 **메모리 공유**이다.

이러한 문제를 방지하기 위해 공유 메모리를 쓰는 프로세스끼리 동기화를 진행해야한다.

### 해결방안 : 동기화

쓰레드의 순차적 실행을 보장해주기

동시에 공유 자원을 접근할 수 없도록 상호 배제 조건을 만들어 놓는다.

→ Mutual Exclusion 

여러 스레드가 하나의 스레드만이 차지할 수 있는 락을 획득하기 위해 경합한다고 해서 붙여진것이다. 하지만 상호배제를 진행해도 교착상태가 발생할 수 있다.

### 교착상태(Deadlock)

→ 공유 자원에 대한 요구가 엉켜서 자원 관리를 잘못하여 프로세스나 스레드가 자원의 락을 획득하기 위해 무한 대기하는것

시스템 적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.

(외나무 다리의 양 끝에서 서로가 비켜주기를 기다리고만 있는 것과 같다.)

![image](https://github.com/user-attachments/assets/a2836f53-0ad2-4c30-b394-b20f388297c2)


프로세스1과 2가 자원1, 2를 모두 얻어야 한다고 가정해보자

t1 : 프로세스1이 자원1을 얻음 / 프로세스2가 자원2를 얻음

t2 : 프로세스1은 자원2를 기다림 / 프로세스2는 자원1을 기다림

현재 서로 원하는 자원이 상대방에 할당되어 있어서 두 프로세스는 무한정 wait 상태에 빠짐

→ 이것이 바로 **DeadLock**

(주로 발생하는 경우)

> 멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황 발생
> 
> 
> 한 프로세스가 자원을 요청했을 때, 동시에 그 자원을 사용할 수 없는 상황이 발생할 수 있음. 이때 프로세스는 대기 상태로 들어감
> 
> 대기 상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때 '교착 상태' 발생
> 

### 데드락 발생 조건

4가지의 조건이 모두 성립해야 데드락 발생

1. 상호 배제(Mutual exclusion)
2. 점유 대기(Hold and wait)
3. 비선점(No preeption)
4. 순환 대기(Circular wait)

### 데드락 처리

1. 예방(prevention)
    
    교착 상태 발생 조건 중 하나를 제거하면서 해결한다 (자원 낭비 엄청 심함)
    
    > 상호배제 부정 : 여러 프로세스가 공유 자원 사용
    점유대기 부정 : 프로세스 실행전 모든 자원을 할당
    비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
    순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구
    > 
2. 회피(avoidance)
    
    교착 상태 발생 시 피해나가는 방법
    
    > 은행원 알고리즘(Banker's Algorithm)
    > 
    > - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함
    > - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피
    > - 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기
    
    > 자원 할당 그래프 알고리즘(Resource-Allocation Graph Algorithm)
    > 
    > - 자원과 프로세스에 대해 요청 간선과 할당 간선을 적용하여 교착 상태를 회피하는 알고리즘
    > - 프로세스가 자원을 요구 시 요청 간선을 할당 간선으로 변경 했을 시 사이클이 생성 되는지 확인한다
    > - 사이클이 생성된다 하여 무조건 교착상태인 것은 아니다
    >     
    >     > 자원에 하나의 인스턴스만 존재 시 교착 상태로 판별한다자원에 여러 인스턴스가 존재 시 교착 상태 가능성으로 판별한다
    >     > 
    > - 사이클을 생성하지 않으면 자원을 할당한다

**교착 상태를 탐지 & 회복**

교착 상태가 되도록 허용한 다음 회복시키는 방법

1. 탐지(Detection)
    
    자원 할당 그래프를 통해 교착 상태를 탐지함
    
    자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함
    
2. 회복(Recovery)
    
    교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법
    
    > 프로세스 종료 방법
    > 
    > - 교착 상태의 프로세스를 모두 중지
    > - 교착 상태가 제거될 때까지 하나씩 프로세스 중지
    > 
    > **자원 선점 방법**
    > 
    > - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)
    > - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점

**주요 질문**

1. 데드락(교착 상태)가 뭔가요? 발생 조건에 대해 말해보세요.
2. 회피 기법인 은행원 알고리즘이 뭔지 설명해보세요.
3. 기아상태를 설명하는 식사하는 철학자 문제에 대해 설명해보세요.


🍽️ 식사하는 철학자 문제 (Dining Philosophers Problem)
🧠 문제 상황
5명의 철학자가 동그란 식탁에 앉아 있고, 철학자 사이사이에 포크가 하나씩 놓여 있음.

각 철학자는 다음 두 가지 행동을 반복함:

생각하기 (Thinking)

배가 고프면 두 개의 포크를 집고 식사하기 (Eating)

🎯 규칙
식사를 하려면 좌우 양쪽의 두 개의 포크를 동시에 집어야 함.

포크는 한 번에 한 철학자만 사용 가능

🔒 이 문제에서 발생할 수 있는 문제들
1. ❗ 데드락 (Deadlock)
모든 철학자가 동시에 왼쪽 포크만 들고 오른쪽 포크를 기다리면 → 서로 기다리다 멈춰버림

→ 무한 대기 상태

2. ⚠️ 기아 상태 (Starvation)
어떤 철학자는 계속해서 포크를 획득하지 못하고 식사를 못 하는 상태가 될 수 있음

예: 포크를 차지한 이웃 철학자들이 계속 번갈아 가며 먹기만 하고, 가운데 철학자는 영원히 대기 상태

→ 기아 상태(굶는 상태) 발생

🌟 기아 상태를 유발하는 상황 요약
스레드(철학자)가 자원을 계속 기다리지만, 다른 스레드들이 계속 우선권을 가져서 사용하지 못하는 상태

자원을 사용할 기회가 오지 않음 → 영원히 굶음

🔧 해결 방법 (Starvation 방지법)
공정한 자원 할당 (Fair Scheduling)
→ 철학자들에게 포크를 공평하게 차례대로 사용할 수 있게 함

우선순위나 대기 시간 기반 정책
→ 오랫동안 기다린 철학자에게 우선권 부여

세마포어(semaphore), 모니터(monitor), 뮤텍스(mutex) 사용
→ 교착 상태나 기아 상태를 방지하기 위한 동기화 메커니즘 적용


    
    

# 세마포어, 뮤텍스

## 뮤텍스

→ 공유된 자원의 데이터나 임계영역(critical section) 같은 곳에 스레드의 러닝타임이 서로 겹치지 않게 하나의 프로세스 또는 스레드가 접근하는 것을 막는다.

상호배제를 구현하기 위한 동기화 기법중 하나이다.

공유 자원에 대한 접근을 동시에 하나의 스레드만 가능하게 제한한다.

즉, 뮤텍스는 동기화 대상이 하나인게 특징

다른 스레드들은 뮤텍스의 락을 가지기 위해 대기하며, 락을 해제하는 스레드가 있을때까지 다른 스레드들은 접근하지 못한다.

한 프로세스에 의해 소유될 수 있는 key 기반으로 한 상호배제 기법이고 키에 해당하는 객체가 있으며 이 객체를 소유한 스레드와 프로세스만이 공유 자원에 접근 가능하다.

<img width="769" alt="image2" src="https://github.com/user-attachments/assets/94c8b300-c94c-4be3-8133-3c287ae20e8c" />


출처 : https://heeonii.tistory.com/14

## 세마포어 :

리소스의 상태를 나타내는 간단한 카운터라고 생각할 수 있다.

일반적으로 비교적 긴 시간을 확보하려는 리소스에 대해 이용하게 되며 유닉스 시스템의 프로그래밍에서 세마포어는 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 동기화 시키는 기술이다.

공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 여러 Process 혹은 Thread가 접근하는 것을 막아줌 (동기화 대상이 하나 이상)

<img width="743" alt="image3" src="https://github.com/user-attachments/assets/56481adb-14e9-41c3-b54f-0f0f12c5f79a" />


출처 : https://heeonii.tistory.com/14

### 차이점

- 동기화 대상의 갯수 차이 : 뮤텍스는 동기화 대상이 오직 하나이고, 세마포어는 변수만큼의 프로세스 접근이 가능하여 하나 이상이다.
- 세마포어는 lock을 소유할 수 없지만 뮤텍스는 책임을 가지는 대신 lock을 소유를 할 수 있다. 그 이유는 뮤텍스 의 상태는 0,1 이 두개 뿐이기 때문이다.
