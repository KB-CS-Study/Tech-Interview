- [OWASP Top 10, XSS, CSRF](https://0woy.tistory.com/entry/OWASP-Top-10-XSS-CSRF)
- [웹 사이트 보안: 보안 헤더 & 쿠키 설정](https://0woy.tistory.com/entry/%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EB%B3%B4%EC%95%88-%EB%B3%B4%EC%95%88-%ED%97%A4%EB%8D%94-%EC%BF%A0%ED%82%A4-%EC%84%A4%EC%A0%95)
- [JWT 보안 및 2FA](https://0woy.tistory.com/entry/JWT-%EB%B3%B4%EC%95%88-%EB%B0%8F-2FA)

---

## OWASP (Open Worldwide Application Security Project)

OWASP는 **오픈소스 보안 프로젝트**로,  
보안 전문가들이 전 세계적으로 수집한 실데이터를 바탕으로 이 목록을 주기적으로 업데이트 함

가장 최근 기준은 **OWASP Top 10 – 2021**

-   OWASP Top 10은 **웹 보안의 체크리스트**
-   **개발자, 기획자, QA** 등 모두가 의식적으로 확인해야 함
-   각 항목은 실제 해킹 사례 기반
-   보안 점검, 보안 코딩, 시스템 설계 시 **필수 가이드라인**

각 항목은 **위험도, 발생 빈도, 영향도** 등을 종합해 순위를 매김 👇🏻 

| 순위 | 항목 코드 | **취약점 이름** | 설명 |
| --- | --- | --- | --- |
| 1 | A01:2021 | **Broken Access Control** | 권한 없는 사용자가 데이터나 기능에 접근할 수 있는 문제 |
| 2 | A02:2021 | **Cryptographic Failures**   (구. 민감정보 노출) | 암호화 실패로 인한 데이터 유출 (ex. 평문 전송, 약한 알고리즘 등) |
| 3 | A03:2021 | **Injection** | SQL, Command, LDAP 등 입력값을 통해 의도치 않은 명령어 실행 |
| 4 | A04:2021 | **Insecure Design** | 보안이 고려되지 않은 시스템 설계 (기획단계부터 문제) |
| 5 | A05:2021 | **Security Misconfiguration** | 서버/프레임워크/라이브러리의 잘못된 설정   (ex. 디버그 모드 ON, 오류 메시지 노출 등) |
| 6 | A06:2021 | **Vulnerable and Outdated Components** | 보안 패치가 안 된 라이브러리나 프레임워크 사용 |
| 7 | A07:2021 | **Identification and Authentication Failures** | 로그인, 세션 관리의 실패 (ex. 무차별 대입 공격 방지 미비) |
| 8 | A08:2021 | **Software and Data Integrity Failures** | 배포 파일이나 중요 데이터가 검증되지 않아 조작 가능 |
| 9 | A09:2021 | **Security Logging and Monitoring Failures** | 보안 이벤트 로그 누락, 이상행위 탐지 실패 |
| 10 | A10:2021 | **Server-Side Request Forgery (SSRF)** | 서버가 외부 요청을 대신 보낼 때 악용되는 취약점 |

---

## XSS (Cross-Site Scripting)

사용자의 브라우저에 **악성 스크립트를 실행**시키는 공격

-   공격자가 웹 사이트에 악성 JS 삽입
-   피해자가 해당 페이지 방문 시 브라우저에서 스크립트 실행
-   쿠키 탈취, 세션 하이재킹, 피싱 페이지 유도 등 가능

### 주요 유형

| **이름** | **설명** |
| --- | --- |
| **Stored XSS** | 게시판 등 DB에 저장돼 다른 사용자에게 전파 |
| **Reflected XSS** | URL에 포함된 스크립트가 즉시 응답에 반영 |
| **DOM-based XSS** | 클라이언트 측 JS에서 DOM 처리 中 발생 |

---

### ❓ 어떻게 일반 사용자가 웹 사이트에 XSS 스크립트를 삽입하지

결론: 웹사이트가 **사용자 입력을 제대로 필터링하지 않고**, 그 내용을 그대로 **HTML 응답에 반영**할 때 발생

1.  웹사이트가 입력값을 검증 & 필터링 없이 처리
2.  서버 또는 클라이언트가 입력값을 그대로 HTML에 출력
3.  브라우저는 \`<script>\`나 \`onerror=...\` 같은 JS 문법 자동 실행

> 👉 즉, XSS는 **브라우저의 친절함을 역이용**하는 공격

---

#### 예시 1: 게시판, 댓글, 리뷰 기능

사용자가 입력한 내용을 DB에 저장한 후, **페이지에 출력할 때 escape 없이 그냥 출력**하는 경우

```
<!-- 게시판 글 작성 -->
<input name="content" value="<script>alert('XSS')</script>">
```

저장된 악성 스크립트가 HTML에 그대로 출력되면?

```
<p>오늘도 좋은 하루! <script>alert('XSS')</script></p>
```

👉 사용자가 아닌 **브라우저가 <script> 태그를 실행!**

---

#### 예시 2: URL 파라미터를 그대로 HTML에 출력

```
<!-- 검색 결과 페이지 -->
결과: <span id="query">"{{ searchTerm }}"</span>
```

사용자가 URL을 이렇게 만들면:

```
https://example.com/search?query=<script>alert('XSS')</script>
```

위 \`<script>\`가 HTML에 그대로 삽입되면서 브라우저 실행

---

#### 예시 3: JavaScript DOM 조작 (DOM-based XSS)

```
const param = new URLSearchParams(location.search).get("msg");
document.getElementById("output").innerHTML = param;
```

→ URL:

```
https://example.com/?msg=<img src=x onerror=alert('XSS')>
```

---

### 대응 방법

1\. **모든 사용자 입력은 출력 전 Escape 처리**

```
<p><%= escapeHtml(userInput) %></p>
```

2\. 절대 innerHTML로 삽입하지 말고, **textContent 또는 안전한 렌더링 함수 사용**

3\. \`WAF(Web Application Firewall)\`나 \`CSP(Content Security Policy)\`도 보조적으로 사용

---

## CSRF (Cross-Site Request Forgery)

CSRF는 공격자가 사용자의 웹 브라우저를 속여, 사용자가 로그인한 웹 사이트에 원치 않는 요청(예: 비밀번호 변경, 송금, 게시글 삭제 등) 을 보내도록 만드는 공격

사용자는 자신이 요청을 보낸다는 사실 인지X, 해당 웹 사이트에서는 사용자가 정상적으로 요청한 것으로 간주하여 처리함

---

### 작동 방식

1.  사용자가 합법적인 웹 사이트 A에 로그인, A는 사용자 인증을 위해 쿠키(세션 ID 등)를 발행하고 브라우저에 저장
2.  사용자는 공격자가 만든 악성 웹 사이트 B에 접속
3.  B는 웹 사이트 A로 특정 요청을 보내는 HTML 코드(예: <img> 태그의 src 속성에 요청 URL 삽입, 숨겨진 폼을 자동으로 제출, JavaScript를 이용한 AJAX 요청 등)를 포함
4.  사용자 브라우저는 B에 있는 코드를 해석하면서, A로 요청을 보냄. 이때 브라우저는 A에 대한 쿠키를 자동으로 첨부
5.  A는 이 요청이 사용자로부터 온 정상적인 요청으로 간주하고 처리 사용자는 자신이 원하지 않는 작업이 수행되었음을 나중에앎

---

### 방어 기법 = CSRF 토큰

가장 일반적이고 효과적인 CSRF 방어 기법은 CSRF 토큰을 사용하는 것

1.  서버는 사용자에게 폼을 제공할 때, **예측 불가한 무작위 문자열**을 생성해 폼에 숨겨진 필드로 삽입하고, 동시에 해당 토큰을 사용자의 세션에도 저장
2.  사용자가 폼을 제출하면, 서버는 요청에 포함된 **CSRF 토큰과 세션에 저장된 토큰 비교**
3.  두 토큰이 일치하면 정상적인 요청으로 간주 및 처리, 일치하지 않으면 CSRF 공격으로 판단하여 거부  
    **공격자는 사용자 세션에 저장된 토큰 값을 알 수 없으므로**, 위조된 요청에 올바른 토큰을 포함할 수 없음

> 📌 여기서 제공되는 예측 불가한 무작위 문자열이 CSRF 토큰임!

---

## 인풋 검증 (Input Validation)

-   인풋 검증은 사용자 또는 외부 시스템으로부터 받은 모든 입력 데이터가 애플리케이션의 기대치와 보안 요구 사항을 충족하는지 확인하는 과정
-   이는 악의적인 데이터가 시스템에 주입되거나, 시스템의 안정성을 해치는 것을 방지하기 위한 핵심적인 보안 조치임
-   인풋 검증이 제대로 이루어지지 않으면, 다양한 종류의 보안 취약점으로 이어짐

| 보안 취약점 | 설명 |
| --- | --- |
| SQL Injection | 악의적인 SQL 쿼리 삽입을 통해 DB 조작 |
| XSS | 악성 스크립트를 웹페이지에 삽입해 사용자 브라우저에서 실행 |
| OS Command Injection | 시스템 명령어를 삽입해 서버에서 임의 명령 실행 |
| Path Traversal | 파일 경로를 조작해 서버의 민감 파일에 접근 |
| Buffer Overflow | 버퍼의 허용 범위를 넘어 데이터 입력하여, 메모리 조작 & 시스템 불안정 |
| 논리적 오류 | 유효하지 않은 입력으로 애플리케이션의 비즈니스 로직 오작동 |

---

### 검증 유형 & 해결 방법

-   **데이터 타입 검증**: 입력 값이 예상되는 데이터 타입인지 확인
-   **길이 검증**: 입력 값의 최소 / 최대 길이 확인
-   **형식 검증** (정규식 사용): 데이터가 특정 형식에 맞는지 정규식을 사용하여 확인
-   **범위 검증**: 숫자 값의 경우 특정 범위 내에 있는지 확인
-   **특수 문자 필터링 / 이스케이프**: 특수 문자를 필터링 하거나 안전하게 인코딩
-   허용 목록 vs 블랙 리스트
    -   **허용 목록: 허용된 문자, 패턴, 값만 허용하고 나머지는 거부 (권장)** 
    -   블랙리스트: 알려진 악성 문자, 패턴, 값 거부

---

#### **1\. 클라이언트 측 검증 (Client-Side validation):**

사용자 경험 향상을 위해 **브라우저에서 즉시 입력 오류 피드백**

하지만 보안 목적으로는 **절대적으로 신뢰해서는 안 됨.**

Js를 비활성화 하거나 개발자 도구를 통해 쉽게 우회 가능

---

#### **2\. 서버 측 검증 (Server-Side validation):**

**필수적인 보안 조치**, 클라이언트 측에서 어떤 식으로든 입력 값이 조작될 수 있으므로, **모든 중요 검증은 서버에서 처리**

---

## 세션 탈취  (Session Hijacking)

-   세션 탈취는 공격자가 사용자의 유효한 세션 을 가로채거나 도용하여, 합법적인 사용자로 위장하여 시스템에 접근하고 행동하는 공격
-   공격자가 사용자 계정으로 로그인 하여 개인정보 열람, 비밀번호 변경, 자금 이체 등 작업 수행 가능
-   관리자 세션이 탈취될 경우 시스템 전반에 대한 통제권을 잃을 수 있음

> **📌 세션**  
> 사용자가 웹사이트에 로그인한 후 서버와 유지되는 '**세션**'은 **사용자를 식별하고 상태를 유지**하는 역할을 함  
> 이 세션 정보(주로 세션 ID)가 노출되거나 예측 가능할 때 세션 탈취가 발생할 수 있음

---

### 어디서 세션이 탈취되는가 ❓

#### **1\. 세션 고정 (Session Fixation):**

공격자가 특정 세션 ID를 사용자에게 미리 부여하고, 사용자가 그 세션 ID로 로그인하도록 유도

사용자가 로그인한 후, 공격자는 이미 알고 있는 세션 ID로 로그인하여 사용자의 세션을 가로챔

#### **2\. XSS:**

공격자가 웹 페이지에 악성 스크립트를 주입하고, 이 스크립트가 \`document.cookie\` 등을 통해 세션 쿠키(세션 ID 포함)를 읽어 공격자에게 전송

#### **3\. 네트워크 스니핑:**

암호화되지 않은 HTTP 연결을 통해 세션 ID가 전송될 때, 공격자가 네트워크 패킷을 가로채 세션 ID를 획득(MITM 공격의 일종)

#### **4\. 예측 가능한 세션ID:**

서버가 예측 가능한 패턴으로 세션 ID를 생성할 경우, 공격자가 이를 예측하여 유효한 세션 ID를 생성

#### **5\. 클라이언트 측 저장:**

\`localStorage\`나 \`sessionStorage\`에 민감한 세션 정보(예: JWT)가 저장되어 있을 경우, XSS 등으로 탈취

---

### 세션 탈취 방어 전략

-   **HTTPS 사용 강제:** 모든 통신에 HTTPS를 사용하여 세션 ID를 포함한 모든 데이터가 암호화되어 전송 (네트워크 스니핑 방지)
-   **Secure 쿠키 속성 사용:** 세션 쿠키에 Secure 속성을 설정하여 HTTPS 연결에서만 전송
-   **HttpOnly 쿠키 속성 사용:** 세션 쿠키에 HttpOnly 속성을 설정하여 JavaScript를 통한 접근을 막아 XSS로부터 세션 ID 탈취를 방지
-   **강력하고 무작위적인 세션 ID 생성:** 예측 불가능하고 충분히 긴 세션 ID를 사용하여 무차별 대입 공격이나 예측 공격 방어
-   **세션 만료 시간 설정:** 짧은 세션 만료 시간을 설정하고, 비활성 시 세션을 자동으로 종료
-   **세션 재생성 (Session Regeneration):** 로그인, 비밀번호 변경 등 **중요한 작업 후에 세션 ID를 새로 발급**하여 세션 고정 공격을 방지
-   **IP 주소 검증:** 세션 사용 중 **클라이언트의 IP 주소가 변경될 경우 세션을 재확인하거나 종료**하는 정책 고려  
    (VPN, 모바일 환경에서는 사용자 경험 저해 가능성 있음)
-   **사용자 에이전트(User-Agent) 검증:** 세션 사용 중 사용자 에이전트 정보가 변경될 경우 비정상으로 판단
-   **로그아웃 기능 구현 및 강제 종료:** 사용자가 명확하게 로그아웃할 수 있도록 하고, 필요한 경우 관리자가 특정 세션을 강제로 종료할 수 있는 기능을 제공
-   **정기적인 세션 감사:** 비정상적인 세션 활동을 탐지하기 위한 로깅 및 모니터링 시스템을 구축

---


## 보안 헤더 (Security Headers)

보안 헤더는 **웹 서버가 웹 브라우저로** 응답을 보낼 때, **HTTP 응답 헤더에 추가**하여, **브라우저의 보안 기능을 강화하고 특정 유형의 공격을 완화**하도록 지시하는 역할

주요 보안 헤더:

1.  _**Strict-Transport-Security (HSTS)**_
    -   **목적**: 브라우저가 해당 웹 사이트에 접속할 때 **HTTPS만 사용하도록 강제,**  
        중간자 공격을 통해 HTTP로 다운 그레이드 되는 것을 방지
    -   **작동 방식**: 서버가 이 헤더를 보내면, 브라우저는 지정된 \`max-age\` 기간 동안 이 도메인에 대한 모든 요청을 HTTPS 로 자동 전환
    -   **예시:** \`Strict-Transport-Security: max-age = 31536000; includeSubDomains\`
        -   _max-age_: 초 단위로 HSTS 규칙 적용 기간 (여기서는 1년)
        -   _includeSubDomains_: 하위 도메인도 HSTS 규칙 적용 여부
2.  _**Content-Security-Policy (CSP)**_
    1.  **목적:** **XSS 및 데이터 주입 공격을 방어**하는 데 매우 효과적인 헤더  
        페이지가 로드될 수 있는 리소스(스크립트, 스타일시트, 이미지, 폰트 등)의 **출처를 제한**하여, 신뢰할 수 없는 소스에서 로드되는 악성 코드를 차단
    2.  **작동 방식:** 개발자가 허용되는 리소스의 출처를 지정하면, 브라우저는 해당 정책에 따라 리소스 로드를 제어
3.  **X-Content-Type-Options**
    -   **목적:** 브라우저의 MIME 타입 스니핑 기능을 비활성화  
        공격자가 악성 스크립트를 이미지 파일로 업로드하고, 브라우저가 이를 스크립트로 오인하여 실행하는 XSS 공격 방지
    -   **작동 방식:** nosniff 값을 사용하여 브라우저에게 선언된 Content-Type 헤더를 엄격하게 따르도록 지시
    -   **예시:** _X-Content-Type-Options: nosniff_
    -   **MIME 스니핑?:**   
        서버가 보낸 Content-Type 헤더와 관계없이 브라우저가 파일 내용을 기반으로 MIME 타입을 추측하여 렌더링하는 것
4.  **X-Frame-Options**
    -   **목적:** 클릭재킹 공격 방지. 클릭재킹은 공격자가 투명한 \`<iframe>\`을 이용하여 사용자에게 실제 웹사이트 위에 가짜 UI를 덮어씌워, **사용자가 클릭하는 것처럼 보이지만 실제로는 숨겨진 <iframe>의 요소를 클릭하도록 유도**하는 공격
    -   **작동 방식:** 이 헤더를 통해 웹페이지가 <iframe>, <frame>, <object>, <embed> 등 다른 웹페이지 내부에 임베드되는 것을 허용할지 여부를 제어
    -   **예시:**
        -   X-Frame-Options: _DENY_: 어떤 프레임 내에서도 페이지 로드를 완전히 금지 (가장 강력)
        -   X-Frame-Options: _SAMEORIGIN_: 동일 출처(Same Origin)의 프레임 내에서만 페이지 로드를 허용
        -   X-Frame-Options: _ALLOW-FROM uri_: 특정 URI의 프레임 내에서만 페이지 로드를 허용 (현대 브라우저에서 잘 지원되지 않음, CSP의 frame-ancestors를 사용하는 것이 더 권장됨)
5.  **Referrer-Policy**
    -   **목적:** 사용자가 링크를 클릭하여 **다른 웹사이트로 이동**할 때 브라우저가 전송하는 Referer 헤더에 **어떤 정보를 포함할지 제어,** 이 헤더에는 이전 페이지의 URL이 포함될 수 있으며, 이는 민감한 정보 노출의 원인이 될 수 있음
    -   **작동 방식:** 다양한 정책을 통해 Referer 정보의 전송 범위를 제한합
    -   **예시:** \`Referrer-Policy: no-referrer-when-downgrade\` (HTTPS에서 HTTP로 다운그레이드될 때 Referer 전송 금지)
        -   _no-referrer_: Referer 헤더를 완전히 전송X
        -   _same-origin_: 동일 출처로의 요청에만 Referer 전송
        -   _strict-origin-when-cross-origin_: 크로스 오리진 요청 시에는 출처(Origin)만 전송, 동일 출처 요청 시에는 전체 URL 전송

---

## 쿠키 속성 (Cookie Attribute)

쿠키는 웹 애플리케이션에서 **사용자 상태를 유지**하는 데 사용되는 작은 데이터 조각

∴ 쿠키의 보안 속성을 적절히 설정하는 것은 매우 중요

### 1) HttpOnly

-   XSS 공격으로 인한 쿠키 탈취를 방지하기 위함
-   HTTP 속성이 설정된 쿠키는 클라이언트 측 JS에서 \`document.cookie\` 등을 통해 접근할 수 없음  
    **\= 오직 HTTP 요청을 통해서만 서버로 전송**
-   예시: \`Set-Cookie: sessionid = abcdef123; **HttpOnly\`**
-   JS에서 쿠키에 접근할 필요가 있는 경우 이 속성을 사용할 수 없음.. 

### 2) Secure

-   중간자 공격을 통해 쿠키가 탈취되는 것 방지
-   Secure 속성이 설정된 쿠키는 **HTTPS를 통해서만 서버로 전송**됨 (HTTP 연결에서는 전송X)
-   예시**:** \`Set-Cookie: sessionid=abcdef123; **Secure**\`
-   민감 정보 (세션ID, 인증 토큰 등)를 포함하는 쿠키는 반드시 Secure 속성 설정 必

### 3) SameSite

-   CSRF (Cross-Site Request Forgery) 공격을 방지하거나 완화
-   쿠키가 교차 사이트 요청(Cross-site requests)에 첨부되는 방식을 제어
-   SameSite 속성은 현대 웹 보안에서 CSRF 방어를 위한 핵심적인 쿠키 속성 중 하나로, **CSRF 토큰과 함께 사용될 때 더욱 강력한 방어 메커니즘을 제공**

| **값** | **LAX** | **Strict** | **None** |
| --- | --- | --- | --- |
| **설명** | 대부분의 교차 사이트 요청에는 쿠키가 전송되지 않지만,      최상위 탐색(Top-level navigation, 예: 링크 클릭, GET 폼 제출)에는 전송. | 동일 사이트 요청(Same-site requests)에만 쿠키가 전송      교차 사이트 요청에서는 어떤 경우에도 쿠키가 전송되지 않음      **보안은 가장 강력**하지만, 외부 링크를 통해 로그인된 상태로 웹사이트에 진입하는 경우 로그인 상태가 유지되지 않는 등 사용자 경험에 제약 | 교차 사이트 요청에도 쿠키가 전송      이 경우 **반드시 Secure 속성과 함께 사용되어야 합니다.** (SameSite=None without Secure는 거부.)      주로 타사 쿠키(Third-party cookies)가 필요한 경우 (예: 임베디드 위젯, 광고 추적, Single Sign-On 시스템)에 사용    |
| **예시** | Set-Cookie: sessionid=abcdef123; SameSite=Lax | ... SameSite=Strict | .. SameSite=None; Secure |

---

### JWT (JSON Web Token) 보안

-   JWT는 웹 애플리케이션에서 **정보를 안전하게 전송**하기 위한 간결하고 자체 포함적인 방법
-   주로 사용자 **인증 및 인가**(권한 부여)에 사용되며, **기존 세션 기반 인증 방식의 단점을 보완**
-   하지만 JWT 자체만으로 모든 보안이 해결되는 것은 아니며, 잘못 사용하면 여러 보안 취약점에 노출될 수 있음

| **구조** | 설명 |
| --- | --- |
| **Header** | 토큰의 타입(JWT)과 서명에 사용된 알고리즘(예: HS256, RS256)을 정의 |
| **Payload** | 클레임(Claim)이라고 불리는 **실제 정보**가 포함, 표준 클레임(iss, exp, sub 등), 공개 클레임, 비공개 클레임이 있습니다. 여기에 민감한 정보를 직접 넣는 것은 보안상 좋지 않음 |
| **Signature** | 인코딩된 헤더, 인코딩된 페이로드, 그리고 비밀 키(Secret Key) 또는 비공개 키(Private Key)를 사용하여 생성됨.   이 서명은 **토큰의 무결성(변조 여부)을 검증**하는 데 사용 |

---

### JWT 보안의 주요 고려사항 및 취약점

JWT의 강력한 기능에도 불구하고, 다음과 같은 보안 문제와 고려 사항이 존재

#### **1) 토큰 탈취 (Token Theft):**

**가장 큰 위협으로,** JWT는 일단 발급되면 유효 기간(exp)이 만료되기 전까지는 유효함.

만약 공격자가 사용자 토큰을 탈취하면, 해당 토큰이 만료될 때까지 사용자를 가장하여 모든 작업 수행 가능

-   **주요 탈취 경로:**
    -   XSS (Cross-Site Scripting)
    -   Man-in-the-Middle (MITM) Attack
    -   취약한 저장소
-   **방어 전략:**
    -   **HttpOnly 쿠키 사용**
    -   **Secure 쿠키 사용**
    -   **토큰 만료 시간 짧게 설정:** 토큰 탈취 시 피해를 최소화하기 위해 액세스 토큰의 유효 시간을 짧게 설정
    -   **_리프레시 토큰(Refresh Token) 사용_:** 짧은 만료 시간의 액세스 토큰과 긴 만료 시간의 리프레시 토큰 사용  
        리프레시 토큰은 HttpOnly 쿠키에 저장하고, 새로운 액세스 토큰 발급에만 사용하며, 사용 시마다 재사용 여부를 검증하고 새로 발급하는 등의 엄격한 관리 必
    -   **IP 주소 검증:** 토큰 사용 시 클라이언트의 IP 주소를 함께 검증하여, 토큰이 다른 IP 주소에서 사용될 경우 거부

#### **2) 서명 없음 (alg: none) 취약점:**

JWT 헤더의 alg 필드를 none으로 설정하면, 토큰의 서명 검증을 생략

공격자는 이 점을 악용하여 \`alg: none\`으로 설정된 JWT를 생성하고, **페이로드에 원하는 정보를 넣어** 서버에 보내면, 서버는 서명을 검증하지 않고 유효한 토큰으로 간주

-   서버 측에서 alg: none을 명시적으로 거부하거나, 허용된 서명 알고리즘 목록(화이트리스트)만을 허용하도록 설정
-   대부분의 JWT 라이브러리에서는 기본적으로 none 알고리즘을 지원하지 않거나 명시적인 설정 必

#### **3) 알고리즘 교체 공격 (Algorithm Confusion Attack):**

서버가 비대칭 키(RSA)를 사용해야 할 JWT를 대칭 키(HMAC) 서명으로 받아들이는 취약점

공격자는 RSA 공개 키를 사용하여 HMAC 서명을 만들고, 이를 서버에 보내면 서버는 공개 키를 비밀 키로 오인하여 유효한 토큰으로 간주

-   JWT 라이브러리를 통해 **수신된 토큰의 alg 헤더와 실제 서명 검증에 사용되는 키/알고리즘 조합이 일치하는지 항상 확인**
-   즉, RSA 서명을 기대한다면 HMAC 서명은 무조건 거부

#### **4) 페이로드에 민감한 정보 포함:**

**JWT의 페이로드**는 Base64Url로 인코딩될 뿐, **암호화되지 않음.**  
∴ 누구나 쉽게 디코딩하여 페이로드의 내용을 볼 수 있으므로  여기에 비밀번호, 개인 식별 정보(PII) 등 민감한 정보는X

만약 페이로드에 민감한 정보를 반드시 포함해야 한다면, **JWE (JSON Web Encryption)**와 같은 암호화 방식을 함께 고려

#### **5) 키 관리 및 재사용:**

JWT 서명에 사용되는 비밀 키(Secret Key) 또는 비공개 키(Private Key)가 노출되면, 공격자는 유효한 JWT를 무제한으로 생성 간능 또한, 너무 짧거나 예측 가능한 키를 사용하는 것도 위험

-   **강력하고 무작위적인 키를 사용**
-   **키는 안전하게 보관**하고, 코드나 버전 관리 시스템에 직접 **하드코딩X**. (환경 변수, 키 관리 시스템(KMS) 활용)
-   정기적인 키 로테이션(Key Rotation) 수행
-   각기 다른 목적(액세스 토큰 서명, 리프레시 토큰 서명 등)에 **별도의 키를 사용**하는 것을 고려

#### **6) 토큰 무효화 (Token Invalidation):**

JWT는 자체 포함적이므로, 한 번 발급되면 서버 측에서 개별 토큰을 즉시 무효화하기 어려움.  
만료 시간이 짧더라도, 만료 전까지는 유효

-   **짧은 만료 시간의 액세스 토큰 사용:** 토큰 탈취 시 공격자가 사용할 수 있는 시간을 최소화
-   **블랙리스트 (Blacklist) / Revocation List:**
    -   무효화해야 할 토큰을 서버 측 캐시(Redis 등)에 저장하고, 요청이 들어올 때마다 해당 토큰이 블랙리스트에 있는지 확인하여 무효화된 토큰의 사용을 거부
    -   대량의 토큰을 관리 시 확장성 문제가 발생 가능
-   **세션 ID 저장 (세미-스테이트풀 방식):**
    -   JWT 페이로드에 고유한 세션 ID를 포함시키고, 서버에서 이 ID를 통해 해당 세션의 유효성을 관리
    -   세션 ID를 블랙리스트에 추가하거나 데이터베이스에서 삭제하는 방식으로 특정 세션의 토큰을 무효화
-   **로그아웃 시 클라이언트 토큰 삭제:** 클라이언트(브라우저)에서 localStorage나 쿠키에 저장된 토큰을 즉시 삭제

#### **7) 재전송 공격 (Replay Attack):**

만료되지 않은 JWT는 공격자가 이를 가로채서 다시 서버에 전송(재전송)하여 동일한 작업을 반복

-   **요청 타임스탬프 (Timestamp) 및 Nonce 사용:** 페이로드에 요청 시 타임스탬프와 일회용 난수(Nonce)를 포함시키고, 서버에서 이를 검증하여 중복 요청 방지. (하지만 JWT를 매번 변경해야 하므로 복잡해질 수 있음)
-   **짧은 만료 시간:** 재전송 공격의 유효 시간을 줄임

---

### **안전한 JWT 구현을 위한 권장 사항**

1.  **JWT는 HttpOnly 및 Secure 속성이 설정된 쿠키에 저장**하여 XSS 및 MITM 공격으로부터 보호 (일반적으로 액세스 토큰보다는 리프레시 토큰을 HttpOnly 쿠키에 저장)
2.  **액세스 토큰의 만료 시간을 짧게** 설정하고, **리프레시 토큰을 함께 사용**하여 사용자 경험과 보안의 균형을 맞춤
3.  **SameSite 쿠키 속성**을 활용하여 CSRF 공격을 완화
4.  **JWT 페이로드에는 민감한 정보를 포함X** (ID, 권한 등 최소한의 정보만)
5.  **alg: none 알고리즘 사용을 절대적으로 금지**하고, **알고리즘 교체 공격에 대비하여 서명 알고리즘을 엄격하게 검증**
6.  **강력하고 안전하게 관리되는 비밀 키/비공개 키를 사용**하며, 정기적으로 로테이션합
7.  **로그아웃, 비밀번호 변경 시 토큰을 무효화**할 수 있는 메커니즘(예: 블랙리스트, 세션 ID 관리)을 구현
8.  모든 통신은 **HTTPS**를 통해 이루어지도록 강제

---

## 2FA (Two-Factor Authentication)

-   2FA 또는 이중 인증은 사용자가 계정에 접근하기 위해 두 가지 서로 다른 유형의 인증 요소를 제공하도록 요구하는 보안 메커니즘
-   단일 인증 요소(예: 비밀번호)보다 훨씬 강력한 보안을 제공하여, 비밀번호가 유출되더라도 계정이 즉시 탈취되는 것을 방지
-   **인증 요소의 세 가지 유형:** 2FA는 다음 세 가지 유형 중 서로 다른 두 가지를 조합
    -   **_사용자가 아는 것_ (Something you know):** 비밀번호, PIN, 보안 질문 답변
    -   **_사용자가 가진 것_ (Something you have):** 스마트폰, OTP 생성기, 물리적 보안 키(USB 토큰), 스마트 카드
    -   **_사용자가 누구인지_ (Something you are):** 지문, 얼굴 인식, 홍채 스캔 등 생체 인식 정보

#### **작동 방식 (예시):** 가장 흔한 2FA 조합은 "비밀번호 (아는 것)" + "스마트폰/OTP (가진 것)" 

1.  사용자가 웹사이트에 로그인하기 위해 아이디와 비밀번호를 입력합니다. (첫 번째 요소)
2.  웹사이트는 사용자에게 두 번째 인증 요소를 요청합니다. (예: 등록된 스마트폰으로 전송된 일회성 코드(OTP), OTP 앱에서 생성된 코드, 물리적 보안 키를 통한 인증)
3.  사용자가 두 번째 인증 코드를 정확히 입력해야만 로그인이 완료됩니다.

---

## 장점 / 단점

| **장점** | 설명 |
| --- | --- |
| **보안 강화** | 비밀번호가 유출되더라도 공격자가 두 번째 인증 요소를 가지고 있지 않으면 계정에 접근할 수 없어 무단 접근을 효과적으로 차단 |
| **피싱 및 크리덴셜 스터핑 공격 방어** | 비밀번호만 탈취하는 피싱 공격이나, 다른 사이트에서 유출된 비밀번호를 재사용하여 공격하는 크리덴셜 스터핑 공격에 대한 강력한 방어책이 됨 |

| **단점** | 설명 |
| --- | --- |
| **사용자 편의 성 저해** | 추가적인 단계가 필요하므로 사용자 경험이 약간 저해될 수 있음 |
| **복구 메커니즘** | 두 번째 인증 요소를 분실하거나 손상했을 때 계정을 복구할 수 있는 안전한 방법을 제공해야 함   (예: 복구 코드, 백업 인증 방법) |
| **SIM 스와핑 공격** | SMS 기반 OTP는 공격자가 사용자의 전화번호 SIM을 탈취(스와핑)하여 OTP를 가로챌 수 있는 위험 |
| **보안 키 분실** | 물리적 보안 키를 분실할 경우 계정 접근이 어려울 수 있음 |

---

### 2FA의 종류 및 구현 예시:

-   **SMS 기반 OTP:** 등록된 휴대폰 번호로 일회성 인증 코드를 전송 (편리하지만 SIM 스와핑 공격에 취약할 수 있음)
-   **Authenticator 앱 (TOTP):** Google Authenticator, Microsoft Authenticator 등 앱에서 시간 기반 일회용 비밀번호(TOTP)를 생성 (오프라인에서도 작동, SIM 스와핑 공격 방어)
-   **물리적 보안 키 (FIDO U2F/WebAuthn):** YubiKey와 같은 USB 형태의 물리적 장치를 사용하여 인증 (**가장 강력한 보안**, 피싱 방어에 매우 효과적)
-   **푸시 알림 기반 승인:** 등록된 스마트폰 앱으로 로그인 시도를 알리고, 사용자가 앱에서 \`"승인"\` 버튼을 눌러 인증
-   **생체 인식 (Biometrics):** 지문, 얼굴 인식 등을 사용(모바일 기기에서 주로 사용)

#### **권장 사항:**

-   SMS OTP보다는 \`Authenticator 앱\`이나 \`물리적 보안 키\` 사용을 권장
-   사용자에게 2FA 사용을 적극적으로 권장하고, 가능한 경우 강제하는 정책을 고려
-   안전한 복구 옵션을 제공하되, 남용되지 않도록 관리


