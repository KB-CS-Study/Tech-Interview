
### 웹 보안

- OWASP Top 10
    - OWASP(Open Worldwide Application Security Project) : 조직이 신뢰할 수 있는 안전한 애플리케이션을 위한 소프트웨어를 설계, 개발, 획득, 운영 및 유지 관리할 수 있도록 하는 데 전념하는 개방형 커뮤니티
    - 중요한 이유
        - 웹 애플리케이션 보안 위험에 대한 인식을 높이는 데 중요한 역할
        - 웹 애플리케이션 보안의 증가하는 과제를 해결하기 위한 귀중한 리소스, 도구, 문서 및 모범 사례를 제공

  | 순위 | OWASP 2017 | OWASP 2021 |
      | --- | --- | --- |
  | A1 | 인젝션 (Injection) | 취약한 접근 통제 (Broken Access Control) |
  | A2 | 취약한 인증 (Broken Authentication) | 암호화 오류 (Cryptographic Failures) |
  | A3 | 민감 데이터 노출 (Sensitive Data Exposure) | 인젝션 (Injection) |
  | A4 | XML 외부 개체 (XXE) | 안전하지 않은 설계 (Insecure Design) |
  | A5 | 취약한 접근 통제 | 잘못된 보안 구성 (Security Misconfiguration) |
  | A6 | 잘못된 보안 구성 | 취약하고 오래된 구성요소 (Vulnerable and Outdated Components) |
  | A7 | 크로스 사이트 스크립팅 (XSS) | 취약한 인증 (Identification and Authentication Failures) |
  | A8 | 위험한 역직렬화 (Insecure Deserialization) | 소프트웨어 및 데이터 무결성 오류 (Software and Data Integrity Failures) |
  | A9 | 알려진 취약점을 사용하는 구성요소 | 보안 로깅 및 모니터링 실패 (Security Logging and Monitoring Failures) |
  | A10 | 충분하지 않은 로깅 및 모니터링 | 서버측 요청 위조 (Server-Side Request Forgery, SSRF) |
- SQL Injection
    - SQL Injection이란

      > 해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법
      >
        - 웹 사이트의 보안상 허점을 이용해 특정 SQL 쿼리 문을 전송하여 공격자가 원하는 데이터베이스의 중요한 정보를 가져오는 해킹 기법.
        - 클라이언트가 입력한 데이터를 제대로 필터링 하지 못하는 경우 발생.
        - 공격 난이도가 쉬운데 비해 피해 규모가 큼.


    **SQL Injection의 진행의 예**
    
    - 각 클라이언트가 자격증 번호를 조회할 수 있는 시스템.
    - SQL 진행은 anjinma 클라이언트가 '자격증 번호 조회'를 클릭하여 anjinma 라는 이름이 웹서버에 전송되고 DB에 입력한 값과 일치하면 자격증 DB를 출력해준다.
    - blackhat 클라이언트는 anjinma 클라이언트의 자격증 번호를 조회하기 위해서 SQL문을 수정하지만 권한이 없어서 자격증 정보를 가져올 수 없다.
    - ex) http://license12345.com/mysearch?=anjinma url을 전송할때 anjinma가 로그인 되어있으면 정상적으로 자격증 번호를 조회할 수 있지만 blackhat이 로그인 되어있으면 자격증 번호를 조회할 수 없다.
    - 공격자인 blackhat은 url뒤에 ' or '1'='1'을 넣어줘서 항상 참이 되게 만들어서 자격증 번호를 조회해 온다.
    
    **공격 방법**
    
    **1) 인증 우회**
    
    보통 로그인을 할 때, 아이디와 비밀번호를 input 창에 입력하게 된다. 쉽게 이해하기 위해 가벼운 예를 들어보자. 아이디가 abc, 비밀번호가 만약 1234일 때 쿼리는 아래와 같은 방식으로 전송될 것이다.
    
    ```
    SELECT * FROM USER WHERE ID = "abc" AND PASSWORD = "1234";
    
    ```
    
    SQL Injection으로 공격할 때, input 창에 비밀번호를 입력함과 동시에 다른 쿼리문을 함께 입력하는 것이다.
    
    ```
    1234; DELETE * USER FROM ID = "1";
    
    ```
    
    보안이 완벽하지 않은 경우, 이처럼 비밀번호가 아이디와 일치해서 True가 되고 뒤에 작성한 DELETE 문도 데이터베이스에 영향을 줄 수도 있게 되는 치명적인 상황이다.
    
    이 밖에도 기본 쿼리문의 WHERE 절에 OR문을 추가하여 `'1' = '1'`과 같은 true문을 작성하여 무조건 적용되도록 수정한 뒤 DB를 마음대로 조작할 수도 있다.
    
    **2) 데이터 노출**
    
    시스템에서 발생하는 에러 메시지를 이용해 공격하는 방법이다. 보통 에러는 개발자가 버그를 수정하는 면에서 도움을 받을 수 있는 존재다. 해커들은 이를 역이용해 악의적인 구문을 삽입하여 에러를 유발시킨다.
    
    즉 예를 들면, 해커는 **GET 방식으로 동작하는 URL 쿼리 스트링을 추가하여 에러를 발생**시킨다. 이에 해당하는 오류가 발생하면, 이를 통해 해당 웹앱의 데이터베이스 구조를 유추할 수 있고 해킹에 활용한다.
    
    **방어 방법**
    
    **1) input 값을 받을 때, 특수문자 여부 검사하기**
    
    > 로그인 전, 검증 로직을 추가하여 미리 설정한 특수문자들이 들어왔을 때 요청을 막아낸다.
    > 
    
    **2) SQL 서버 오류 발생 시, 해당하는 에러 메시지 감추기**
    
    > view를 활용하여 원본 데이터베이스 테이블에는 접근 권한을 높인다. 일반 사용자는 view로만 접근하여 에러를 볼 수 없도록 만든다.
    > 
    
    **3) preparestatement 사용하기**
    
    > preparestatement를 사용하면, 특수문자를 자동으로 escaping 해준다. (statement와는 다르게 쿼리문에서 전달인자 값을 ?로 받는 것) 이를 활용해 서버 측에서 필터링 과정을 통해서 공격을 방어한다.
    > 
- XSS(Cross Site Scripting 공격)
    - 사용자 브라우저에 전달되는 데이터에 악성 스크립트를 포함시킨 뒤, 사용자 브라우저에 실행되면서 해킹하는 공격
    - SQL Injection과 함께 ㅟ약점 중 가장 기초적인 취약점으로 알려져 있으며 공격 패턴이 다양하고 변화도 다양하게 이루어지기 때문에 파급효과가 무궁ㄱ무진하다
    - 공격 유형
        1. Reflected XSS
            - 공격자가 만든 **악성 URL을 사용자가 클릭**했을 때, 서버가 이 입력값을 그대로 응답에 반영해 브라우저에서 실행되는 방식
            - **일시적으로 발생**하고, 사용자 조작이 필요함

            ```jsx
            https://example.com/search?q=<script>alert(1)</script>
            ```

           → 서버가 이 값을 그대로 HTML에 반영하면, 브라우저에서 <script>alert(1)</script> 실행

        2. Stored XSS
            - 악성 스크립트를 **DB나 로그, 게시판 등에 저장**해두고, 이후 페이지를 본 모든 사용자 브라우저에서 실행됨
            - **지속적이며, 다수 피해자 발생 가능**
            - 예: 게시판에 글을 쓰면서 <script>stealCookies()</script> 삽입
        3. DOM based XSS
            - **서버가 아닌 브라우저에서 자바스크립트로 DOM 조작 중에 발생**하는 XSS
            - 클라이언트 사이드에서 자바스크립트가 location.href, innerHTML 같은 속성으로 악성 값을 처리할 때 발생

            ```jsx
            // 예: URL 파라미터를 그대로 innerHTML에 삽입
            document.getElementById("msg").innerHTML = location.search;
            ```

    - 방어 방법


        | **방법** | **설명** |
        | --- | --- |
        | 🔒 입력값 필터링 | <, >, ', " 등 특수 문자 제거 또는 치환 (escape) |
        | ✅ 출력 시 인코딩 | HTML 출력 시 &lt;, &gt;, &quot; 등으로 변경 |
        | 🧼 Content Security Policy (CSP) | inline script 차단, 외부 스크립트만 허용 등 |
        | ⛔️ innerHTML 지양 | 가능하면 textContent, setAttribute 사용 |
        | 🛡 프레임워크 보안 기능 사용 | React, Vue는 기본적으로 XSS를 막는 방식으로 렌더링 |
- CSRF(Cross Site Request Forgery), 사용자 간 요청 위조
    - 특징
        - 웹 보안 취약점의 일종
        - 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(데이터 수정, 삭제, 등록 등)을 특정 웹사이트에 요청하게 하는 공격
    - 동작 원리
        - 사용자는 보안이 취약한 서버로부터 이미 로그인되어있는 상태여야한다
        - 쿠키 기반의 서버 세션 정보를 획득할 수 있어야 한다
        - 공격자는 서버를 공격하기 위한 요청 방법에ㅐ 대해 미리 파악하고 있어야한다
    - 공격 방식
        - 사용자는 보안이 취약한 서버에 로그인합니다.
        - 서버에 저장된 세션 정보를 사용할 수 있는 session ID가 사용자의 브라우저 쿠키에 저장됩니다.
        - 공격자는 사용자가 악성 스크립트 페이지를 누르도록 유도합니다.
        - 악성 스크립트 페이지를 누르도록 유도하는 방식은 아래와 같은 방식들이 있습니다.
            - 게시판이 있는 웹사이트에 악성 스크립트를 게시글로 작성하여 사용자들이 게시글을 클릭하도록 유도
            - 메일 등으로 악성 스크립트를 직접 전달하거나, 악성 스크립트가 적힌 페이지 링크를 전달
        - 사용자가 악성 스크립트가 작성된 페이지 접근시 웹 브라우저에 의해 쿠키에 저장된 session ID와 함께 서버로 요청됩니다.
        - 서버는 쿠키에 담긴 session ID를 통해 해당 요청이 인증된 사용자로부터 온 것으로 판단하고 처리합니다.
- 인풋 검증(Input validity)
    - **외부에서 입력되는 값이 예상된 형식, 길이, 타입, 범위 등을 만족하는지 확인하는 것**
    - 사용자 또는 외부 시스템이 보낸 데이터가 **“정상적이고 안전한 값인지”** 판단하는 절차


        | 항목 | 설명 | 예시 |
        | --- | --- | --- |
        | 형식 (Format)
         | 이메일, 전화번호, 주민번호 등 정규식으로 검사 | /^\d{3}-\d{4}-\d{4}$/
         |
        | 범위 (Range) | 나이, 금액 등 숫자가 특정 범위를 벗어나는지 확인 | 0 ≤ 나이 ≤ 120
         |
        | 길이 (Length) | 비밀번호 최소 8자 이상 등 | password.length >= 8
         |
        | 타입 (Type) | 문자열인지, 숫자인지 등 검사 | typeof input === "number"
         |
        | 금지 문자 (Blacklist) | <, >, ', " 등 금지된 특수문자 제거 | "<script>" → "&lt;script&gt;" |
        | 화이트리스트 (Whitelist) | 허용된 값만 통과시키기 | "admin", "user"만 허용"
         |
    - 검증 위치
        - 클라이언트 측 (프론트) : 사용자 경험 향상, 빠른 피드백 제공 → **하지만 신뢰 불가**
        - 서버 측 (백엔드) : 반드시 필요함, 외부 공격 방어의 최후 방어선
    - 검증하지 않으면 생기는 문제
        
        
        | **공격/문제** | **설명** |
        | --- | --- |
        | ❌ SQL Injection | id=1' OR '1'='1 같은 악성 입력 |
        | ❌ XSS | <script>alert(1)</script> |
        | ❌ 인증 우회 | 로그인 시 ID=admin 같은 의도치 않은 입력 |
        | ❌ 서버 다운 | 너무 긴 문자열, Null 값 등으로 오류 발생 |
- HTTP 보안 헤더
    - 필요성
        - HTTP가 기본적으로 암호화되지 않은 텍스트 형태로 데이터를 전송한다는 점에서 보안 취약점 → 도청, 변조, 중간자 공격과 같은 사이버 공격에 노출
    - 특징
        - 웹에서 동시에 작동함으로써 웹 애플리케이션을 다양한 공격으로부터 보호하는 포괄적인 보안 체계를 구축
        - 보안 헤더는 HTTP 응답에 추가적인 요청사항을 포함시켜서 브라우저가 데이터를 안전하게 처리하도록 유도
            - 요청 사항 : 데이터의 무결성 보장, 사용자의 개인 정보를 보호, 악의적인 사용자
    - 종류


        | **보안 헤더** | **역할** | **주요 설정** | **요약** |
        | --- | --- | --- | --- |
        | **1. Content-Security-Policy (CSP)** | XSS 방지 | default-src, script-src 등 출처 제한 | **스크립트·리소스의 출처를 제한해 악성 코드 실행 방지** |
        | **2. HTTP Strict-Transport-Security (HSTS)** | HTTPS 강제 | max-age=31536000; includeSubDomains; preload | **HTTPS로만 접속 강제해 중간자 공격(MITM) 차단** |
        | **3. X-Content-Type-Options** | MIME 스니핑 방지 | nosniff | **브라우저가 파일 타입을 임의로 해석하지 못하게 방지** |
        | **4. X-Frame-Options** | 클릭재킹 방지 | DENY, SAMEORIGIN | **다른 사이트가 iframe으로 내 사이트를 끼워넣지 못하게 막음** |
        | **5. X-XSS-Protection** | (과거용) 브라우저 XSS 필터 | 0 (비권장) | **지원 중단됨. 최신 브라우저에서는 사용 X** |
- 쿠키 속성 (HttpOnly, Secure, SameSite)


    | **속성** | **설명** | **방어 효과** |
    | --- | --- | --- |
    | **HttpOnly** | JavaScript로 쿠키 접근 불가. 서버 응답 시 Set-Cookie: sessionId=abc; HttpOnly | XSS로 쿠키 탈취 방지 |
    | **Secure** | HTTPS 환경에서만 쿠키 전송 | 네트워크 중간자(MITM) 공격 방지 |
    | **SameSite** | 타 도메인 요청 시 쿠키 전송 제한 | CSRF 방지에 효과적 |
    | Strict | 다른 사이트에서 요청 시 쿠키 **절대 전송 안 함** | 보안 최우선 |
    | Lax | GET 방식 등 일부 안전한 요청엔 전송 | 기본값 (적절한 보안성) |
    | None | **모든 요청에 쿠키 전송**, 단 Secure 필수 | 외부 요청 허용 시 사용 (주의 필요) |

### 시스템 및 실무 보안

- 권한 상승
    - 시스템/웹 애플리케이션의 취약점을 이용해 일반 사용자가 관리자 권한을 얻는 공격
    - 예시: 잘못된 파일 접근 제어로 루트 파일에 접근, SUID 설정된 파일 오용 등
    - 대응: 최소 권한 원칙 적용, 관리자 리소스 접근 제어
- 파일 권한
    - 리눅스/유닉스 기반 시스템에서 읽기(r), 쓰기(w), 실행(x) 권한을 사용자/그룹/기타에 맞게 설정
    - chmod, chown, umask 명령어로 설정
    - 보안 권장:
        - 중요 설정 파일: 600 (읽기/쓰기만 소유자에게)
        - 실행 파일: 필요 시에만 x 권한 부여
        - 웹 업로드 폴더: 실행 권한 제한 (파일 업로드 취약점 대응)
- JWT 보안


    | **항목** | **설명** |
    | --- | --- |
    | 구조 | Header.Payload.Signature |
    | 장점 | 서버 무상태 인증, 확장성 좋음 |
    | 보안 이슈 | - 탈취 시 인증 우회 가능 - Signature 알고리즘 none으로 설정 시 무력화 가능 |
    | 대응 방법 | - HTTPS 적용 - 서명에 강력한 secretKey 사용 (HS256/RS256) - 짧은 만료 시간 설정 - JWT 저장 위치는 XSS에 취약한 localStorage 대신 HttpOnly 쿠키 권장 |
- 세션 탈취
    - 사용자의 세션 ID를 탈취해 인증된 사용자로 가장하는 공격
    - 주요 방식: XSS, 네트워크 스니핑, 악성 코드
    - 방어 방법:
        - 세션 ID 재사용 방지 (로그인/권한 변경 시 세션 재생성)
        - HttpOnly, Secure, SameSite 쿠키 속성 활용
        - 세션 타임아웃 설정
- 2FA
    - 인증 시 2가지 이상의 인증 요소를 요구
    - 인증 요소 유형:
        - 지식 기반: 비밀번호, PIN
        - 소지 기반: OTP 토큰, 문자 인증
        - 생체 정보: 지문, 얼굴
    - 효과: 비밀번호 탈취만으로는 로그인 불가능하게 하여 보안 강화
- 보안 면접 질문 대응


    | **질문** | **답변 요령** |
    | --- | --- |
    | XSS 방어 어떻게 하나요? | 입력값 필터링, 출력 시 HTML 인코딩, CSP 정책 적용 |
    | CSRF 방지 방법은? | SameSite 쿠키, CSRF 토큰 적용, Referer 검사 |
    | HTTPS만 쓰면 안전한가요? | 전송 구간만 안전. 서버 측 취약점, XSS/CSRF는 별도 방어 필요 |
    | 로그인 보안에 필요한 요소는? | 비밀번호 해싱 저장(Bcrypt 등), 로그인 시도 횟수 제한, 2FA |
- 보안 설계 시 고려사항 정리


    | **항목** | **내용** |
    | --- | --- |
    | 최소 권한 원칙 | 사용자, 서비스가 필요한 최소 권한만 부여 |
    | 민감 정보 암호화 | 개인정보, 결제정보는 AES 등으로 암호화 |
    | 로깅과 모니터링 | 이상 행동 실시간 탐지, 보안 사고 대응 |
    | 의심 요청 필터링 | WAF, 보안 필터를 통해 비정상적인 요청 차단 |
    | 외부 라이브러리 검증 | 의존성 취약점 확인 (Snyk, OWASP Dependency-Check 등) |