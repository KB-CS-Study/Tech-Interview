## **✅ 웹 보안**

### **OWASP Top 10**

OWASP(Open Web Application Security Project)에서 주기적으로 발표하는 웹 보안 위협 10가지 목록

### A01 : Broken Access Control (접근 권한 취약점)

웹 애플리케이션이 액세스 제어를 적절하게 시행하지 않아 승인되지 않은 사용자가 애플리케이션의 민감한 영역에 액세스할 수 있도록 허용할 때 발생

- 엑세스 제어는 사용자가 권한을 벗어나 행동할 수 없도록 정책을 시행
- 만약 엑세스 제어가 취약하면 사용자는 주어진 권한을 벗어나 모든 데이터를 무단으로 열람, 수정 혹은 삭제 등의 행위로 이어질 수 있음

이 취약점을 방지하려면 역할 기반 액세스 제어 사용과 같은 강력한 액세스 제어 조치를 구현하고 무단 액세스를 차단하도록 웹 서버를 적절하게 구성해야 함

### A02 : Cryptographic Failures (암호화 오류)

웹 애플리케이션이 취약한 알고리즘을 사용하거나 키를 적절하게 보호하지 못하는 등 암호화를 제대로 사용하지 않을 때 발생함

적절한 암호화가 이루어지지 않으면 민감 데이터가 노출될 수 있음

암호화 실패를 방지하려면 강력한 암호화 알고리즘을 사용하고 키를 적절하게 관리하고 보호해야 함

### A03: Injection (인젝션)

공격자가 취약한 웹 애플리케이션에 임의의 코드를 주입하여 실행할 수 있을 때 발생

SQL, NoSQL, OS 명령, ORM(Object Relational Mapping), LDAP, EL(Expression Language) 또는 OGNL(Object Graph Navigation Library) 인젝션 취약점은 신뢰할 수 없는 데이터가 명령어나 쿼리문의 일부분으로써 인터프리터로 보내질 때 취약점이 발생

인젝션 공격을 방지하려면 매개변수화된 쿼리를 사용하고 모든 사용자 입력을 삭제하고 허용 가능한 입력 값의 화이트리스트를 사용해야 함

### A04: Insecure Design (안전하지 않은 설계)

공격에 취약하게 만드는 웹 응용 프로그램의 전반적인 설계의 약점을 나타냄

Insecure Design(안전하지 않은 설계)는 누락되거나 비효율적인 제어 설계로 표현되는 다양한 취약점을 나타내는 카테고리

안전하지 않은 설계와 안전하지 않은 구현에는 차이가 있지만, 안전하지 않은 설계에서 취약점으로 이어지는 구현 결함이 있을 수 있음

안전하지 않은 설계를 방지하려면 보안 설계 원칙을 따르고 배포 전에 애플리케이션의 취약성을 철저히 테스트해야 함

### A05: Security Misconfiguration (보안설정오류)

웹 애플리케이션이 제대로 구성되지 않아 공격에 노출될 수 있을 때 발생

애플리케이션 스택의 적절한 보안 강화가 누락되었거나 클라우드 서비스에 대한 권한이 적절하지 않게 구성되었을 때, 불필요한 기능이 활성화 되거나 설치되었을 때, 기본계정 및 암호화가 변경되지 않았을 때, 지나치게 상세한 오류 메세지를 노출할 때, 최신 보안기능이 비활성화 되거나 안전하지 않게 구성되었을 때 발생

잘못된 보안 구성을 방지하려면 보안 구성 모범 사례를 따르고 시스템을 정기적으로 업데이트 및 패치하고 애플리케이션의 민감한 영역에 대한 액세스를 제한해야 함

### A06: Vulnerable and Outdated Components (취약하고 오래된 요소)

취약하고 오래된 요소는 지원이 종료되었거나 오래된 버전을 사용할 때 발생합니다. 이는 애플리케이션 뿐만 아니라, DBMS, API 및 모든 구성요소 들이 포함됩니다. 이는 웹 애플리케이션이 공격자가 악용할 수 있는 알려진 취약성이 있는 타사 구성 요소를 사용할 때 발생

이러한 유형의 취약성을 방지하려면 애플리케이션에서 알려진 취약성을 정기적으로 검사하고 취약한 구성 요소를 업데이트하거나 교체해야 함

### A07: Identification and Authentication Failures (식별 및 인증 오류)

이것은 웹 애플리케이션이 인증 및 세션 관리를 처리하는 방식의 약점을 나타냅니다.

사용자의 신원확인, 인증 및 세션관리가 적절히 되지 않을 때 취약점이 발생할 수 있음

이러한 유형의 공격을 방지하려면 강력한 암호를 사용하고 보안 쿠키 사용 및 세션 토큰 회전과 같은 적절한 세션 관리 제어를 구현해야 함

### A08: Software and Data Integrity Failures(소프트웨어 및 데이터 무결성 오류)

웹 애플리케이션이 암호나 신용 카드 번호와 같은 민감한 데이터를 제대로 보호하지 않을 때 발생

무결성을 확인하지 않고 소프트웨어 업데이트, 중요 데이터 및 CI/CD 파이프라인과 관련된 가정을 하는데 중점을 둠

민감한 데이터 노출을 방지하려면 전송 중이거나 저장된 모든 민감한 데이터를 암호화하고 HTTPS와 같은 보안 프로토콜을 사용해야 함

### A09: Security Logging and Monitoring Failures (보안 로깅 및 모니터링 실패)

웹 애플리케이션이 보안 이벤트를 적절하게 로깅 및 모니터링하지 않을 때 발생

로깅 및 모니터링 없이는 공격활동을 인지할 수 없습니다. 이 카테고리는 진행중인 공격을 감지 및 대응하는데 도움이 됨

이 취약성을 방지하려면 강력한 로깅 및 모니터링 시스템을 구현하고 정기적으로 로그 파일을 검토하여 공격 또는 기타 보안 문제의 증거를 찾아야 함

### A10: Server-Side Request Forgery (서버 측 요청 위조)

이는 공격자가 웹 애플리케이션을 속여 다른 시스템에 의도하지 않은 요청을 하도록 하여 잠재적으로 중요한 정보를 노출할 때 발생

SSRF 결함은 웹 애플리케이션이 사용자가 제공한 URL의 유효성을 검사하지 않고 원격 리소스를 가져올 때마다 발생합니다. 이를 통해 공격자는 방화벽, VPN 또는 다른 유형의 네트워크 ACL(액세스 제어 목록)에 의해 보호되는 경우에도 응용 프로그램이 조작된 요청을 예기치 않은 대상으로 보내도록 강제할 수 있음

SSRF 공격을 방지하려면 모든 사용자 제어 입력의 유효성을 검사하고 애플리케이션이 만들 수 있는 요청 유형을 제한해야 함

### **SQL Injection**

- 공격자가 입력값에 SQL 문법을 주입하여 의도하지 않은 쿼리를 실행하게 함

```
SELECT * FROM users WHERE id = '1' OR '1'='1';
```

- 비밀번호는 'anything'이 아니므로, password=anything의 결과도 거짓(FALSE)이지만, '1'='1'은 참(TRUE) 문이므로 TRUE 값을 반환
- OR 연산자로 인해, 값(FALSE 또는 TRUE)이 TRUE이므로, 인증 우회에 성공

- **대응**: PreparedStatement, ORM, 입력 검증 등

```sql
$id = $_GET['id']

(1) $id = Stripslashes($id)

(2) $id = mysql_real_escape_String($id)
```

(1)로 인해 입력 문자열의 각 작은 따옴표(')가 큰따옴표(")로 바뀌고, (2)로 인해 모든 작은 따옴표(') 앞에 (/)가 추가됩니다. 수정된 Magical String은 인증을 우회하지 못하며, 데이터베이스는 안전하게 유지

### **XSS (Cross-Site Scripting)**

`XSS`란 `Cross Site Script`의 약자로 웹사이트에 악성코드를 주입하는 행동을 말하며, 공격자가 웹사이트를 넘어서 공격한다는 뜻에서 유래

- 스크립트가 삽입되어 클라이언트에서 실행됨 (ex. <script>alert(1)</script>)
- **Stored**: DB에 저장 후 출력됨
    - 다른 HTML 문서를 보여주는 웹사이트나 게시판과 같이 공격자가 직접적으로 DOM을 작성할 수 있는 환경에서 주로 일어남
- **Reflected**: URL 등에 포함되어 반사되어 실행됨
    - 공격자의 입력 값이 HTTP 응답에 그대로 포함되어 공격자에게 다시 반사(Reflected)되어 보인도록 함주로 주소창이나 간단한 입력 영역에서 스크립트를 삽입하는 식으로 공격
- **대응**
    - **Query를 sanitize**
        - Reflected XSS 코드 예제에서는 query를 받는 부분을 sanitizeHtml() 함수를 사용하여 sanitize를 한다. 코드를 적용하니 주소 url에서 query에 태그를 입력해도 태그가 걸러지는 것을 볼 수 있음
    - **DOM을 sanitize**
        - 스크립트만 막아야하므로 별도의 옵션으로 allowedTags를 false값

### **CSRF (Cross-Site Request Forgery)**

사이트간 요청 위조

동작 원리

1. 사용자는 보안이 취약한 서버에 로그인

2. 서버에 저장된 세션 정보를 사용할 수 있는 session ID가 사용자의 브라우저 쿠키에 저장됨

3. 공격자는 사용자가 악성 스크립트 페이지를 누르도록 유도
- 게시판이 있는 웹사이트에 악성 스크립트를 게시글로 작성하여 사용자들이 게시글을 클릭하도록 유도
- 메일 등으로 악성 스크립트를 직접 전달하거나, 악성 스크립트가 적힌 페이지 링크를 전달

4. 사용자가 악성 스크립트가 작성된 페이지 접근시 웹 브라우저에 의해 쿠키에 저장된 session ID와 함께 서버로 요청

5. 서버는 쿠키에 담긴 session ID를 통해 해당 요청이 인증된 사용자로부터 온 것으로 판단하고 처리

- 대응
    
    Referer check (리퍼러 체크)
    
    Java servlet을 사용하신다면 아래와 같이 intercepter 클래스를 만들어서 모든 요청에 대해 referer check 할 수 있도록 방어가 가능
    

CAPTCHA 도입

- 이게 그 우리 맨날 자동차가 포함된 타일을 골라주세요! 라는 사진임

### **인풋 검증**

- 사용자 입력값을 검증하지 않으면 Injection, XSS 등의 취약점으로 이어짐
- **대응**: 서버 측에서 화이트리스트 기반 필터링, 정규식 검증 등

### **보안 헤더**

- **Content-Security-Policy**: 외부 JS 제한
- **X-Frame-Options**: 클릭재킹 방지
- **X-Content-Type-Options**: MIME 스니핑 방지

### **쿠키 속성**

| **속성** | **설명** |
| --- | --- |
| **HttpOnly** | JavaScript로 접근 불가 (XSS 방지) |
| **Secure** | HTTPS로만 전송 |
| **SameSite** | 쿠키의 크로스사이트 전송 제어 (Lax, Strict, None) |
|  |  |

## **✅ 시스템 및 실무 보안**

### **1. 권한 상승 (Privilege Escalation)**

- **정의**: 일반 사용자가 시스템 내의 취약점을 이용해 **루트(관리자) 권한**을 얻는 공격.
- **원인 예시**:
    - SUID가 설정된 프로그램의 취약한 코드 실행 (/usr/bin/passwd 등)
    - 루트 소유 파일을 잘못된 권한으로 접근 허용
    - 웹 애플리케이션의 인가 로직 부재 (ex. /admin 접근 가능)
- **대응 방법**:
    - SUID, SGID 최소화 및 모니터링
    - 역할 기반 접근 제어(RBAC) 정책 수립
    - 서비스/애플리케이션 계정은 최소 권한만 부여

### 

### **2. 파일 권한**

- 리눅스/유닉스는 r(읽기), w(쓰기), x(실행) 권한을 사용자/그룹/기타에 따라 구분함.
- **권한 구조 예시**:

```
-rw-r--r-- 1 user group 123 Jul 1 config.env
```

- **실무 예시**:
    - DB 비밀번호가 담긴 .env, .pem 키 파일 등은 chmod 600으로 소유자만 접근 가능하게 설정
- **실수 예시**:
    - /var/www/html/config.php에 DB 자격정보 포함 + world readable 설정 → 해킹
    

### **3. JWT 보안**

- JWT는 **서명된 문자열 토큰**으로 인증 상태를 클라이언트에 저장하여 사용.
- **기본 구성**: Header.Payload.Signature

**주의사항**

| **항목** | **설명** |
| --- | --- |
| alg=none 취약점 | 서명 없이 인증 우회 가능 (라이브러리에서 기본값 확인해야 함) |
| 유효 기간(exp) | 반드시 설정하여 토큰 탈취 시 영향 최소화 |
| Refresh Token | Access Token은 짧게, Refresh Token은 재발급용으로 별도 관리 |
| HTTPS 사용 | JWT는 탈취되면 인증 상태 유지됨 → TLS로 암호화 필수 |
| 로그아웃 처리 | JWT는 상태를 서버에서 저장하지 않으므로 **Blacklist**, Redis 저장 등 처리 필요 |

### **4. 세션 탈취 (Session Hijacking)**

- 인증된 사용자의 세션 ID(주로 쿠키에 저장됨)를 탈취하여 **로그인 상태 탈취**
- **공격 예시**:
    - XSS를 통해 document.cookie를 훔치기
    - 네트워크 스니핑으로 세션 쿠키 가로채기

### **대응 방법**

| **항목** | **설명** |
| --- | --- |
| HttpOnly | JS에서 접근 못하게 하여 XSS로부터 보호 |
| Secure | HTTPS에서만 전송되도록 강제 |
| SameSite=Strict | CSRF 방지용: 외부 요청에는 쿠키 안 보내도록 설정 |
| 세션 갱신 | 로그인 후 세션 ID 재발급 (세션 고정 공격 방지) |
| IP/UA 체크 | 사용자 환경이 갑자기 바뀌면 세션 만료 처리 |

### **5. 2FA (Two-Factor Authentication)**

- **2단계 인증**은 사용자가 인증 시 **두 가지 요건**을 만족해야 인증되는 방식.
- **첫 번째 요건**: ID/PW (지식 기반 인증)
- **두 번째 요건**:
    - **소유 기반**: OTP, 이메일 인증, SMS 인증
    - **생체 기반**: 지문, 안면 인식 등 (FIDO 기반)
- **왜 필요한가?**
    - 비밀번호 유출 시 계정 보호 가능
    - 기업 서비스에서는 2FA를 기본 보안요건으로 요구
    

### **6. 보안 설계 시 고려사항**

보안을 시스템 개발 초기에 고려하지 않으면, 나중에 **취약점 보완 비용이 수십 배 증가**할 수 있음.

 ****

**주요 고려사항:**

| **항목** | **설명** |
| --- | --- |
| 인증 vs 인가 구분 | 로그인(Authentication)과 권한 확인(Authorization)을 명확히 구분 |
| 최소 권한 원칙 | 사용자나 시스템 컴포넌트에 꼭 필요한 권한만 부여 |
| 데이터 암호화 | 전송 시 TLS, 저장 시 AES 등 적용 |
| 에러 메시지 제한 | 예: 존재하지 않는 계정입니다 → 공격자에게 정보 제공 위험 |
| 보안 로깅 & 모니터링 | 공격 탐지 가능하도록 핵심 행동 로깅 (ex. 로그인 시도, 관리자 접근 등) |
| 패치/업데이트 | 운영 중인 시스템의 라이브러리, OS 등을 주기적으로 점검 및 갱신 |