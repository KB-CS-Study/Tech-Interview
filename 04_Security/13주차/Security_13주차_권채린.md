# 보안 기초 + 네트워크 보안


## 보안 기본 개념

### 🚨 기밀성, 무결성, 가용성

1. **기밀성(Confidentiality)**
    
    인가되지 않은 사용자나 시스템이 정보에 접근하지 못하도록 보호하는 것
    
    - 정보에 대한 접근 제한
    
    예시 : 로그인 인증, 암호화된 통신, 접근 제어 시스템
    
    보안 위협 사례 : 해킹, 도청, 내부자 정보 유출
    
2. **무결성(Integrity)**
    
    정보가 **원래의 상태 그대로 유지**되고, 인가되지 않은 변경이나 손상이 발생하지 않도록 보장하는 것
    
    - 데이터의 정확성과 신뢰성 유지
    
    예시 : 해시값 비교를 통한 파일 검증, 디지털 서명, 변경 이력 관리
    
    보안 위협 사례 : 중간자 공격, 데이터 위조, 파일 손상
    

1. **가용성(Availability)**
    
    인가된 사용자가 필요할 때 **항상 정보와 시스템을 사용할 수 있도록 보장**하는 것
    
    - 서비스 지속성 확보
    
    예시 : 서버 이중화, 백업 시스템, 디도스 방어
    
    보안 위협 사례 : 디도스 공격, 서버 다운, 랜섬웨어에 의한 시스템 잠금

    <br>
    

### 🚨 인증(Authentication), 인가(Authorization)

**인증(Authentication)**

- 사용자가 진짜 본인인지 확인하는 과정

정의 : 사용자가 주장하는 신원을 시스템이 검증

사용 예시 : 

- 아이디 + 비밀번호 입력
- 지문, 얼굴 인식
- OTP, 인증 메일
- OAuth 로그인

목적 : 사용자의 신원 확인

실패 시 보안 위험 : 타인이 다른 사람으로 가장해 시스템 접근 가능

**인가(Authorization)**

- 인증된 사용자가 무엇을 할 수 있는지 결정

정의 : 인증된 사용자에게 어떤 자원에 접근할 권한이 있는지 확인하는 과정

사용 예시 :

- 일반 사용자는 본인 정보만 열람 가능, 관리자는 모든 사용자 정보 열람 가능
- 게시판 글 작성은 가능하지만 삭제는 관리자만 가능

목적 : 권한 제한 및 역할 기반 제어

실패 시 보안 위험 : 일반 사용자가 권리자 권한을 가지게 될 수 있음 

![image](https://github.com/user-attachments/assets/fc60f988-2f93-4b1e-a464-b531510422c1)

    
<br>
    
### 🚨 해시(Hash)

임의의 데이터를 고정된 길이의 값으로 변환하는 함수, 주로 데이터 무결성 확인이나 비밀번호 저장, 디지털 서명 등에 사용

- 임의의 길이 입력 → 고정된 길이의 출력 생성
- 출력된 고정 길이의 값을 해시 값 또는 메시지 다이제스트라고 함

**해시 주요 특징**

- 결정성 : 같은 입력 → 항상 같은 출력
- 빠른 계산 속도 : 해시값 생성이 빠르다
- 충돌 회피 : 서로 다른 입력 → 같은 해시값 나오지 않게
- 역산 불가성 : 해시값 → 원래 값을 역산할 수 없음
- 작은 변화 민감성 : 입력이 조금만 바뀌어도 해시값이 완전히 바뀜

**해시 알고리즘 종류**

| 알고리즘 | 해시 길이 | 보안 수준 | 비고 |
| --- | --- | --- | --- |
| **MD5** | 128비트 | 낮음 | 빠르지만 충돌 가능성이 높아 사용 지양 |
| **SHA-1** | 160비트 | 낮음 | 취약점 발견되어 점차 퇴출 중 |
| **SHA-256** | 256비트 | 높음 | 현재 가장 널리 쓰이는 보안 해시 |
| **SHA-3** | 다양함 | 높음 | SHA-2 이후 표준화된 알고리즘 |


<br>
    
### 🚨 대칭/비대칭 키 암호화

**대칭키 암호화 (Symmetric Encryption)**

**하나의 비밀 키로 암호화와 복호화 모두 수행** / 비밀키 암호화라고도 함

- 특징 : 암호화/복호화에 동일한 키 사용
- 장점 : 빠른 속도, 구현 간단
- 단점 : 키를 공유하는 과정에서 유출 위험있음
- 예시 : AES, DES

![image](https://github.com/user-attachments/assets/adfefd28-015e-4cbd-8924-9bcc4374dee3)


**비대칭키 암호화 (Asymmetric Encryption)**

**공개키로 암호화하고, 개인키로 복호화** ⇒ 암호화와 복호화에 다른 키 사용

- 특징 : 서로 다른 두 개의 키 사용(공개키/개인키)
- 공개키 : 누구나 볼 수 있음(배포 가능)
- 개인키 : 본인만 알고 있어야 함
- 장점 : 키를 공유하지 않아도 되어 안전함
- 단점 : 연산 비용이 높아 속도가 느림
- 예 시 : RSA, DSA, ECC

![image](https://github.com/user-attachments/assets/28c81f90-417a-47b9-b576-2c972802d6b8)

![image](https://github.com/user-attachments/assets/4e359080-9ec0-47f3-ad55-8b61572b7f2a)

<br>
    
### 🚨 전자서명

⇒ 전자문서에 대해 서명자의 신원과 해당 문서의 위변조 여부를 확인 가능하게 하는 기술

핵심 기능

- 무결성 보장 : 문자가 중간에 변경되지 않았음을 확인
- 인증 : 서명자가 실제 서명했음을 증명
- 부인 방지 : 나중에 서명 사실을 부인할 수 없음

<br>

## 네트워크 보안

### 🧩 HTTPS 동작 원리 & TLS 핸드 셰이크

- **HTTP**(HyperText Transfer Protocol) : 웹 브라우저와 웹 서버 간에 데이터를 주고받는 프로토콜
- **HTTPS**(HTTP Secure or HTTP over SSL/TLS) : HTTP에 TLS(또는 SSL) 암호화를 더한 버전

**[HTTPS Handshake 작동 방식]**

1. **클라이언트 → 서버로 접속 시도** (https URL 입력)
2. 서버가 **인증서(공개키 포함)** 전송
3. 클라이언트는 인증서가 **신뢰할 수 있는 기관(CA)**에서 발급되었는지 확인
4. 클라이언트가 **대칭키를 생성**하고, 서버의 공개키로 암호화하여 서버에 전송
5. 서버는 **자신의 개인키로 복호화**해 대칭키 획득
6. 이후부터는 **대칭키로 암호화된 통신**

![image](https://github.com/user-attachments/assets/d9f0f3c6-afa8-4010-9e43-3d45a71dd4f5)


<br>


### 🧩 SSL Strip

### 🧩 인증서 구조

- 디지털 인증서 : 공인된 기관에서 발급한, 서버 또는 사용자의 신원을 증명하는 전자 문서

| 항목 | 설명 |
| --- | --- |
| **Version** | 인증서 버전 (보통 v3) |
| **Serial Number** | 인증서 고유 번호 |
| **Signature Algorithm** | CA가 인증서에 서명할 때 사용한 해시 및 암호화 알고리즘 (예: SHA256withRSA) |
| **Issuer** | 인증서를 발급한 기관(CA)의 이름 |
| **Validity** | 인증서의 유효 기간 (Not Before / Not After) |
| **Subject** | 인증서 주체 (도메인 이름, 개인 또는 서버 정보 등) |
| **Subject Public Key Info** | 인증서 주체의 **공개키**와 그 알고리즘 정보 |
| **Extensions** | 확장 필드 (옵션), 예: 도메인 이름, 서버 인증 용도 등 |
| **Signature** | CA가 위 정보들을 요약(해시)한 후 **자신의 개인키로 서명한 값** |

![image](https://github.com/user-attachments/assets/1623e389-dd80-4c53-b97a-9bcdb278dbde)


<br>


### 🧩 DNS 스푸핑

- DNS : Domain Name System
- 사람이 기억하기 쉬운 도메인 주소**(www.google.com)**를 ip주소(예: 142.250.206.4)로 변환해주는 시스템
- 애플리케이션 게층 프로토콜

![image](https://github.com/user-attachments/assets/eaf6b51c-6dbd-49ad-bee0-a1ba7a067d73)


**DNS 스푸핑**

- DNS 서버나 클라이언트의 DNS 캐시에 잘못된 IP 주소를 의도적으로 넣어, 사용자가 가짜 사이트에 접속하게 만드는 공격
- 즉, 도메인 이름에 대응하는 IP주소를 조작해서, `www.bank.com`에 접속하려고 했는데, 실제로는 **공격자의 사이트**로 접속되게 만드는 것

🔐 **DNS 스푸핑 공격 절차**

1. 사용자가 웹사이트 접속 (`www.bank.com`)
2. 브라우저가 DNS 서버에 IP 주소 요청
3. 공격자가 미리 **위조된 DNS 응답**을 클라이언트에게 전달
4. 사용자의 로컬 DNS 캐시에 **잘못된 IP 정보 저장**
5. 사용자는 가짜 웹사이트(`bank.fake.com`)에 접속하게 됨

![image](https://github.com/user-attachments/assets/3e45378b-91fc-4c47-920d-9b327cb396af)

<br>


### 🧩 Man-in-the-Middle 공격

- **통신 중간에 공격자가 몰래 끼어들어**, 양쪽 당사자의 데이터를 **가로채거나 조작**하는 공격
- 중간자 공격이라고도 불리며, 마치 도청하는 제3자가 통신 내용을 몰래 엿보고 바꾸는 방식
- 피해자는 공격자가 있다는 사실도 모른채, 정상적으로 통신하고 있다고 착각
