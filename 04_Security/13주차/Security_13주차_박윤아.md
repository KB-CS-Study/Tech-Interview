
## CIA Triad

정보 보안의 핵심 개념인 CIA Triad는 **기밀성**, **무결성**, **가용성**의 약자로 정보 보안에서 필수적으로 고려해야함

이들 요소는 상호 보완적인 관계를 가지며, 하나라도 소홀히 여겨서는 안 됨  
다만, **어느 요소가 더 중요한지에 대해서는 상황에 따라 달라질 수** 있음

> 📌 기밀성이 중요한 조직에서는 기밀성을 최우선으로 고려하고, 그다음으로 무결성, 가용성을 중요시한다.  
> 반면, OT 환경(운영기술 환경)에서는 가용성이 최우선이며, 그다음으로 무결성과 기밀성을 고려하는 순서가 바뀔 수 있다.

![1](https://github.com/user-attachments/assets/b17cf16f-4be8-4794-af28-26fafcaca9d5)


###   
1) 기밀성 (Confidentiality)

기밀성은 “**_허가받지 않은 자가 정보에 접근할 수 없도록 보호하는 것_**”을 의미

개인의 은행 계좌 정보가 **외부에 노출되지 않도록 보호**해야 하는데, 이를 실현하기 위한 대표적인 방법은 \`**암호화\`**

> 📌 암호화는 데이터를 다른 형태로 변환하여, **허가받지 않은 자가 이해할 수 없게 만드는 기술**

또한, \`**접근 통제**\`도 중요한 기밀성 확보 수단

금고에 중요한 문서를 보관하고, 그 금고에 접근할 수 있는 자격을 제한하는 방식처럼, **정보 시스템에서도 사용자별로 접근 권한을 제한**함으로써 기밀성을 유지할 수 있음

예시: 기업에서는 직급별, 부서별로 권한을 세분화하여 개발자가 회계 데이터를 함부로 열람하지 못하거나, 법무팀이 보관하는 계약서를 타 부서에서 볼 수 없도록 관리!

![2](https://github.com/user-attachments/assets/360ec6e1-604c-4d33-928e-33c1db198f33)


### 2) 무결성 (Integrity)

무결성은 “**정보가 허가받지 않은 방식으로 변경되거나 삭제되지 않도록 보호하는 것”**을 의미

은행의 거래 내역이 임의로 조작되지 않도록 보호하는 것이 무결성의 대표적인 사례로,  
무결성을 유지하기 위해서는 \`변경 금지 정책\`이나, 필요한 경우 \`변경 시 승인\`을 받는 절차가 必

또한, 변경 작업이 발생하면 그에 대한 **로그 기록**을 남겨, 문제가  발생했을 때 추적할 수 있어야 함  
이러한 로그는 사후 분석에 중요한 역할을 하며, 문제 해결의 단서를 제공

![3](https://github.com/user-attachments/assets/42951f93-61b4-4a28-8c19-fa597a4d628b)


### 3) 가용성 (Availability)

가용성은 “_**허가받은 사용자가 적시에 원하는 정보를 접근할 수 있도록 하는 것**_”을 의미  
이는 정보 시스템이 **언제든지 사용 가능하도록 유지**하는 것을 목표로 하며, 백업과 재난 복구 시스템을 통해 실현

데이터 손실에 대비해 정기적으로 데이터를 백업하거나, 2차 데이터센터를 구축해 시스템 장애 시 신속하게 복구할 수 있도록 하며, 정기적인 복구 테스트를 통해 예상치 못한 상황에 대비하는 것이 중요

---

### ❓ 인증과 인가

#### 인증 (Authentication)

사용자의 **신원을 입증하는 과정**을 인증이라고 함

> 예시: 사용자가 사이트에 로그인할 때 누구인지 확인하는 과정

#### 인가 (Authorization)

인가는 **사이트의 특정 부분에 접근할 수 있는지 권한을 확인**하는 작업

> 예시: 관리자는 관리자 페이지에 들어갈 수 있으나, 일반 사용자는 관리자 페이지에 접근 불가

---

## 해시 (Hash)

해시는 **임의 길이의 데이터**를 **고정된 길이의 데이터**(해시 값, 해시 코드, 요약 등)로 변환하는 **단방향 함수**

원본 데이터를 추정할 수 없도록 설계되며, **같은 입력에 대해서는 항상 같은 출력**을 보장

| **용어** | **설명** |
| --- | --- |
| **해시** | 다양한 길이 데이터를 고정 길이 데이터로 매핑한 값 |
| **해싱** | 임의의 데이터를 해시로 바꾸는 일 |
| **해시 함수** | 임의의 데이터를 해시로 바꾸는 함수 |


---

## HTTPS (HyperText Transfer Protocol Secure Socket Layer)

HTTP/2,3은 HTTPS 위에서 동작

HTTPS는 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 \`SSL/TLS\` 계층을 넣은 신뢰할 수 있는 HTTPS 요청을 말함

HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, **SSL이나 TLS 프로토콜을 통해** **세션 데이터를 암호화** 함

> ∴ 데이터의 적절한 보호를 보장

HTTPS를 구축하는 방법은 아래와 같이 크게 세 가지로 나뉨

1.  직접 **CA**에서 구매한 인증키를 기반으로 HTTPS 서비스 구축
2.  서버 앞단에 HTTPS를 제공하는 **로드밸런서** 사용
3.  서버 앞단에 HTTPS를 제공하는 **CDN** 사용

---

## SSL/TLS

**SSL** (Secure Soket Layer)은 SSL 1.0 부터 시작하여 SSL 2.0, SSL3.0, TLS 1.0, TLS 1.3까지 버전이 올라감

**TLS(Transport Layer Security Protocol)로 명칭이 변경**되었으나, 통칭하여 SSL/TLS로 부름

-   SSL/TLS는 전송 계층에서 보안을 제공하는 프로토콜
-   제 3자가 메시지를 도청하거나 변조하지 못하도록 함

| **항목** | **SSL** | **TLS** |
| --- | --- | --- |
| **정식 명칭** | Secure Sockets Layer | Transport Layer Security |
| **개발 주체** | Netscape | IETF(인터넷 표준화 기구) |
| **버전** | SSL 2.0, 3.0 (현재 모두 폐기됨) | TLS 1.0, 1.1, 1.2, 1.3 |
| **보안성** | 취약점 존재, 더 이상 사용되지 않음 | 최신 버전은 보안이 강화됨 |
| **호환성** | 과거 시스템과 호환 | SSL과의 하위 호환 제공 (초기 TLS) |
| **사용 여부** | 더 이상 사용하지 않음 | **현재 대부분의 웹에서 사용** 중 |

![1](https://github.com/user-attachments/assets/fbe2ab62-8c83-4481-a382-4e5e58a37784)


SSL/TLS를 통해 공격자가 서버인 척하면서  사용자 정보를 가로채는 네트워크상의 \`**인터셉터\` 방지 가능**

-   SSL/TLS는 **보안 세션을 기반**으로 데이터를 암호화
-   **보안 세션 만들기 👉** _**인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘**_ 사용됨

---

### 인증 메커니즘

인증 메커니즘은 \`**CA**\` (Certificate Authorities)에서 발급한 인증서를 기반으로 이루어짐

CA에서 발급한 인증서는 안전한 연결을 시작하는 데 있어 필요한 \`**공개키\`를 클라이언트에 제공**하고,  
사용자가 접속한 **서버가 신뢰할 수 있는 서버**임을 보장

![2](https://github.com/user-attachments/assets/84d4c1b6-16d7-4eec-9abd-7fbf9a73bd00)


CA는 아무 기업이나 할 수 있는 것이 아니며, _**신뢰성이 엄격히 공인된 기업들**만 참여_ 가능

> Ex) Comodo, GoDaddy, GlobalSign, 아마존 등

---

### CA 발급 과정

서비스가 CA 인증서를 발급받으려면 \`**사이트 정보**\`와 \`**공개키**\`를 CA에 제출해야 함

이후 CA는 공개키를 해시한 값인 **지문(finger print)**을 사용하는 CA의 비밀키 등을 기반으로 CA 인증서 발급

> **❓ 개인키, 공개키 (쌍을 이루어 존재)  
> \- 개인키 (비밀키)**: 키 발행자만이 갖는 키, 보통 데이터를 복호화 하는데 사용 (암호화도 가능)  
> **\- 공개키**: 누구나 알아도 상관 없는 키, 보통 데이터를 암호화 하는데 사용 (복호화도 가능)  
> \- **대칭키**: 암/복호화에 각기 다른 키를 사용하는 것이 아닌 대칭키라는 하나의 키를 사용

![3](https://github.com/user-attachments/assets/76f5e02d-36a7-4bb3-b8a4-53cf9f76e81a)


---

#### 인증서를 사용하는 이유

인증서는 **서버가 진짜 신뢰할 수 있는 주체인지 클라이언트에게 증명**하기 위한 수단임

#### 인증서의 역할

1.  서버의 공개키와 도메인이 진짜인지 검증
2.  공개키가 제 3자 (인증기관, CA)에 의해 발급되었는지 확인
3.  중간자 공격 방지

#### 인증서에 들어있는 것

-   서버의 도메인 정보
-   서버의 공개키
-   인증기관의 전자 서명
-   유효기간 등 메타 정보

브라우저는 내장된 신뢰된 루트 CA 목록을 가지고, 서버 인증서의 서명 검증

> **📌 정리  
> **인증서 없이는 **누가 공개키를 보냈는지 알 수 없어서, 신뢰할 수 없는 암호화**가 됨  
> ∴ SSL/TLS 핸드셰이크 (= HTTPS 핸드셰이크)에서 인증서를 먼저 보내는 것

이렇게, SSL/TLS 인증서를 통해 웹 브라우저가 서버를 신용하게 되었으므로, 그 다음으로 웹 브라우저와 서버는 **데이터를 어떻게 암호화할 것인지에 대해 협상**함.

이 협상에 사용되는 암호화 알고리즘의 집합이 바로 사이퍼 슈트이며, 이 전반적인 과정을 \`SSL/TLS HandShake\`라고 함

---

## SSL/TLS Handshake

**보안이 시작되고 끝나는 동안 유지되는 세션**

SSL/TLS는 핸드셰이크를 통해 보안 세션을 생성, 이를 기반으로 상태 정보 등을 공유

> **📌 세션**   
> 운영체제가 어떠한 사용자로부터 자신의 자산 사용을 허락하는 일정 기간  
> 사용자는 일정 시간 동안 응용 프로그램 & 자원 사용 가능

![4](https://github.com/user-attachments/assets/236f26eb-e39f-4244-9e7b-f07a12d85856)


\`TCP Handshake\`: HTTPS가 TCP기반의 프로토콜이므로 암호화 협상 (TLS Handshake)에 앞서 연결을 생성하는 과정

---

### 1) Client Hello

Client가 Server에 연결을 시도하며 전송하는 패킷

전송 내용: 

-   자신이 사용가능한 사이퍼 슈트 목록
-   Session ID
-   SSL Protocol Version
-   Random byte 

#### 사이퍼 슈트 (Cipher Suite) 👇🏻 

SSL Protocol version, 인증서 검증, 데이터 암호화 프로토콜, Hash 방식 등의 정보를 담고 있는 존재로,  
**선택된 Cipher Suite의 알고리즘에 따라 데이터를 암호화** 함

-   TLS\_AES\_128\_GCM\_SHA256
-   TLS\_AES\_256\_GCM\_SHA384
-   TLS\_ECDHE\_RSA\_WITH\_AES\_128\_GCM\_SHA256
-   TLS\_AES\_128\_CCM\_8\_SHA256

등

_EX) \`TLS\_AES\_128\_GCM\_SHA256\`_

-   TLS = 프로토콜
-   AES\_128\_GCM: AEAD 사이퍼 모드
-   SHA256: 해싱 알고리즘

EX2) \`TLS\_ECDHE\_RSA\_WITH\_AES\_128\_GCM\_SHA256\`

-   ECDHE: 키 교환방식
-   RSA: 인증서 검증

> **❓ AEAD 사이퍼 모드  
> **AEAD(Authenticated Encryption with Associated Data)는 **데이터 암호화 알고리즘**을 의미  
> EX)  AES\_128\_GCM  
> **128비트의 키**를 사용하는 표준 블록 암호화 기술 + **병렬 계산**에 용이한 **알고리즘 GCM**이 결합된 알고리즘

---

### 2-1) Server Hello

Client가 보내온 ClientHello Packet을 받아 사이퍼 슈트 중 하나를 선택한 후, Client에게 알림

또한 자신의 SSL Protocol version 등 도 함께 보냄

---

### 2-2) Certificate

1.  Server가 자신의 SSL/TLS 인증서를 Client에게 전달  
    (인증서 내부에는 **Server가 발행한 공개키**가 들어 있음)
2.  Client는 CA의 개인키로 암호화된 SSL 인증서를 CA의 공개키로 복호화
3.  복호화에 성공하면, 인증서는 진짜임이 증명됨 (실패 시 가짜)

---

#### 2-3) Server Key Exchange / ServerHello Done

Server Key Exchange는 Server의 공개키가 SSL 인증서 내부에 없는 경우, Server가 직접 전달함을 의미

> 인증서에 있는 경우 생략하는 과정

---

### 3-1) Client Key Exchange

Client는 데이터 암호화에 사용할 **대칭키를 생성하여, Server의 공개키로 암호화한 후 Server에 전달**

여기서 전달된 \`대칭키\`가 바로 **SSL/TLS Handshake의 목적**이자, 가장 중요한 수단인 **데이터를 실제로 암호화하는 비밀키**임

이제 Key를 통해 Client와 Server가 교환하고자 하는 데이터를 암호화 함

---

### 3-2) ChangeCipherSpec / Finished

Client, Server 모두가 서로에게 보내는 Packet으로 교환할 정보를 모두 교환한 뒤, **통신할 준비가 다 되었음을 알리는 패킷**

그리고 Finished Packet을 보내어 SSL/TLS Handshake 종료

---

#### **정리**

1.  ClientHello (암호화 알고리즘 나열 & 전달)
2.  ServerHello (암호화 알고리즘 선택)
3.  ServerCertificate (인증서 전달)
4.  Client Key Exchange (데이터 암호화할 대칭키 전달)
5.  Client / ServerHello done (정보 전달 완료)
6.  Finished (SSL/TLS Handshaek 종료)

즉, 클라이언트와 서버가 키를 공유하고, 이를 기반으로 인증, 인증 확인 등의 작업이 발생  
\= **단 한 번의 1-RTT가 생긴 후 데이터를 송수신** 

> 📌 TLS 1.3은 사용자가 이전에 방문한 사이트를 재방문하는 경우, 위 통신을 하지 않아도 됨 **(= 0-RTT)**

---

## 전자 서명 (Digital Signature)

전자 서명은 전자 문서의 **무결성, 인증**, 그리고 **부인 방지**를 보장하기 위한 기술임

주로 **공개키 암호 방식 (RSA, DSA, ECDSA 등)을 기반**으로 하며, **암호화와 해시 함수가 결합**되어 작동

---

### ❓ 부인 방지 (Non-repudiation)

부인 방지란 쉽게 말해 "**_나중에 발뺌할 수 없게 만드는 것_**"을 의미

#### 예시 상황:

-   A가 B에게 어떤 계약 문서를 이메일로 보냈고, 거기에 전자서명 진행
-   나중에 A가“_**나 그 문서 보낸 적 없어”**_라고 주장

**전자 서명은 A의 개인키로 생성**된 것이고 B는 **A의 공개키로 검증**할 수 있음

> 즉, 해당 서명은 A만이 만들 수 있고, 문서에 해당 서명이 있다는 건 A가 실제로 서명하고 문서를 보냈다는 증거

∴ A는 자신이 문서를 보낸 적 없다고 주장할 수 없음 = 부인 방지!

---

### 전자서명의 핵심 원리

전자 서명은 아래와 같은 순서로 이루어짐

1.  **해시값 생성**
    -   서명하고자 하는 원문(메시지)에 대해 해시 함수를 적용해 고정된 길이의 메시지 다이제스트(hash) 생성
    -   이 **해시값은 원문의 요약**으로, 원문이 바뀌면 완전히 다른 해시값 생성됨
2.  **서명 (Sign)**
    -   생성된 해시값을 **개인키로 암호**화
    -   **암호화된 해시값이 전자서명**이 됨
3.  **검증 (Verify)**
    -   검증자는 서명된 문서와 함께 제공된 전자서명을 받음
    -   서명자의 공개키로 전자서명을 복호화하여 해시값 A를 얻음
    -   동시에 받은 원문에 대한 동일한 해시함수를 적용해 해시값 B를 생성
    -   **\`A=B\`인 경우**, 위조된 문서가 아니며 서명자가 해당 개인키 소유자임을 확인

---

## 암호화 알고리즘

\`공개키\`는 **보안**을 위해,\` 대칭키\`는 **속도를 위해** 사용됩니다.

HTTPS에서는 처음에 **공개키로 대칭키를 안전하게 주고받고**, 이후는 **대칭키로 빠르게 암호화**합니다.

| **항목** | **공개키 암호화** | **대칭키 암호화** |
| --- | --- | --- |
| **키 사용 방식** | 공개키로 암호화, 개인키로 복호화 | 같은 키로 암호화와 복호화 |
| **속도** | 느림 | 빠름 |
| **사용 시점** | **초기 핸드셰이크에서만 사용** (대칭키 전달용) | 이후 **실제 데이터 전송에 사용** |
| **예시 알고리즘** | RSA | AES |

> **❓ 암호화 알고리즘?, 키 교환 방식?**  
> RSA는 공개키로 암호화 / 복호화를 수행하므로 공개키 암호화 알고리즘임.  
> DH, ECDHE는 공개키를 사용하는 키 교환 방식임 (암호화 xx)

---

### 공개키 암호화: RSA (Rivest–Shamir–Adleman)

#### 공개키 암호화

-   암/복호화에 **서로 다른 키** 사용
-   송신자는 **수신자의 공개키로 암호화**, 수신자는 **자신의 개인키로 복호화**
-   수학적 난제를 기반으로 설계
-   대칭키 암호에 비해 느림
-   키 교환 불필요
-   여러 송신자가 하나의 공개키로 암호화 하므로 사용자가 많아도 키 관리 유리
-   사용자 N명이 각자의 공개키 1개, 개인키 1개를 가지므로 → **키 개수 = \`2N\`**

![1](https://github.com/user-attachments/assets/90ab2f49-71e8-44fd-927b-6536dcd94e60)


---

#### RSA

RSA는 공개키 암호화 알고리즘의 대표격으로, 데이터를 암호화하거나, 전자서명을 생성하거나, 세션 키를 교환하는 데 사용

**TLS 1.3 부터는 속도와 보안성 문제로 ECDHE 등으로 대체**되는 중 (PFS 보장)

#### **소인수분해**가 매우 어렵다는 수학적 문제를 기반으로 함

-   큰 수 n을 두 소수의 곱으로 분해하는 건 매우 어렵고,
-   이 어려움을 이용해서 안전한 암호화 구조를 만듦

> 👉 누구나 암호화할 수 있지만 **복호화는 개인키를 가진 사람만** 가능

---

#### **❓ ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)**

-   ECDH: 타원 곡선 기반 디피-헬만 키 교환
-   **Ephemeral (일회용)**: 매 세션마다 새 키 쌍을 생성해 **Perfect Forward Secrecy(PFS)** 보장

> 📌 PFS   
> PFS는 특정 시점(예: 과거)의 통신 내용을 **그 시점의 세션 키 없이는 복호화할 수 없도록 보장**하는 보안 특성  
>   
> \`ECDHE\` 는 **매 세션마다 일시적인 키 쌍을 생성**하여 PFS를 제공하고, 이 때문에 **TLS 1.3 이후의 공개키 교환 방식에서 필수**로 채택됨  
> 반면, \`RSA\` 키 교환 방식은 **고정된 키**로 통신하기 때문에, **서버 개인키가 유출되면 과거의 통신 데이터까지 복호화**될 수 있어 PFS를 보장하지 못하며, 그로 인해 TLS 1.3에서는 제거됨

---

### 대칭키 암호화: AES (Advanced Encryption Standard)

#### 대칭키 암호화

-   암/복호화에 **하나의 암호키** 사용
-   비대칭키(공개키) 암호화에 비해 **속**도 빠름
-   사전에 송, 수신자 간 키를 교환 (DH, ECDHE, RSA) 해야 함
-   대상이 증가할 수록 많은 키 관리 필요
-   사용자 N명이 서로 안전하게 통신하려면, 각 쌍마다 서로 다른 키가 필요 → **키 개수 = \`N(N-1)/2\`**

![2](https://github.com/user-attachments/assets/0fa1a2df-608f-4a44-b55e-fe74b7d8d326)


\`AES\`: **가장 널리 사용되는 대칭키 블록 암호화** 알고리즘

| **항목** | **내용** |
| --- | --- |
| **이름** | **AES, Advanced Encryption Standard** (고급 암호화 표준) |
| **대체한 것** | 과거 **DES**(Data Encryption Standard)를 대체 |
| **암호 방식** | **대칭키 암호화** – 암호화와 복호화에 같은 키 사용 |
| **블록 크기** | **128비트 고정** |
| **키 길이** | **128, 192, 256비트 중 하나 선택** |
| **라운드 수** | 키 길이에 따라 **10, 12, 14 라운드** |
| **사용처** | HTTPS, VPN, 파일 암호화, 하드디스크 암호화 등 |

---

#### **❓ 왜 TLS도 대칭키를 사용하나**

-   비대칭키(RSA, ECDHE)는 **속도가 느림**
-   TLS는 세션 키 교환(=대칭키 생성)은 ECDHE로 하고,  
    **실제 데이터 암호화는 빠른 대칭키 암호화(AES, ChaCha20 등)를 사용**

---

#### 사용 예시: **A와 B가 비밀 키 k를 공유**

-   A는 메시지 "HELLO"를 k로 암호화해서 CIPHER 생성
-   B는 CIPHER를 k로 복호화해서 다시 "HELLO" 획득

👉 만약 이 k를 제 3자가 탈취하면, 암호문을 쉽게 복호화 할 수 있으므로 대칭키는 **키 관리가 핵심**

---

## 중간자 공격 (Man-in-the-Middle, MITM)

중간자 공격은통신 중간에 **공격자**가 몰래 끼어들어 **데이터를 엿보거나 조작**하는 공격

즉, A와 B가 통신한다고 생각했지만**, 실제로는 \`A-공격자-B\` 사이에서 통신이 몰래 중계**되고 있는 것

#### 예시: A가 B에게 로그인 요청

```
A ──(로그인 정보)──▶ 🕵️ Eve(공격자) ──▶ B
A ◀─(응답 위조)── 🕵️ Eve ◀── B
```

-   공격자 Eve는 A의 로그인 정보를 가로채거나 조작 가능
-   B은 아무 일도 모름. A도 B과 통신한다고 착각

---

### MITM이 가능한 조건

| 방법 | 설명 |
| --- | --- |
| ARP 스푸핑 | 내부 네트워크에서 공격자가 라우터인 척함 |
| DNS 스푸핑 | 가짜 IP 주소로 유도 (ex. 진짜 google 대신 가짜 google 접속) |
| HTTPS 우회 | 공격자가 **SSL Strip** 등을 사용해 **HTTPS를 HTTP로 다운그레이드** |
| 공용 Wi-Fi | 카페 와이파이 등에서 네트워크 스니핑 가능 |

---

### MITM 공격을 막는법

| 방어 방법 | 설명 |
| --- | --- |
| ✅ **HTTPS 사용 (TLS)** | 암호화로 중간에서 내용을 볼 수 없게 함 |
| ✅ **서버 인증서 검증** | CA 서명이 유효한지, 인증서가 진짜인지 확인 |
| ✅ **공개키 기반 키 교환 (ECDHE)** | 세션 키를 중간자가 알 수 없음 → **PFS 보장** |
| ❌ **HTTP 사용 금지** | 평문 전송은 중간자 공격에 너무 취약 |

---

## SSL Strip

SSL Strip은 클라이언트가 HTTPS로 접속하려는 걸 **중간자 공격자가 몰래 HTTP로 바꿔버리는 공격**  
👉 중간자 공격 기법 중 하나

-   사용자가 생각하기에 안전한 \`[https://example.com\`](https://example.com)에 접속 중이지만,
-   실제로는 공격자가 \`[http://example.com\`](http://example.com)로 접속하게 유도하고 로그인 정보를 가로챔

---

### SSL Strip 공격 단계

1.  **공격자가 중간자 위치 확보** (예: 공용 와이파이, ARP 스푸핑 등으로)
2.  사용자가 \`[http://example.com\`](http://example.com) 접속  
    원래는 서버가 301/302로 \`[https://example.com\`](https://example.com)으로 리다이렉션
3.  공격자가 그 리다이렉션을 **제거**하거나 **HTTP로 변조  
    **즉, 클라이언트는 https://로 안 넘어가고 http://에 머무름
4.  클라이언트가 로그인 정보 입력 → **평문**으로 서버 전송됨
5.  공격자는 평문 로그인 정보를 **가로채고 탈취**
6.  공격자는 백엔드에 **HTTPS로 안전하게 요청해서 응답을 받아온 후, 다시 HTTP로 클라이언트에 전송**

---

### SSL Strip 방지법

| 방법 | 설명 |
| --- | --- |
| ✅ **HTTPS 강제 리디렉션** | 서버 측에서 HTTP 요청을 301/308로 무조건 HTTPS로 강제 |
| ✅ **HSTS (HTTP Strict Transport Security)** | 브라우저가 이 도메인을 **무조건 HTTPS로 접속**하게 강제함 |
| ✅ **브라우저 주소창 확인 교육** | http:// 접속 여부에 대한 사용자 경각심 고취 |
| ❌ **HTTP 접속 허용** | 매우 위험. 반드시 막아야 함 |

---

#### **❓ HSTS**

서버가 브라우저에게 항상 HTTPS로 접속할 것을 강제하는 것

∴ 브라우저는 이후 해당 사이트에 무조건 HTTPS로 접근

> ⭐ 주소창에 HTTP로 써도 HTTPS로 자동 전환

---

## 스푸핑 (Spoofing )

스푸핑은 네트워크에서 **위조된 정보를 보내어**, 상대가 **내가 누구인지 오해하게 만드는 공격 방식**

### 1\. ARP 스푸핑

#### ARP

-   IP 주소 ↔ MAC 주소를 매핑하는 프로토콜
-   로컬 네트워크(LAN)에서만 사용
-   예: "192.168.0.1의 MAC 주소가 뭐야?" → **브로드캐스트 요청**

#### ARP의 문제점: **신뢰 기반 + 인증X**

ARP는 **아무 패킷이나 믿기 때문에,** 공격자가 “나는 라우터야!”라고 **위조된 ARP 응답**을 보내면, 피해자는 MAC 주소를 덮어써버림

> 공격자 → 피해자: "192.168.0.1 = 내 MAC 주소"  
> 공격자 → 라우터: "192.168.0.100 = 내 MAC 주소"  
>   
> 이러면 피해자와 라우터는  모두 공격자에게 트래픽을 보냄

---

### 2\. DNS 스푸핑

역할: example.com (도메인 주소) → 123.123.123.123 (IP 주소 반환) 

#### **DNS의 문제점:**

-   UDP 기반 (검증 약함)
-   응답자가 **진짜 DNS 서버인지 확인하지 않음**
-   캐시 중독 가능 (DNS Cache Poisoning)

#### 예시:

공격자가 example.com 요청에 대해 **자신이 만든 가짜 IP 주소를 응답**해줌 → 사용자는 가짜 사이트로 접속

> **❓ DNS Cache Poisoning**  
>   
> DNS 서버나 사용자의 DNS 캐시에 잘못된 IP 주소 정보를 심어 넣는 공격  
> 👉 정상 도메인을 가짜 IP 주소로 유도 가능  
> HTTPS를 강제하면 위 위협을 막을 수 있음 (SSL 인증서 불일치)

---

### 정리

스푸핑은 **기본 프로토콜 설계의 ‘신뢰 구조’를 악용하는 공격**  
즉, **“나는 누구다”라고 말하는 걸 시스템이 굳이 확인하지 않기 때문에** 속을 수 있음

현대 보안은 이 신뢰를 **검증(암호화, 인증서, 서명)**으로 대체하는 방향으로 발전 中

| **공격 기법** | 목적 | 주요 수단 | 대응 방안 |
| --- | --- | --- | --- |
| **MITM** | 통신 중간 탈취 및 조작 | ARP/DNS 스푸핑 등 | HTTPS, VPN, 세션 보호 |
| **SSL Strip** | HTTPS → HTTP 다운그레이드 | MITM 기반 | HSTS, HTTPS 리디렉션 강제 |
| **ARP Spoofing** | 동일 네트워크 내 트래픽 가로채기 | ARP 응답 위조 (MAC 주소 속임) | 정적 ARP 설정, ARP 인스펙션 |
| **DNS Spoofing** | 사용자를 가짜 IP로 유도 | DNS 응답 위조 | DNSSEC, HTTPS 적용 |
