# 보안 기초 + 네트워크 보안

## 보안 기본 개념

### 기밀성·무결성·가용성 (CIA)

1. 기밀성 (Confidentiality)
    - 허용된 사용자만 정보자산에 대한 접근을 허용하는 것
    - 위협요소 : 도청, 도난

2. 무결성 (Integrity)
    - 데이터가 악의적으로 변경되지 않는 것
    - 자산이 허용된 User에 의해서만 변경이 가능 해야 한다.

3. 가용성 (Availability)
    - 허용된 당사자가 원하는 시간에 데이터에 접근 가능한 것
    - ex) 아무데서나 네이버 구글 로그인은 가능하다.
    - 위협요소 : 디도스 공격(내부) 화재, 정전(외부)

<hr />

### 인증(Authentication)과 인가(Authorization)

1. 인증이란?
    - 유저가 누구인지 확인하는 절차, 회원가입하고 로그인 하는 것.

2. 인가란?
    - 유저에 대한 권한을 허락하는 것.

- 누가, 언제, 어떻게 쓰고 있는가를 파악하기 위해 어떤 사이트에서든 인증, 인가가 있음.
- 인증과 인가는 API에서 가장 자주 구현되는 기능중 하나.
- Private한 API는 물론이고 Public한 API도 기본적인 인증과 인가를 요구.

#### 인증(Authentication)

- 인증은 유저의 identification을 확인하는 절차이다.
- 쉽게 설명하면 유저의 아이디와 비번을 확인하는 절차
- 인증을 하기 위해서 먼저 유저의 아이디와 비번을 생성할 수 있는 기능도 필요하다.

#### 비밀번호 암호화는 어떻게 이루어지는가

- 유저의 비밀번호는 절대 비밀번호 그대로 DB에 저장하지 않음
- DB가 해킹 당하면 유저의 비밀번호도 그대로 노출될 뿐더러 내부 개발자나 인력이 그 정보를 볼 수있음 -> 유저의 비밀번호는 꼭 암호화해서 저장
- 비밀번호 암호화에는 단방향 해쉬 함수(one-way-hash function)가 일반적으로 쓰임

ref) 단방향 해쉬함수란?
: 원본 메시지를 변환하여 암호화된 메시지인 다이제스트(digest)를 생성

- 원본 메세지를 알면 암호화된 메시지 알 수 있지만 그 반대는 안됨. 그래서 one-way이다.

#### 단방향 해시함수의 취약점(Rainbow table attack)

- 해시함수는 원래 패스워드를 저장하기 위한 것이 아닌 짧은 시간에 데이터를 검색하기 위해 설계된 것
- 그렇기 때문에 해시 함수는 본래 처리 속도가 최대한 빠르도록 설계된 속성을 이용해서
  공격자는 매우 빠른 속도로 임의의 문자열의 다이제스트와 해킹할 대상의 다이제스트를 비교 가능
- 이런 방식으로 패스워드를 추측하면 패스워드가 충분히 길거나 복잡하지 않은 경우에는 그리 긴 시간이 걸리지 않음

ref) Rainbow table
: 미리 해쉬값들을 계산해 놓은 테이블

#### 단방향 해시함수의 보완점(Salting,Key Stretching)

- Salting
    - 원본 값에 '소금을 뿌리듯이' random값을 추가하는 것
- Key Stretching
    - 연산을 느리게 하기 위해 해쉬값이 구해지면 그 해시값을 기반으로 또 해쉬를 하고 해쉬를 하고 n번 해서 최종값을 저장 => rainbow attack이 어려워짐
- 두 가지 암호 알고리즘으로 기존 단방향 해쉬함수의 단점을 보완

#### 인가(Authorization)

- 사용자가 로그인하면, 해당 사용자가 맞는지 확인하는 절차
    - JSON WEB TOKEN(JWT)를 쓰면 인가가 수월함(서버가 유저 정보를 갖고 있으므로 데이터에서 유저의 권한 정보도 읽어들이면 됨)
    - access token을 통해 해당 유저 정보를 얻을 수 있으므로 해당 유저가 가지고 있는 권한(permission)도 확인가능

#### JSON WEB TOKEN(JWT)

- Header - Payload - Signature 로 구성되어 있다.
- Header에는 토큰 타입과 해시 알고리즘 정보가 들어간다.
- Payload 에는 토큰 정보 또한 직접적인 정보가 아닌 primary key 정보가 들어가서 쉽게 알수없는 정보를 넘기는 게 아니라, 쉽게 식별할 수 없는 키를 넘겨준다. 토큰의 유효 기간을 넘겨주는것도
  일반적이다.
- Signature에는 앞에 정보를 암호화 한 내용이 들어간다고 볼 수 있다.
- JSON Web Token을 frontend는 받아서 다시 backend로 넘겨 주어야함

#### Authorization 절차

1. Authentication 절차를 통해 access token을 생성한다. access token에는 유저 정보 를 확인할 수 있는 정보가 들어가 있어야 한다 (예를 들어 user id).
2. 유저가 request를 보낼때 access token을 첨부해서 보낸다.
3. 서버에서는 유저가 보낸 access token을 복호화 한다.
4. 복호화된 데이터를 통해 user id를 얻는다.
5. user id를 사용해서 database에서 해당 유저의 권한(permission)을 확인하다.
6. 유저가 충분한 권한을 가지고 있으면 해당 요청을 처리한다.
7. 유저가 권한을 가지고 있지 않으면 Unauthorized Response(401) 혹은 다른 에러 코드를 보 낸다.

<hr />

### 대칭/비대칭 키 암호화 (AES, RSA)

#### 대칭 키 알고리즘

- 암호화, 복호화 모두 같은 키를 사용한다.
- 빠르고 안전하다.
- 키관리가 어렵다. (안전한 키 교환 방법이 필요하다.)
- AES, DESC, Blowfish
- AES는 128 192, 256가 있는데 256이 가장 안전하다.

#### 비대칭 키 알고리즘

- 공개키 + 비밀키를 필요로 한다.
- 공개키는 누구에게나 공개해도 되고, 비밀키는 소유자만 알고있어야 한다.
- 공개키로 데이터를 암호화 하고, 비밀키로 복호화 한다.
- 키관리가 쉽다. (안전한 키 교환 방법이 필요치 않다)
- 속도가 느리고 계산량이 많다.
- RSA, Diffie-Hellman, ECC
- RSA는 2048비트 이상이며 보안수준이 높은경우 4096비트 이상의 크기가 사용된다.

<hr />

### 디지털 서명

- 디지털 서명은 메시지의 인증과 무결성을 보장하기 위한 암호학적 기술
- 디지털 서명에는 다음과 같은 단계가 있다.

1. 메시지의 해시 값 계산: 메시지의 해시 값(또는 메시지 다이제스트)을 계산한다. 해시 함수는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다.
   디지털 서명에서는 일반적으로 SHA-2 또는 SHA-3과 같은 안전한 해시 함수를 사용하여 해시 값을 계산한다.

2. 개인 키로 암호화: 해시 값에 개인 키를 적용하여 암호화한다.
   이 과정에서는 전용 알고리즘, 예를 들어 RSA나 ECDSA(타원 곡선 디지털 서명 알고리즘) 등을 사용한다.

3. 디지털 서명 생성: 암호화된 해시 값(서명)과 함께 공개 키(디지털 인증서에서 제공)를 함께 전송한다. 이 서명은 메시지의 무결성과 인증을 증명하는 데 사용된다.

4. 디지털 서명 검증: 서명을 검증하는 데는 메시지의 원본 해시 값을 계산하여, 공개 키를 사용하여 서명된 해시 값과 비교한다.
   이를 통해 서명이 원본 메시지에 대한 것임과 서명이 위조되지 않았음을 증명할 수 있다.

- 메시지의 해시 값을 계산하여 디지털 서명을 생성하면, 해시 값이 고정 길이이므로 매우 짧아지며, 무결성과 인증을 검증하는 데 소요되는 데이터 양이 줄어든다.
  이를 통해 전송 대역폭을 절약하고 검증 속도를 높일 수 있다.

<hr />

## 네트워크 보안

### HTTPS 동작 원리

- 공개키 암호화 방식과 대칭키 암호화 방식의 장점을 활용해 하이브리드 사용
    - 데이터를 대칭키 방식으로 암복호화하고, 공개키 방식으로 대칭키 전달

1. 클라이언트가 서버 접속하여 Handshaking 과정에서 서로 탐색

   1.1. Client Hello

    - 클라이언트가 서버에게 전송할 데이터
        - 클라이언트 측에서 생성한 랜덤 데이터
        - 클-서 암호화 방식 통일을 위해 클라이언트가 사용할 수 있는 암호화 방식
        - 이전에 이미 Handshaking 기록이 있다면 자원 절약을 위해 기존 세션을 재활용하기 위한 세션 아이디

   1.2. Server Hello

    - Client Hello에 대한 응답으로 전송할 데이터
        - 서버 측에서 생성한 랜덤 데이터
        - 서버가 선택한 클라이언트의 암호화 방식
        - SSL 인증서

   1.3. Client 인증 확인

    - 서버로부터 받은 인증서가 CA에 의해 발급되었는지 본인이 가지고 있는 목록에서 확인하고, 목록에 있다면 CA 공개키로 인증서 복호화
    - 클-서 각각의 랜덤 데이터를 조합하여 pre master secret 값 생성(데이터 송수신 시 대칭키 암호화에 사용할 키)
    - pre master secret 값을 공개키 방식으로 서버 전달(공개키는 서버로부터 받은 인증서에 포함)
    - 일련의 과정을 거쳐 session key 생성

   1.4. Server 인증 확인

    - 서버는 비공개키로 복호화하여 pre master secret 값 취득(대칭키 공유 완료)
    - 일련의 과정을 거쳐 session key 생성
      
   1.5. Handshaking 종료

2. 데이터 전송

    - 서버와 클라이언트는 session key를 활용해 데이터를 암복호화하여 데이터 송수신

3. 연결 종료 및 session key 폐기

![](https://velog.velcdn.com/images%2Faverycode%2Fpost%2F1e192b79-3071-4de2-ad1d-1d203c399e08%2Fimage.png)

<hr />

### TLS 핸드셰이크

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbvymsB%2FbtrH2gsv2ZF%2FnBP3JQxqmzatmsWEU05Rfk%2Fimg.png)

- TCP 통신을 먼저 진행해서 통로를 생성한 다음에 TLS를 진행한다.

#### Client : Client Hello

- 클라이언트가 서버에서 Client Hello 메시지 전송
- 패킷 내에는 TLS Version, Client가 지원하는 암호화 방식, Client Random Data(클라이언트에서 생성한 난수로 대칭키를 만들 때 사용), Session ID, SNI(서버명) 가 포함된다.
- Session ID
  - 매번 연결할 때마다 Handshake 과정을 진행하는 것은 비효율적이니 최초 한번 전체 Handshake 과정을 진행하고 Session ID를 가진다. 후에는 이 Session ID를 사용해서 위 과정을 반복해서 진행하지 않는다.
  - 최초 Handshake에선 SessionID가 0이지만 Handshake를 한번 진행하면 서버로부터 Session ID를 받는다.
  클라이언트는 로컬에 저장해두고 다시 서버와 Handshake과정을 맺을 일이 있다면 Session ID를 포함한 패킷을 전송한다.
  서버에서는 전달받은 Session ID가 아직 유효하다면 동일한 Session ID를 다시 전송한다.
  이 과정에서 최초 Handshake를 위해 진행한 작업들을 하지 않기 때문에 시간이 절약된다.

#### Server : Server Hello

- 클라이언트가 보낸 Client Hello에 대한 서버의 응답이다.
- TLS Version, 암호화 방식(Client가 보낸 암호화 방식 중에 서버가 사용 가능한 암호화 방식을 선택), Server Random Data(서버에서 생성한 난수, 대칭키를 만들 때 사용), SessionID(유효한 Session ID)

#### Server : Server Certificate

- 서버의 인증서를 클라이언트에게 보내는 단계로 필요에 따라 CA의 Certificate도 함께 전송한다.
  - 클라이언트는 이 패킷을 통해 서버의 인증서가 무결한지 검증한다.

#### Server : Server Hello Done

- 서버가 클라이언트에게 보낼 메시지를 모두 보냈다는 뜻

#### Client : Client Key Exchange

- 인증서가 무결한지 검증 되었으면 클라이언트의 난수와 서버의 난수를 조합하여 대칭키를 생성한다.
- 그리고 대칭키를 서버의 공개키로 암호화한다.
- 암호화한 정보를 서버에게 전송한다.

#### Server & Client : Change Cipher Spec

- 이제부터 전송되는 모든 패킷은 협상된 알고리즘과 키를 이용하여 암호화 하겠다고 알리는 메시지

#### Server & Client : Finished

-   TLS Handshake를 성공적으로 마치고 종료

<hr />

### 인증서 구조

- ROOT, Intermediate(중간인증서), Leaf(서버 인증서) 3단계로 구성된 구성을 인증서 체인(Certificate chain)이라고 한다.
- 이 3개의 인증서 체인은 하위 구조의 인증서를 서명하고 상위 구조의 인증서를 참고하는 방식으로 만들어진다.
- 즉 인증서 체인은 SSL 인증서(서버 인증서)에서 시작하여 ROOT 인증서로 끝나는 인증서 목록으로 구성된다.
  
![](https://blog.kakaocdn.net/dn/pcGEU/btsGGOdkoew/WL24t60hO4wlg6D07AR59K/img.png)

1) ROOT 인증서

- CA(Certificate Authority)에서 자체 서명한 인증서로 공개키 기반의 암호화를 사용한다.
- 모든 유효한 SSL 인증서는 업계에서 보안 리더로 알려진 신뢰할 수 있는 CA가 발행한 루트 CA 인증서 아래 체인에 위치한다.

2) 중간 인증서

- 루트 인증서와 SSL 인증서 사이에 구분을 만들어 위험을 완화하도록 설계된 인증서이다.
- 루트 인증서가 가장 많은 권한을 갖고 보호되어야 하기 때문에 루트 인증서가 손상될 경우를 대비한다.

3) SSL 인증서

- HTTPS 통신을 통해 웹사이트의 컨텐츠가 브라우저에 전송되는 동안 사이트에서 주고받는 모든 데이터를 암호화한다.
- 암호화는 대칭키 암호화 방식과 공개키 암호화 방식을 사용한다.
- SSL 인증서를 통해 클라이언트(브라우저)와 서버 간 통신을 보안화하고 통신 과정에서 발생할 수 있는 스니핑(데이터 엿보기), 피싱(유사 사이트), 데이터 변조 등의 해킹을 방지할 수 있다.

<hr />

### SSL 스트립이란?

- SSL 스트립(SSL Stripping)은 중간자 공격(MitM) 기법의 일종으로, 공격자가 HTTPS 연결을 HTTP로 변환하여 사용자의 데이터 통신을 가로채는 방법을 의미한다.
- Client가 Client Hello Message를 전송 할 때 이를 가로챈 공격자는 자기가 마치 사용자인 것 처럼 Client Hello Message를 Server에게 전달해준다. Server는 Server Hello Message와 서버 인증서를 공격자에게 제공해준다. 이렇게 보안 인증서가 나오기전 사이를 탈취하면서 SSL Strip Attack이 성립된다.
- 사용사 <--HTTP--> 공격자 <--HTTPS--> 서버 형식을 띄게 된다.

1. 사용자 --> 공격자 (사용자가 서버에세 SSL 인증서를 발급받기 위한 절차 수행중)
2. 공격자 --> 서버 ( 그 절차 사이에 끼어들어 자기를 거쳐 가게끔 함)
3. 사용자 <-> 공격자 (HTTP로 통신 진행)
4. 공격자 <-> 서버 (HTTPS로 통신 진행)

<hr />

### DNS Spoofing

- DNS Spoofing 이란 공격 대상에게 전달되는 DNS IP 주소를 조작하거나, DNS Server의 캐시 정보를 조작하여 희생자가 의도하지 않은 주소로 접속하게 만드는 공격이다.
- 이 공격이 가능한 이유는, DNS는 응답이 여러 개 오더라도 가장 먼저 온 응답만 받고, 그 뒤의 응답은 모두 버리기 때문이다.

![](https://velog.velcdn.com/images/younghyun/post/7693baa8-6c2b-4fe6-b790-53f81da27614/image.png)

1. DNS Query 까지는 똑같다.
2. 하지만, DNS프로토콜의 먼저 온 응답만 채택하고, 그 뒤의 응답은 버리는 특징을 이용해서 지리적으로 가까운 공격자가 DNS Server 보다 먼저 DNS Response를 보낸다.
3. 이렇게 되면, DNS Server가 보낸 정상적인 응답은 거절되고, 위조된 DNS Response(해커의 웹 서버 주소)를 받게 된다.
4. 사용자는 위조된 DNS Response에 들어 있는 주소(해커의 웹 서버 주소)로 접속하게 된다.

#### 대응 방안

- hosts파일을 사용하면, 가장 우선적으로 처리 되므로 hosts 파일에 올라간 도메인에 대해서는 DNS 스푸핑 공격을 당하지 않는다.
- BIND(Berkeley Internet Name Domain)를 최신 버전으로 유지

<hr />

### Man-in-the-Middle 공격

- 사이버 보안 위협 중 하나로, 공격자가 두 당사자 간의 통신을 몰래 가로채고, 심지어 수정하거나 조작할 수 있는 상황을 말한다. 
- 이를 통해 공격자는 민감한 정보(예: 로그인 자격증명, 개인 데이터, 금융 정보 등)를 탈취하거나 시스템에 악의적인 영향을 미칠 수 있다.

#### 기술적인 작동 원리

1. 통신 가로채기 : 공격자는 두 당사자 간의 통신 경로에 끼어들어 데이터를 가로챈다. 이는 주로 공개된 Wi-Fi 네트워크나 취약한 네트워크를 통해 이루어진다.
2. 데이터 도청 및 수정 : 가로챈 데이터를 분석하거나, 필요에 따라 데이터를 수정할 수 있다. 예를 들어, 사용자가 서버에 로그인하려고 할 때, 공격자는 로그인 정보를 탈취할 수 있다.
3. 인증 우회 : 공격자는 중간에서 통신을 중계하면서 자신을 서버나 클라이언트로 가장할 수 있다. 이를 통해 사용자는 공격자가 신뢰할 수 있는 당사자로 오인하게 된다.

#### 방어 방법

- 암호화 사용(HTTPS) : 모든 통신을 HTTPS로 암호화하여 데이터가 전송 중에 가로채이더라도 내용을 해독하기 어렵게 만든다. Spring Boot에서는 SSL/TLS 설정을 통해 쉽게 HTTPS를 구현할 수 있다.
- 강력한 인증 및 권한 부여 : OAuth, JWT와 같은 강력한 인증방식을 사용하여 사용자와 서버 간의 신뢰성을 높인다.
- 인증서 검증 : 클라이언트와 서버가 서로의 인증서를 검증하도록 설정하여, 중간에서의 인증서 위조를 방지한다.
- 최신 보안 패치 적용 : 사용 중인 라이브러리와 프레임워크의 보안 패치를 최신 상태로 유지하여 알려진 취약점을 악용한 공격을 방지한다.
- 보안 헤더 사용 : Spring Security를 활용하여 HTTP 보안 헤더를 설정함으로써 다양한 공격 벡터를 줄일 수 있다.
- 네트워크 보안 강화 : 방화벽, 침입 탐지 시스템(IDS), 침입 방지 시스템(IPS) 등을 활용하여 네트워크 수준에서의 공격을 탐지하고 차단한다.
