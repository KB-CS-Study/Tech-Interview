### TCP, UDP 특징

- TCP와 UDP란?
    - 데이터를 전송하기 위한 전송 계층(Transport Layer) 프로토콜
    - TCP는 신뢰성을 보장하며, UDP는 지연 최소화와 전송 속도를 중시
    - 데이터를 목적지로 보내기 위한 `포트 기반 통신`을 제공

### TCP VS UDP

| 프로토콜 종류 | TCP                      | UDP                             |
|---------------|---------------------------|----------------------------------|
| 연결 방식     | 연결형 서비스 (패킷 교환 방식) | 비연결형 서비스 (데이터그램 방식) |
| 전송 순서     | 전송 순서 보장            | 전송 순서가 바뀔 수 있음        |
| 수신 여부 확인 | O                         | X                                |
| 통신 방식     | 1:1 통신                  | 1:1 / 1:N / N:N 통신 가능       |
| 신뢰성        | 높음                      | 낮음                             |
| 속도          | 느림                      | 빠름                             |
- 수신 여부 확인(ACK) : TCP는 수신 여부를 확인하는 반면, UDP는 수신 실패 여부 조차 알지 못함
- 통신 방식 : UDP의 멀티캐스트/브로드캐스트는 일부 네트워크에서 제한될 수 있다

**관련 프로토콜 예시**

| **프로토콜** | **설명** | **사용 계층** | **기반** |
| --- | --- | --- | --- |
| HTTP/HTTPS | 웹 통신 | 애플리케이션 | TCP |
| FTP | 파일 전송 | 애플리케이션 | TCP |
| DNS | 도메인 → IP 변환 | 애플리케이션 | UDP |
| DHCP | IP 자동 할당 | 애플리케이션 | UDP |
| VoIP, 게임 | 실시간 데이터 전송 | 애플리케이션 | UDP |

## 1) TCP

- TCP에만 연결(Connection, Session) 개념이 있다.
- 연결은 결과적으로 순서번호(Sequence Number)로 구현된다
- 연결은 상태(전이) 개념을 동반한다

- **3-Way Handshake(연결 성립)**

> 데이터를 안전하게 보내기 전에, 양쪽이 신뢰할 수 있는 연결을 형성하기 위한 절차
>

![image](https://github.com/user-attachments/assets/8f09f1f0-48b9-414b-8c21-84d54978e2d6)

1. Client → Server : SYN 패킷을 보냄 `(연결 요청)`
2. Server : SYN 패킷을 받고, Client에게 패킷을 받았다는 신호인 ACK + SYN 패킷을 함께 보냄 `(요청 수락 및 응답)`
3. Client는 ACK(X+1)와 SYN 패킷을 받고 ACK(y+1)를 Server로 보냄 `(연결 확인)`

- TCP는 정확한 전송을 보장해야하기 때문에 통신하기 앞서, 논리적인 접속을 성립하기 위해 `3 way handshake` 과정을 진행한다
- 이 과정을 통해 양쪽 모두 연결 상태를 동기화 하고, 초기 순서 번호를 설정

- **4-Way Handshake(연결 해제)**

> 데이터를 모두 주고 받은 뒤, 연결을 정상적으로 종료하는 절차
>

![image](https://github.com/user-attachments/assets/6847d60a-769b-4204-8b8a-5c5481f7d1ed)



1. Client는 Server에게 연결을 종료한다는 FIN 플래그 + ACK를 보낸다 `(연결 종료 요청)`
2. Server는 FIN을 확인했다는 ACK를 Client에게 보낸다 `(요청 수락, CLOSE_WAIT 상태 진입)`
    - 이때, 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다
3. 데이터를 모두 보냈다면 연결이 종료 되었다는 FIN + ACK를 Client에 보낸다 `(서버 측 종료 요청)`
4. Client는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다 `(응답, TIME_WAIT 상태 진입 후 종료)`
    - 아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT를 통해 기다린다
5. Server는 ACK를 받은 이후 소켓을 닫는다 (close)
6. TIME_WAIT 시간이 끝나면 Client도 소켓을 닫는다(close)
- 연결 성립 후, 모든 통신이 끝났다면 해제를 해줘야한다

### 1-1) TCP의 신뢰성 보장 메커니즘 : Sequence Number, ACK, 재전송, 타이머 등

| **항목** | **설명** |
| --- | --- |
| **Sequence Number** | 데이터의 순서 식별. 손실되었을 경우 재전송 범위 결정에 사용 |
| **ACK** | 수신 확인 응답. 다음에 수신할 Sequence Number를 의미 |
| **Retransmission** | ACK 응답이 없을 경우 일정 시간 후 해당 데이터 재전송 |
| **Timer** | 특정 시간 내 ACK가 도착하지 않으면 Timeout 발생 |

### 1-2) TCP의 흐름 제어 (Flow Control) : 슬라이딩 윈도우

- 흐름 제어
    - 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법
        - 송신측의 속도가 수신측의 속도보다 빠를 경우 문제가 생긴다
        - 수신측의 제한된 저장 용량을 초과한 이후에 도착하는 데이터는 손실 될 수 있다
        - 만약 손실 된다면 불필요하게 응답과 데이터 전송이 송/수신 측 간에 빈번히 발생한다
        - 이러한 위험을 줄이기 위해 송신 측의 데이터 전송량을 수신측에 따라 조절해야한다
    - Flow Control은 receiver가 sender에게 현재 자신의 상태를 feedback 한다
    - 해결 방법 : Stop and Wait, Sliding Window(Go back N ARQ)
- Stop and Wait
    - 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법
- 슬라이딩 윈도우
    - 수신 측에서 처리 가능한 만큼만 데이터 전송을 허용, 수신자의 버퍼 오버플로우를 방지 하기 위함
    - 수신 측에서 설정한 윈도우 크기 만큼 송신측에서 확인 응답없이 Segment를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법
    - 동작 방식 : 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는 대로 이 윈도우를 옆으로 옮김으로써 그 다음 패킷을 전송
- Window size 변화
    - TCP/IP를 사용하는 모든 호스트들은 송신하기 위한 것과 수신하기 위한 2개의 Window를 가지고 있다.
    - 호스트들은 실제 데이터를 보내기 전에 3 way handshaking을 통해 수신 호스트의 receive window size에 자신의 send window size를 맞추겍 된다

### 1-3) TCP의 혼잡 제어 (Congestion Control) : AIMD, Slow Start

- 혼잡 제어
    - 송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법
    - `혼잡` : 네트워크 내에 패킷의 수가 과도하게 증가하는 현상
    - `혼잡 제어` : 혼잡 현상을 방지하거나 제거하는 기능
- AIMD (Additive Increase Multiplicative Decrease)
    - 처음 패킷을 하나씩 보내고 이것이 문제 없이 도착하면 `window 크기`를 1씩 증가시켜가며 전송하는 방법
        - window 크기 : 단위 시간 내에 보내는 패킷의 수
- Slow Start
    - AMID 방식이 네트워크 수용량 주변에서는 효율적으로 작동하지만, 처음에 전송 속도를 올리는데 시간이 오래 걸리는 단점이 존재
    - AMID 방식과 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제 없이 도착하면 각각의 ACK 패킷마다 window size를 1씩 늘려준다.
        - 즉, 한 주기가 지나면 window size가 2배가 된다
    - AMID와 차이점
        - AMID에 반해 전송 속도가 지수 함수 꼴로 증가한다
        - 대신 혼잡 현상이 발생하면 window size를 1로 떨어뜨리게 된다
- Fast Retransmit(빠른 재전송)
    - 빠른 재전송은 TCP의 혼잡 조절에 추가된 정책
- Fast Recovery
    - 혼잡 상태가 되면 window size를 줄이지 않고 반으로 줄이고 선형 증가시키는 방법


| **구분** | **흐름 제어 (Flow Control)** | **혼잡 제어 (Congestion Control)** |
| --- | --- | --- |
| 목적 | 수신 측 버퍼 초과 방지 | 네트워크 혼잡 방지 |
| 대상 | 수신자 | 네트워크 전체 |
| 기법 | Sliding Window 등 | AIMD, Slow Start 등 |
| 제어 기준 | 수신자의 처리 속도 | 네트워크의 혼잡 상태 |

## 2) UDP

- UDP를 사용하는 이유?
    - 데이터처리가 TCP보다 빠르기 때문이다
    - 실시간 방송과 온라인 게임에서 사용되며, 네트워크 환경이 안좋을 때 끊기는 현상
    - 한 두개 패킷이 손실돼도 무방한 상황에 적합
- 사용 사례
    - DNS : 응답 시간이 짧고, 단순 요청/응답만으로 구성
    - VoIP, Zoom 통화 : 약간의 손실보다는 지연 없는 전송이 중요하기 때문

### 2-1) UDP가 흐름/혼잡 제어를 하지 않는 이유

- 빠른 속도와 단순한 구조를 위해 흐름 제어 기능 생략
- 대신 애플리케이션 자체적으로 처리하거나 오류를 감수함
    - 비연결형 서비스
    - 순서 보장 없음
    - 오류 처리 없음
    - 빠르고 가벼운 통신
- TCP 대비 생략된 기능

| **기능** | **TCP** | **UDP** |
| --- | --- | --- |
| 연결 설정 (3-Way Handshake) | O | ❌ |
| 흐름 제어 (Flow Control) | O | ❌ |
| 혼잡 제어 (Congestion Control) | O | ❌ |
| 오류 복구 (재전송 등) | O | ❌ |
| 순서 보장 | O | ❌ |
- 대신 **응용 프로그램이 직접** 오류 처리, 순서 정렬 등을 담당

### 2-2) DHCP (UDP와 관련)

- Dynamic Host Configuration Protocol
- 주소를 할당하는 서버와 할당 받으려는 클라이언트로 구성된다
- 복잡한 인터넷 설정을 자동으로 해준다고 볼 수 있는데 핵심은 내가 사용할 IP 주소를 서버가 알려준다는 것에 있다.
- 역할 : 사용자의 디바이스가 **자동으로 IP 주소, 서브넷 마스크, 게이트웨이, DNS** 등을 할당받게 함
- **작동 흐름 (UDP 사용)**
    1. **DHCP Discover** – 클라이언트 → 브로드캐스트
    2. **DHCP Offer** – 서버 → IP 제안
    3. **DHCP Request** – 클라이언트 → 제안 수락 요청
    4. **DHCP ACK** – 서버 → 최종 확정
- DHCP는 서버가 누군지 모르는 상태에서 브로드캐스트로 요청을 보내므로 비연결형 UDP가 적합함

### 멀티플렉싱과 디멀티플렉싱(포트 번호와 TCP/UDP 연결)

- 멀티 플렉싱(Multiplexing)
    - 송신 측에서 여러 애플리케이션의 데이터를 하나의 전송 경로로 통합
    - 각 데이터에는 출발지 포트 번호를 부여
- 디멀티플렉싱(Demultiplexing)
    - 수신 측에서 들어온 데이터의 포트 번호를 기준으로 각 애플리케이션에 전달
    - OS는 포트 번호를 기반으로 수신된 데이터를 해당 애플리케이션에게 전달

- 멀티 플렉싱/디멀티플렉싱은 IP + 포트 번호 조합(소켓)을 기반으로 작동하며, 동일한 IP 주소 내에서도 다수의 애플리케이션 간 데이터 흐름을 구분해줌

| **상황** | **TCP** | **UDP** |
| --- | --- | --- |
| 웹 접속 (HTTP/HTTPS) | O | ❌ |
| 실시간 게임 | ❌ | O |
| 메일 전송 (SMTP) | O | ❌ |
| IP 자동 할당 (DHCP) | ❌ | O |
| 영상 스트리밍 | ❌ | O |

### 백엔드 개발자가 네트워크(TCP/UDP)를 알아야하는 이유

- 백엔드는 보통 클라이언트와 통신하는 API 서버, DB 서버, 외부 서비스 등과 연결되어있다.
- 이 모든 통신은 TCP or UDP위에서 작동하는 프로토콜로 이루어지기 때문이다
    - HTTP → TCP기반, Redis → TCP 기반, 게임 서버 → UDP 기반
    - 왜 연결이 안될까? 왜 패킷이 유실됐을까? 같은 문제를 해결하려면 TCP/UDP 동작 원리를 이해해야 한다
- 요청이 느릴 경우 (장애 분석) “서버가 느리다” 막연한 진단만 하지말고 원인을 알아야한다
    - TCP Handshake 지연
    - Retransmission 반복
    - Congestion Control 때문
- 보안 연결(TLS/SSL)은 TCP 연결 후 암호화 handshake를 추가로 수행함
    - 왜 443포트에서만 HTTPS가 되는지
        - 보안 통신(TLS/SSL)을 처리하는 서버는 443 포트로 들어오는 요청만 **암호화 처리**
    - SYN Flood 같은 공격이 무엇인지
        - **악성 클라이언트가 SYN만 보내고 ACK를 안 보내는 공격**
    - TIME_WAIT가 쌓이면 서버가 왜 느려지는지
        - TCP 연결 종료 후 TIME_WAIT 상태로 일정 시간이 유지되는데 이때 포트를 잠시 점유한다. 이로 인해 대규모 연결이 필요한 서버에서는 포트 고갈로 성능 저하가 발생할 수 있다.
- 실시간 알림/스트리밍 서비스 개발 시 WebSocket처럼 지속적 연결을 유지해야 한다
- 이런 연결 방식은 TCP의 연결 관리, 패킷 손실 대응 개념이 뒷받침 되어야 한다


### 💡 면접 질문 리스트
<details>
  <summary>Q.TIME_WAIT가 쌓이면 서버가 왜 느려지나요?</summary>
  TCP 연결 종료 후 TIME_WAIT 상태로 일정 시간이 유지되는데 이때 포트를 잠시 점유합니다. 이로 인해 대규모 연결이 필요한 서버에서는 포트 고갈로 성능 저하가 발생할 수 있기 때문입니다.
</details>

<details>
  <summary>Q.왜 HTTP는 TCP를 사용하나요?</summary>
  HTTP는 신뢰성 있는 데이터를 보장해야하기 때문에 TCP에서 동작합니다. 특히 웹 페이지처럼 텍스트나 이미지 등 정확한 데이터 전달이 중요할 경우, 손실 없는 전송이 필요하기 때문입니다.
하지만 HTTP 버전에 따라서 전송 방식이 조금 다릅니다. 기존 HTTP/1.1과 HTTP/2는 TCP를 사용하지만, HTTP/3부터는 더 빠른 연결과 멀티 스트림 처리를 위해 UDP 기반의 QUIC 프로토콜을 사용합니다
</details>

<details>
  <summary>Q.DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?</summary>
  단순히 IP 주소만 주는 게 아니라, 네트워크 통신에 필요한 다양한 설정 정보도 함께 제공합니다.
예를 들어, 서브넷 마스크, 기본 게이트웨이, DNS 서버 주소, IP 임대 기간 등을 같이 전달합니다.
</details>
