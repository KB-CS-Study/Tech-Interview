# TCP&UDP / 흐름 제어, 혼잡 제어

**목차**
- [🔄 TCP](#-tcp)
  - [🍀 신뢰 보장 메커니즘](#-신뢰-보장-메커니즘)
  - [🍀 혼잡 제어(Congestion Control)](#-혼잡-제어congestion-control)
  - [🍀 흐름 제어(Flow-Control)](#-흐름-제어flow-control)
  - [🍀 오류 제어(Error Control)](#-오류-제어error-control)
- [↪️ UDP](#-udp)
  - [🍊 DHCP(Dynamic Host Configuration Protocol)](#-dhcpdynamic-host-configuration-protocol)
- [🔀 멀티플렉싱/디멀티플렉싱](#-멀티플렉싱디멀티플렉싱)
  - [멀티플렉싱 (Multiplexing)](#멀티플렉싱-multiplexing)
  - [디멀티플렉싱 (Demultiplexing)](#디멀티플렉싱-demultiplexing)
<br>

## 🔄 TCP

- Transmission Control Protocol / 연결 지향형
- **신뢰성 있는 데이터 전송**을 보장하는 전송(**4**)계층 프로토콜
![image](https://github.com/user-attachments/assets/21531881-0174-4660-950c-09795988e000)


<br>

### 🍀 신뢰 보장 메커니즘

**3-Way Handshake**

![image](https://github.com/user-attachments/assets/b4270398-0aee-4f00-ae41-600b9d957d26)


**1단계**

1. 클라이언트 측 TCP는 서버 TCP에게 특별한 TCP 세그먼트, `SYN 세그먼트`를 송신한다.
    - 애플리케이션 계층 데이터를 포함하지 않는다.
    - 세그먼트 헤더에 `SYN 비트`를 **1**로 설정한다.
2. 클라이언트는 최소 순서 번호(`client_isn`)를 임의로 선택하고, 최초의 TCP SYN 세그먼트의 `순서 번호 필드`에 이 번호를 넣는다.
3. 이 세그먼트는 IP 데이터그램 안에서 캡슐화되고 서버로 송신된다.

**2단계**

TCP SYN 세그먼트를 포함하는 `IP 데이터그램`이 서버 호스트에 도착하면,

1. 서버는 데이터그램으로부터 TCP SYN 세그먼트를 추출한다.
2. 연결에 TCP 버퍼와 변수를 할당한다.
3. 클라이언트 TCP로 **연결 승인 세그먼트,** `SYNACK 세그먼트`를 송신한다.
    - 애플리케이션 계층 데이터를 포함하지 않는다.
    - `SYN 비트`는 **1**로 설정된다.
    - TCP 세그먼트 헤더의 `확인응답 필드`는 `client_isn+1`로 설정된다.
    - 서버는 자신의 최초의 순서 번호(`server_isn`)를 선택하고, TCP 세그먼트 헤더의 `순서 번호 필드`에 이 값을 넣는다.
    

**3단계**

연결 승인 세그먼트를 수신하면,

1. 클라이언트는 연결에 버퍼와 변수를 할당한다.
2. 클라이언트 호스트는 서버로 **또 다른 세그먼트**를 송신한다.
    1. 클라이언트는 TCP 세그먼트 헤더의 `확인응답 필드` 안에 `server_isn+1` 값을 넣어, 서버의 연결 승인 세그먼트를 확인한다.
    2. 연결이 설정되었기 때문에 `SYN 비트`는 **0**으로 설정된다.

<br>

**순서 번호와 확인응답 번호**

**순서 번호**

- TCP는 데이터를 순서대로 정렬되어있는 바이트 스트림으로 본다.
- 세그먼트 순서 번호 == 세그먼트에 있는 첫번째 바이트의 스트림 번호
- 각각의 순서 번호는 TCP 세그먼트의 헤더 내부 순서 번호 필드에 삽입

![image](https://github.com/user-attachments/assets/97678243-5117-4686-a711-51c01d0e0289)


**확인 응답 번호(ACK)**

- TCP는 **전이중 방식**
    - (호스트 A가 호스트 B로 데이터를 송신하는 **동안에** 호스트 B로부터 데이터를 수신하게 해줌)
![image](https://github.com/user-attachments/assets/e7baf205-c11e-49bd-be37-7346cf94d785)


- Seq : 시퀀스 번호, TCP 세그먼트의 시작 바이트 번호
- ACK : 확인 응답 번호, 다음에 기대하는 바이트 번호

<br>

**재전송(Retransmission)**

- AKC(확인 응답)을 받지 못하면 데이터가 손실되었다고 판단 → 재전송 수행
1. 타임아웃 기반 재전송
    1. RTO : ACK가 도착할 때까지 기다리는 타이머
    2. RTT(왕복시간)에 따라 동적 조절
2. 중복 ACK 기반 재전송
    1. 수신자가 같은 ACK번호를 N번 이상 연속 전송 → 송신자가 유실 판단

<br>

### 🍀 혼잡 제어(Congestion Control)

**❓ 목적:**

네트워크 전체의 **혼잡 상태를 완화**하거나 방지하는 것

**💡 예시 상황:**

여러 송신자가 동시에 데이터를 보내면서 네트워크 중간 장비(라우터 등)에 **패킷이 몰려 혼잡**이 발생할 수 있음

**✅ TCP에서의 대표적인 혼잡 제어 알고리즘:**

1. **Slow Start**: 처음엔 천천히 시작해서 혼잡 여부 확인 후 속도 증가
2. **Congestion Avoidance**: 혼잡신호 감지 시 속도 점진적 증가
3. **Fast Retransmit / Fast Recovery**: 패킷 유실 시 혼잡으로 판단하고 윈도우 크기 감소

<br>

### 🍀 흐름 제어(Flow Control)

**❓ 목적:**
수신자가 **데이터를 너무 빠르게 받지 않도록** 송신자가 속도를 조절하는 기법

**💡 예시 상황:**
수신자의 수신 버퍼가 작아서 데이터를 다 처리하지 못하는 경우 → **버퍼 오버플로우** 발생

**✅ TCP에서의 구현 방식: 슬라이딩 윈도우(Sliding Window)**

- 수신자는 `Window Size` 값을 송신자에게 고지
- 송신자는 그 범위 내에서만 데이터 전송
- ACK를 받으면 윈도우가 슬라이딩하면서 새 데이터 전송

<br>

### 🍀 오류 제어(Error Control)

**❓ 목적:**

**전송 도중 발생한 에러**를 탐지하고 복구하는 것

**💡 예시 상황:**

패킷 전송 중 비트가 바뀌거나 손실되는 경우

**✅ 방법:**

- **에러 탐지 (Detection)**: Checksum, CRC, Parity Bit 등으로 오류 감지
- **에러 정정 (Correction)**:
    - **ARQ (Automatic Repeat Request)**: 수신 측이 에러 발생 시 재전송 요청 (TCP 사용)
    - **FEC (Forward Error Correction)**: 송신 측이 미리 정정 가능한 코드 전송 (실시간 스트리밍 등에서 사용)

<br>

## ↪️ UDP

- 비연결형, 비신뢰성 기반 전송(4)계층 프로토콜
- 빠른 속도와 간단한 구조

**장점**

: **무슨 데이터를 언제 보낼지에 대해서 애플리케이션 레벨에서 더 정교한 제어가 가능.**

: **연결을 설정하기 위한 어떤 지연도 없다**.

**단점**

**: 혼잡 제어 없음**

**UDP 체크섬**

세그먼트가 출발지로부터 목적지로 이동했을 때, **UDP 세그먼트 안의 비트에 대한 변경사항이 있는지 검사**하여 오류 검출을 하기 위한 것

<br>

### 🍊 DHCP(Dynamic Host Configuration Protocol)

- 네트워크에 접속하는 장치에게 **자동으로 IP 주소와 네트워크 설정을 할당해주는 프로토콜**

**DHCP 동작 과정: DORA 과정**

1️⃣ Discover : 클라이언트가 브로드캐스트로 DHCP 서버 찾기

2️⃣ Offer : 서버가 IP 주소 제안

3️⃣ Request : 클라이언트가 그 IP를 사용하겠다고 요청

4️⃣ Acknowledgment : 서버가 요청 수락, 설정 정보 전달

![image](https://github.com/user-attachments/assets/a69868ef-d775-4255-b975-d1ec7d7c7669)


<br>

## 🔀 멀티플렉싱/디멀티플렉싱

전송 계층(TCP/UDP)에서 **포트 번호를 통해 여러 응용 프로그램을 구분하고 처리**하는 핵심 원리

### 멀티플렉싱 (Multiplexing)

송신 측

- **여러 개의 애플리케이션(프로세스)의 데이터를 하나의 네트워크 연결에 실어 보내는 과정**
- 즉, **한 컴퓨터 안의 여러 프로그램이 동시에 데이터를 전송**할 수 있도록 하는 기술!
    - 같은 IP에서 출발해도 포트 번호가 다르기 때문에 **구분 가능**

### 디멀티플렉싱 (Demultiplexing)

수신 측

- **받은 데이터의 포트 번호를 기준으로, 어떤 애플리케이션으로 전달할지 결정하는 과정**
    - 수신자가 패킷을 받으면, 전송 계층이 **목적지 포트 번호**를 확인
    - 해당 포트에 연결된 **응용 프로세스에 데이터 전달**
![image](https://github.com/user-attachments/assets/e7712924-02ee-4ede-9f87-3d0c6de7c83c)
