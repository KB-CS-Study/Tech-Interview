# TCP & UDP

데이터를 전송하기 위해 사용하는 프로토콜

## TCP

- 전송 제어 프로토콜
- 연결형 서비스 :  데이터를 보내기 전에 **3-way** 핸드셰이크를 통해 연결을 설정
- 신뢰성 O : 데이터를 정확하게, 빠짐없이, 순서대로 전달
- 순서를 보장하는 데이터 전달
- 혼잡 제어 : 네트워크에 과부하가 걸리지 않도록 전송 속도를 자동으로 조절
- 흐름 제어 : 송신자가 수신자의 처리 속도를 초과하여 데이터를 보내는 것을 방지

## UDP

- 사용자 데이터그램 프로토콜
- 신뢰성 X → 아무것도 보장하지 않음
    - 데이터 손실 발생 가능
    - 데이터의 순서가 뒤바뀔 수 있음
- 비연결형 서비스 → 데이터를 주고받을 때 연결 절차를 거치지 않음.
    - 데이터를 보내기 전에 delay 발생 X
- 에러 체크는 하지만 복구는 하지 않음
- 적용 서비스 : 신뢰성보다 연속성이 중요한 서비스

### ❓ 왜 UDP를 사용할까?

- 연결 설정이 없음
    
    → 연결 설정 과정이 없기 때문에 지연을 줄일 수 있음
    
- 단순함
    
    → 송신자와 수신자가 연결 상태 정보를 유지할 필요 없음
    
- 헤더 크기가 작음
    
    → 오버헤드가 적어 빠르게 처리 가능
    
- 혼잡 제어가 없음
    
    → 네트워크 상태에 관계없이 제한 없이 빠르게 전송 가능
    

즉, UDP는 빠르고 단순한 데이터 전송을 목표로 설계되었기 때문에 흐름 제어나 혼잡 제어와 같은 복잡한 기능은 제외되었으며, 필요한 경우 응용 프로그램 단계에서 직접 구현해야 한다.

## TCP VS UDP
| 항목 | **TCP (Transmission Control Protocol)** | **UDP (User Datagram Protocol)** |
| --- | --- | --- |
| **연결 방식** | 연결 지향 (Connection-oriented) | 비연결 지향 (Connectionless) |
| **신뢰성** | 보장 (손실 시 재전송, 순서 보장) | 보장하지 않음 (순서 뒤바뀌거나 손실될 수 있음) |
| **흐름 제어** | 있음 | 없음 |
| **혼잡 제어** | 있음 | 없음 |
| **속도** | 상대적으로 느림 (오버헤드 큼) | 빠름 (단순한 구조) |
| **헤더 크기** | 크다 (20바이트 이상) | 작다 (8바이트) |
| **사용 예시** | HTTP, HTTPS, FTP, SMTP 등 | DNS, DHCP, VoIP, 스트리밍 등 |
| **재전송** | O (패킷 손실 시 자동 재전송) | X (수신 실패 시 버림) |


# TCP의 신뢰성 보장 메커니즘

## 시퀀스 번호(Sequence number)

- 각 바이트에 고유한 번호를 붙여, 데이터의 순서 보장에 사용
- 송신자는 세그먼트의 첫 번째 바이트 번호를 지정하고 전송
- 수신자는 시퀀스 번호를 통해 정확한 순서로 데이터 재조립 가능

## **확인 응답 (ACK, Acknowledgment)**

- 수신자는 **정상적으로 받은 마지막 바이트 다음 번호**를 ACK로 응답
- 즉, `ACK 1500` → 1000~1499 바이트를 잘 받았고, **1500번 바이트부터 달라**는 의미
- TCP는 누락된 세그먼트가 있으면 중복 **ACK**을 보내거나, 응답을 생략해서 송신자가 재전송을 유도함

## **재전송 (Retransmission)**

TCP는 세그먼트가 손실되거나 ACK가 오지 않으면 자동으로 해당 세그먼트를 재전송한다.

재전송을 유발하는 조건:

- 타이머 만료 (Timeout)
- 중복 ACK 3회 수신 (Fast Retransmit)
    
     ※ fast retransmit: 수신자가 동일한 ACK(예: ACK 1000)을 연속 3번 이상 보낼 경우, 송신자는 세그먼트 손실로 판단하고 바로 재전송
    

## **타이머 (Retransmission Timer)**

- 각 전송에 대해 **타이머를 설정**하고, 해당 세그먼트에 대한 ACK를 일정 시간 안에 못 받으면 재전송
- 타이머는 네트워크 상황에 따라 RTT(Round Trip Time)을 기반으로 동적으로 조정됨

## TCP의 시작 과정 : 3-way handshaking
![Image](https://github.com/user-attachments/assets/1a9e1ec4-a30a-4b69-920a-060293700d28)

1. 송신자 : 연결을 맺자고 요청하는 SYN 패킷을 보냄
2. 수신자 : 송신자의 요청을 승인하는 SYN+ACK 패킷을 보냄
3. 송신자 : 수신자의 승인 패킷을 확인했다는 의미로 ACK 패킷을 보냄

## TCP 데이터 전송 : 2-way 방식
![Image](https://github.com/user-attachments/assets/e07c768b-bd4f-4777-a157-4ebc3cc6f9a3)

흐름제어(Flow Control) : 수신자의 ACK 패킷을 송신자가 일정 시간 못받은 경우
- 송신자는 수신자에게 다시 메시지를 재전송
- TCP 헤더 정보를 이용, 슬라이딩 윈도우(Sliding Window) 기법으로 처리

## TCP connection 끊기 : 4-way 방식
![Image](https://github.com/user-attachments/assets/43295aca-eaf0-4f98-97e5-4c11408595e6)

1. 송신자 : 수신자에게 연결을 끊고자 FIN 패킷을 보냄
2. 수신자 : ACK 패킷을 보냄 - 종료 요청에 대한 확인
3. 수신자 : FIN 패킷을 보냄 - 자신도 연결 종료를 요청하는 것
4. 송신자 : 수신자의 종료 패킷에 대한 확인으로 ACK 패킷을 보냄

# TCP의 흐름 제어(Flow Control)

## 흐름 제어란?

- 송신자가 수신자의 처리 능력보다 많은 데이터를 보내는 것을 방지하기 위한 메커니즘
- 수신 측 버퍼 오버플로우 방지 → 수신자가 처리할 수 있는 속도만큼만 전송

## 슬라이딩 윈도우(Sliding Window) 기법

### 기본 개념

수신자는 자신이 한 번에 수신 가능한 데이터의 크기를 윈도우 크기(Window Size)로 알려줌.

송신자는 이 크기만큼 데이터를 보낼 수 있으며, ACK(확인 응답)를 받으면 윈도우를 앞으로 슬라이딩하면서 다음 데이터를 전송.

### 동작 방식 예시

1. 수신자는 `Window Size = 500` 바이트라고 알림
2. 송신자는 0~499 바이트까지 전송
3. 수신자는 0~99 바이트까지 받고 ACK(100) 보냄
4. 송신자는 윈도우를 앞으로 슬라이드하고 500바이트 범위 내에서 다음 데이터 전송

### 동적 윈도우 조절

- 수신 측은 버퍼가 부족하면 윈도우 크기를 줄이고, 버퍼가 비워지면 다시 늘림.
- 윈도우 크기를 0으로 설정해 전송 일시 중지 요청 가능

# TCP의 혼잡 제어(Congestion Control)

## 혼잡 제어란?

- 네트워크가 과도한 트래픽으로 인해 혼잡 상태에 빠지지 않도록 전송 속도를 조절하는 기법
- 네트워크 부하를 적절히 조절하여 패킷 손실 최소화와 전송 효율 향상

## Slow Start

초기 전송 속도를 급격히 늘리되, 안전하게 시작하는 방식

- 시작 시점:
    
    TCP 연결 직후 or 패킷 손실 후 재시작
    
- 동작 방식:
    - 시작 시 **cwnd = 1 MSS (Maximum Segment Size)**
    - 매 ACK 수신마다 cwnd를 1 MSS씩 증가 → 결과적으로 지수적으로 증가
- 지속 조건:
    
    cwnd가 임계값(sshtresh)에 도달하면 **A**IMD 단계로 전환
    
- 예시:
    - cwnd = 1, 2, 4, 8, 16, 32... (ACK마다 2배로 증가)
    - 매우 빠르게 전송 속도를 키우지만, 과도한 전송으로 혼잡이 발생할 수 있기 때문에 제한 필요

## **AIMD**

혼잡을 감지하며 천천히 증가하고, 급격히 감소

### Additive Increase (선형 증가)

- 혼잡이 감지되지 않는 경우:
    
    → cwnd를 매 RTT마다 **1 MSS**만큼 증가
    
    → 선형적으로 천천히 증가
    

### Multiplicative Decrease (감소)

- 패킷 손실 등 혼잡 감지 시:
    
    → cwnd를 절반으로 감소 **(cwnd = cwnd / 2)**
    
    → 네트워크에 더 이상 과부하를 주지 않기 위해 급격히 줄임
    

### Slow Start + AIMD 통합 동작 흐름

1. 연결 시작 → Slow Start로 시작 (지수 증가)
2. cwnd가 **ssthresh** 도달 → AIMD로 전환 (선형 증가)
3. 패킷 손실 발생 → **Multiplicative Decrease**, cwnd 절반으로 줄임
4. **ssthresh = cwnd / 2**로 재설정하고, 다시 Slow Start or AIMD 시작

# DHCP

네트워크에 연결된 장치(클라이언트)에게 자동으로 IP 주소 및 기타 네트워크 설정을 제공하는 프로토콜

## DHCP가 제공하는 정보

- IP 주소
- 서브넷 마스크
- 기본 게이트웨이(Gateway)
- DNS 서버 주소

## DHCP 동작 과정

1. Discover : 클라이언트가 브로드캐스트로 DHCP 서버 탐색 (Who can give me IP?)
2. Offer : DHCP 서버가 IP 등 설정 정보를 제안
3. Request : 클라이언트가 특정 서버의 제안을 수락하겠다고 알림
4. Acknowledgment : DHCP 서버가 설정 정보를 확정해서 클라이언트에 전달

❓ DHCP가 UDP를 사용하는 이유

DHCP는 IP 주소가 없거나 갓 부여받은 클라이언트와 통신해야 하는데 TCP는 연결 지향적이므로 IP 없이는 연결이 불가능하다.

# Multiplexing & Demultiplexing

전송 계층에서 제공하는 기본적인 기능

※ 소켓 : 전송 계층과 응용 계층 사이를 연결하는 통로

![Image](https://github.com/user-attachments/assets/f28eaa6b-0090-499f-9db0-78d28686a7ab)

## **Multiplexing**

- 송신 측 전송 계층에서 수행되는 과정으로, 여러 응용 프로그램의 데이터를 하나의 전송 계층 연결에 실어서 전송하는 것
    
    → 여러 소켓을 통해 전달된 여러 개의 데이터를 모아 더 큰 형태로 만들고, 전송 계층의 헤더를 붙여서 네트워크 계층으로 전달한다.
    

## Demultiplexing

- 수신 측 전송 계층에서 수행되는 과정으로, 수신된 데이터를 분리해서 올바른 응용 프로그램으로 전달하는 것
    
    →  하나의 수신 포트로 들어온 세그먼트의 헤더 정보를 분석해서 해당 세그먼트를 적절한 소켓으로 분배한다.
    

## **Connection-oriented Multiplexing**

- TCP 기반
- 송신 측에서 각 응용 프로그램은 고유한 소켓(소스 IP, 소스 포트, 목적지 IP, 목적지 포트)을 통해 연결을 설정함
- 수신 측에서는 이 4가지 정보를 모두 활용해 각 연결을 식별하고, 해당 소켓(응용 프로그램)으로 전달함
- 연결을 설정한 후 통신이 이루어지므로, 신뢰성이 높고 정확한 데이터 전달이 가능

## **Connectionless Multiplexing**

- UDP 기반
- 연결 없이 데이터를 전송하며, 송신자는 포트 번호만 설정하고 곧바로 데이터 전송
- 수신 측은 도착한 데이터그램의 목적지 포트 번호만 보고 어떤 응용 프로그램에 전달할지를 결정
- 포트 번호만으로 소켓을 식별하기 때문에 간단하지만, 송수신 상태를 추적하지 않아 신뢰성이 낮음