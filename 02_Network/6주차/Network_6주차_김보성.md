## ✅ 1. TCP와 UDP

### 🔹 TCP (Transmission Control Protocol)

- 연결 지향형 (Connection-oriented)
- 신뢰성 보장 (데이터 손실/중복/순서 보장)
- 3-Way Handshake로 연결 수립
- 흐름 제어(Flow Control), 혼잡 제어(Congestion Control) 제공
- 데이터 전송 순서 보장
- 헤더 크기: 20~60바이트 (오버헤드 큼)
- 예: HTTP, HTTPS, SMTP, FTP

### 🔹 UDP (User Datagram Protocol)

- 비연결형 (Connectionless)
- 신뢰성 없음 (데이터 손실, 순서 변경 감지/복구 없음)
- 빠르고 간단함
- 흐름/혼잡 제어 없음
- 헤더 크기: 8바이트 (오버헤드 적음)
- 예: DNS, 스트리밍, VoIP, 게임

### 📌 TCP와 UDP의 핵심 차이

| 항목 | TCP | UDP |
| --- | --- | --- |
| 연결 방식 | 연결 지향 (Connection-oriented) | 비연결 지향 (Connectionless) |
| 신뢰성 | 있음 (순서 보장, 재전송, ACK) | 없음 (순서 보장 X, ACK 없음) |
| 흐름/혼잡 제어 | 제공 | 제공하지 않음 |
| 전송 속도 | 느림 (신뢰성을 위한 절차 존재) | 빠름 (바로 전송) |
| 사용 예시 | HTTP, 이메일, FTP 등 | 실시간 스트리밍, VoIP, DNS 등 |

---

### 💡 Checksum이 무엇인가요?

**Checksum**은 전송된 데이터에 오류가 생겼는지를 **검사하는 값**

데이터의 각 비트를 수학적으로 계산해서 만든 요약 값으로, 수신 측에서도 같은 계산을 해서 서로 비교

- **오류 감지**에는 유용하지만, **오류 수정은 못함**
- 즉, 문제가 있으면 "이상 있어요!"만 알림 → 그 후 재전송은 TCP가 수행

---

### TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?

- **둘 다 Checksum을 수행**합니다.
    - TCP는 헤더 + 데이터에 대해 Checksum
    - UDP도 Checksum 필드를 가지고 있지만 **필수는 아님** (일부 구현체에서는 생략)

---

### Checksum으로 오류를 정정할 수 있나요?

**아니요!** Checksum은 **오류 감지만 가능**

오류가 감지되면 TCP는 **자동으로 재전송**하지만, UDP는 무시함

---

### 📌 TCP가 신뢰성을 보장하는 방법

1. **Sequence Number**
    
    → 데이터의 순서를 추적하는 번호. 순서 보장 가능!
    
2. **ACK (Acknowledgement)**
    
    → 받은 데이터를 확인하는 응답 메시지
    
3. **재전송 (Retransmission)**
    
    → ACK가 오지 않으면 해당 데이터를 다시 전송함
    
4. **타이머**
    
    → 일정 시간 내 응답 없으면 재전송 트리거
    

---

### 📌 TCP의 흐름 제어 (Flow Control)

**1. Sliding Window**

- 송신자가 수신자의 처리 속도에 맞춰 데이터를 전송
- 수신자가 처리 가능한 데이터 양을 알려주고 → 송신자가 그 범위 내에서만 전송
- 윈도우 크기는 동적으로 변경 가능

---

### 📌  TCP의 혼잡 제어

네트워크가 혼잡해질 경우, TCP는 여러 알고리즘으로 속도를 조절함

1. **AIMD (Additive Increase, Multiplicative Decrease)**
    - **Additive Increase**: 혼잡이 없을 경우 → **윈도우 크기를 1씩 증가** (선형 증가)
    - **Multiplicative Decrease**: 혼잡이 감지되면 (패킷 손실) → **윈도우 크기를 절반으로 감소**
    - 목적: 혼잡이 발생하지 않도록 조심스럽게 증가하고, 감지되면 빠르게 줄임
2. **Slow Start**
    - 처음 연결 시 윈도우 크기를 작게 시작해서 점점 배로 증가
        - **초기에는 작은 윈도우 크기**(일반적으로 1 MSS)로 시작
        - **수신 ACK마다 윈도우 크기를 2배씩 증가**시킴 (지수적 증가)
    - 임계값(Congestion Threshold)에 도달하면 AIMD 방식으로 전환
3. **Fast Retransmit / Fast Recovery**
    - **중복 ACK 3개**를 수신하면 → 패킷 손실로 간주하고 **즉시 재전송 (Fast Retransmit)**
    - 이때 **타이머 만료를 기다리지 않고** 빠르게 처리
    - **Fast Recovery**: 혼잡 임계값을 절반으로 줄인 뒤 → 그 아래에서 다시 선형 증가
    - 목적: 느린 타이머보다 빠르게 손실을 감지하고 회복

### 📈 혼잡 제어 전체 흐름 요약

1. 연결 초기 → **Slow Start (지수 증가)**
2. ssthresh 도달 → **AIMD 방식 (선형 증가)**
3. 패킷 손실 발생 → **윈도우 반감 (감소 후 선형 증가)**
4. 중복 ACK 3개 → **Fast Retransmit + Fast Recovery**

---

### 💡 왜 HTTP는 TCP를 사용하나요?

- **신뢰성이 중요하기 때문!**
    - 웹 페이지는 데이터 순서가 맞아야 함
    - 일부 손실되면 화면이 깨지거나 제대로 작동하지 않음
    - 그래서 **TCP의 순서 보장, 재전송, 오류 제어** 기능이 필수

---

### ⚠️ UDP가 흐름/혼잡 제어를 하지 않는 이유

- 단순하고 빠른 전송을 목표
- 오버헤드 최소화
- 실시간성이 중요한 애플리케이션에 적합
- 흐름/혼잡 제어는 **애플리케이션 레벨에서 직접 구현** 가능

---

### ❌ 흐름 제어 (Flow Control) 없음

- **수신자의 처리 속도 고려 X**
- 송신자는 **무조건 데이터를 전송**
- 수신자가 감당 못해도 조절되지 않음
- ➜ **빠르지만 데이터 유실 위험 존재**

---

### ❌ 혼잡 제어 (Congestion Control) 없음

- 네트워크 혼잡 여부 **판단 X**
- 전송 속도를 조절하지 않음
- ➜ 대역폭 부족/혼잡 시에도 계속 전송 → **패킷 손실 증가 가능**

---

### ✅ 왜 그러면 일부 프로토콜은 UDP를 쓸까?

- **실시간성**이 중요할 때는 지연이 더 치명적
    - 예: 음성/영상 통화, 게임, 스트리밍 등
- 정확성보다 속도가 우선인 상황에서는 UDP가 더 유리함
- 이런 경우, **신뢰성과 제어는 애플리케이션 단에서 직접 구현**

---

### 💡 왜 HTTP/3는 UDP를 사용하나요?

<img width="557" alt="image" src="https://github.com/user-attachments/assets/fbb5d4f6-df0f-4c9c-8f9a-82b71db15e90" />

https://gngsn.tistory.com/234

- **QUIC 프로토콜**이라는 새로운 전송 프로토콜이 UDP 기반으로 설계됨
- TCP의 단점인 연결 지연(Latency)과 **헤드 오브 라인 블로킹** 문제를 해결하기 위해 개발됨
- HTTP/2인 좌측 구조를 확인해 보면, TCP인 HTTP/2 아래에 TLS가 존재하며,
이 구조로 인해 부가적인 Handshake가 필요
- 새로운 프로토콜QUIC(Quick UDP Internet Connections)을 채택하여 이 문제를 해결
    - QUIC이 **TLS 1.3과 통합되어 별도 핸드셰이크가 필요 없는 점**

> 📌 QUIC는 UDP 위에서 TCP 같은 신뢰성 + TLS 보안을 앱 계층에서 직접 구현
> 
> - Multiplexing 전송하는 새로운 프로토콜
> - **속도는 빠르고 보안은 유지됨**

---

### 💡 브라우저는 TCP인지 UDP인지 어떻게 알 수 있나요?

- 브라우저는 **HTTP 버전에 따라** 다르게 작동해요
    - HTTP/1.1, HTTP/2 → TCP 사용
    - HTTP/3 → UDP + QUIC 사용
- 서버가 지원하는 버전을 **TLS handshake나 ALPN 프로토콜 협상**으로 알아냄

---

### 💡 새로운 프로토콜을 설계할 때 TCP와 UDP 중 어떤 걸 선택할 건가요?

**목표에 따라 다름!**

- **데이터 유실이 허용되지 않고 순서가 중요하면 → TCP**
- **실시간성, 낮은 지연이 더 중요하다면 → UDP**

| 기준 | TCP | UDP |
| --- | --- | --- |
| 신뢰성 필요 | O | X |
| 순서 보장 | O | X |
| 실시간성 | X | O |
| 전송 효율 | 낮음 | 높음 |

---

## ✅ 2. 3-Way Handshake에 대해 설명

### 3-Way Handshake

![image](https://github.com/user-attachments/assets/89e24852-daea-4d3d-86e7-6f91041ab533)


- **TCP 연결을 수립할 때 사용하는 3단계 절차**
- 클라이언트와 서버가 **서로의 존재를 확인하고**, **데이터를 주고받을 준비가 되었는지** 확인하는 과정

---

### 1단계: **SYN (연결 요청)**

- 클라이언트가 서버에게 "나 너랑 통신하고 싶어!"라고 요청
- 이때 **SYN 플래그 = 1**
- 예: 클라이언트가 `seq = x = 100` (랜덤한 초기 시퀀스 번호)를 보냄

```
Client → Server : SYN, seq = x = 100
```

---

### 2단계: **SYN + ACK (수락 + 응답)**

- 서버는 요청을 수락하고 응답
- **SYN = 1**, **ACK = 1**
- `ack = x + 1 = 101` , `seq = 200` (서버의 초기 시퀀스 번호)

```
Server → Client : SYN, ACK, seq = 200, ack = x+1 = 101
```

---

### 3단계: **ACK (최종 확인)**

- 클라이언트도 서버의 응답을 수락하며 마지막으로 ACK 전송
- `ack = y + 1 = 201`

```
Client → Server : ACK, seq = x+1 = 101, ack = y+1 = 201
```

---

## 결과

→ 이 세 단계를 통해 **양쪽 모두 데이터를 주고받을 준비가 되었음**을 확인

→ 그 이후부터는 **실제로 데이터 전송 시작**

---

## 왜 3번 해야 해?

- **1번만 하면**: 클라이언트 의지만 전달됨 (서버 준비 여부 모름)
- **2번만 하면**: 서버 준비는 확인했지만, 클라이언트가 제대로 받았는지 모름
- **3번까지 해야**: 서로 연결할 준비가 된 상태임을 **확실하게 보장**

---

## ✅ 3. 4-Way Handshake에 대해 설명

### 🔍 개념

TCP는 연결 수립 시에는 3단계(3-Way Handshake), **연결 종료 시에는 4단계의 핸드셰이크 과정**

**TCP는 양방향 연결 →** **양쪽 모두 “보낼 데이터 없음”을 확인해야 완전히 종료**되기 때문

---

### 📶 작동 과정

```
1. 클라이언트 → 서버 : FIN (연결 종료 요청)
2. 서버 → 클라이언트 : ACK (요청 수락)
3. 서버 → 클라이언트 : FIN (서버도 종료 요청)
4. 클라이언트 → 서버 : ACK (수락)
```

---

### 📦 각 단계 설명

<img width="533" alt="image" src="https://github.com/user-attachments/assets/090fdb83-ec71-43d1-8b07-f7252af53596" />


https://seongonion.tistory.com/74

### 1단계: **FIN (Finish)**

- 클라이언트가 **자신의 데이터 전송을 끝냈음을 알림**
- 서버에게 "나 더 이상 보낼 거 없어" 라는 뜻

```
Client → Server : FIN, seq = x
```

### 2단계: **ACK**

- 서버가 클라이언트의 종료 요청을 수락
- 아직 서버는 보낼 데이터가 남아 있을 수 있음

```
Server → Client : ACK, ack = x + 1
```

### 3단계: **FIN**

- 서버도 이제 자신의 데이터 전송이 끝남
- "나도 보낼 거 끝났어" 라고 알림

```
Server → Client : FIN, seq = y
```

### 4단계: **ACK**

- 클라이언트가 서버의 종료 신호를 수락

```
Client → Server : ACK, ack = y + 1
```

---

### 🔄 TIME_WAIT 상태

마지막 ACK를 보낸 클라이언트는 **바로 종료하지 않고, 일정 시간 기다림**

- 왜? 만약 **마지막 ACK가 유실**되었을 경우, 서버가 FIN을 재전송할 수 있음
- 그때 클라이언트가 그걸 받고 다시 ACK를 보내줘야 하니까!
- 이 대기 시간이 바로 **TIME_WAIT (기본 2*MSL)**

---

### Q. 패킷이 4-Way 종료 패킷인지 어떻게 알아요?

- TCP 헤더의 **Control 플래그**를 보면 알 수 있음
    - `FIN`, `ACK` 플래그 조합으로 종료 패킷 여부를 판단

### Q. 급하게 종료하고 싶을 땐 어떻게 하나요?

- **TCP RST(Reset) 플래그**를 사용해서 **즉시 연결 종료** 가능
- 하지만 일반적으로 권장되지는 않아요 (세션 손상 위험)

### Q. 한 쪽이 중간에 꺼졌다면?

- TCP는 상대방의 연결 종료를 즉시 감지하지 못함
- 이럴 때 **Keep-Alive 옵션**을 활성화하면 해결 가능
    - 연결 상태가 유지된 채 **오랫동안 데이터 통신이 없으면**, 일정 시간 후 **Keep-Alive 패킷**을 보냄
    - 상대방이 응답하지 않으면 **연결이 끊긴 것으로 간주**하고 종료 처리
- 또는, **타임아웃 설정**을 통해 일정 시간 동안 응답이 없으면 세션을 종료하는 방식도 사용함

> 📌 Keep-Alive는 운영체제에서 기본 비활성화일 수도 있어 설정이 필요하며, TCP 연결을 장시간 유지하는 서버에서 유용함
> 

### Q. TIME_WAIT은 왜 꼭 필요할까요?

- **중복 패킷 제거**, **정상적인 연결 종료 보장**
- 다음 연결이 같은 포트로 재사용될 때, 이전 연결의 잔여 패킷이 영향을 주는 걸 방지

---

## ✅ 4. DHCP (Dynamic Host Configuration Protocol)

### 🔍 개념

네트워크에 접속한 장치에게 **자동으로 IP 주소, 서브넷 마스크, 게이트웨이, DNS 등**

필요한 네트워크 설정 정보를 **자동으로 할당**해주는 프로토콜!

- 예전에는 수동으로 IP 설정을 해줘야 했지만
- DHCP 덕분에 자동으로 쉽게 네트워크에 연결 가능!

---

### 📦 계층 정보

- **OSI 계층 기준**: **응용 계층**
- **TCP/IP 기준**: **응용 계층**
- 전송은 **UDP** 기반으로 수행됨

---

### ⚙️ 동작 방식 (DORA 과정)

DHCP는 **4단계 통신**을 통해 동작해요. 이걸 보통 **DORA** 과정이라고 함

| 단계 | 동작 내용 | 설명 |
| --- | --- | --- |
| **D (Discover)** | 클라이언트 → 브로드캐스트 | "IP 좀 주세요!" |
| **O (Offer)** | 서버 → 클라이언트 | "이 IP 어때?" |
| **R (Request)** | 클라이언트 → 서버 | "이 IP 쓸게요!" |
| **A (Acknowledge)** | 서버 → 클라이언트 | "IP 할당 완료!" |

### ✅ 예시 흐름

1. 클라이언트가 부팅되며 **DHCP Discover** 브로드캐스트 (255.255.255.255)
2. DHCP 서버가 IP 제안 (Offer)을 보냄
3. 클라이언트가 원하는 IP를 **Request**
4. 서버가 **Acknowledge**로 IP 사용 확정

---

### ❓ DHCP는 왜 UDP를 사용할까?

- DHCP는 **초기 IP가 없는 상태**에서 통신함
- IP 없이도 **브로드캐스트로 네트워크에 메시지를 전송**해야 하므로,
    
    TCP처럼 연결 지향 방식은 사용할 수 없고, **UDP**가 적합
    

→ **UDP 포트**

- 클라이언트: 68
- 서버: 67

---

### ✅ DHCP가 제공하는 정보

- IP 주소
- 서브넷 마스크
- 기본 게이트웨이
- DNS 서버 주소
- 임대 기간(Lease Time)
- 기타 설정 (NTP 서버 등)

---

### ⏰ DHCP 유효기간 (Lease Time)

- 할당된 IP 주소는 **영구적이 아님!**
- 보통 몇 시간 ~ 며칠 단위
- 만료되기 전 클라이언트는 연장 요청(Renewal)을 보냄
- 재시도 실패 시, **DHCP Discover**부터 다시 시작

---

## ✅ 5. 멀티플렉싱(Multiplexing) & 디멀티플렉싱(Demultiplexing)

### 🔍 개념

| 개념 | 설명 |
| --- | --- |
| **멀티플렉싱** | 여러 개의 애플리케이션 데이터가 하나의 네트워크 연결(소켓)을 통해 전송될 수 있도록 **식별 정보를 붙여 전송**하는 과정 |
| **디멀티플렉싱** | 수신 측에서 받은 데이터를 **적절한 애플리케이션(프로세스)으로 분배**하는 과정 |

즉, 여러 프로그램이 하나의 네트워크 통신 경로를 **함께 사용할 수 있도록** 해주는 기술!

---

### 💡 왜 필요할까?

- 한 컴퓨터에서 **여러 앱(HTTP, FTP, DNS 등)** 이 동시에 통신할 수 있기 때문
- 하지만 IP 주소는 컴퓨터 하나를 식별할 뿐 → 어떤 애플리케이션인지는 모름
- 그래서! **포트 번호**로 애플리케이션을 구분해주는 게 필요함

---

### 🧩 디멀티플렉싱 과정 자세히 보기

1. 클라이언트는 `HTTP 요청`을 보냄 (ex. 웹 브라우저 → 서버)
2. 해당 데이터는 **출발지 포트, 목적지 포트** 정보를 포함해 전송됨
3. 서버 측 전송 계층(TCP 또는 UDP)은 이 포트를 확인하여
4. **포트 번호에 해당하는 프로그램에게 데이터 전달** (예: 포트 80 → 웹 서버)

---

### 🧪 예시

```
[IP 헤더]       → 출발지 IP: 192.168.0.10 / 목적지 IP: 142.250.196.78
[TCP 헤더]      → 출발지 포트: 51734 / 목적지 포트: 80
[데이터]        → HTTP 요청

서버 측에서는 "목적지 포트 80"이니까 웹 서버로 전달!
```

---

### 🔑 포트 번호 정리

| 포트 범위 | 설명 |
| --- | --- |
| 0 ~ 1023 | **잘 알려진 포트 (Well-known ports)** → HTTP(80), DNS(53), FTP(21) |
| 1024 ~ 49151 | 등록된 포트 |
| 49152 ~ 65535 | 동적 포트 (클라이언트 측에서 임시로 사용) |

---

### 🎯 프로토콜과의 관계

| 프로토콜 | 사용 방식 |
| --- | --- |
| **TCP** | 포트 + 시퀀스 번호로 데이터 흐름 제어 |
| **UDP** | 포트만 사용하고, 신뢰성은 애플리케이션에서 처리 |

---

### 정리

- **멀티플렉싱**: 여러 앱의 데이터를 하나로 모아 전송
- **디멀티플렉싱**: 포트 번호를 보고 데이터를 각 앱으로 분배
- **포트 번호**가 핵심이며, TCP/UDP가 이를 기반으로 통신 흐름을 조율함

---

## ✅ Nagle's Algorithm vs Delayed ACK

### 🔧 Nagle’s Algorithm

- **작은 패킷을 여러 번 보내지 않고 묶어서 전송**
- 전송 후, **이전 패킷에 대한 ACK을 받기 전까지는 새 데이터를 전송하지 않음**
- 목적: **작은 패킷 폭주 방지 → 네트워크 부하 감소**
- 단점: **실시간 응답성이 떨어짐**
    - → **게임, 채팅, 원격 제어**에서는 비추천

> 예: 채팅 앱에서 한 글자 입력할 때마다 지연됨
> 

---

### 📩 Delayed ACK

- **수신자가 ACK 전송을 잠시 지연**
    - → 여러 세그먼트에 대해 하나의 ACK으로 응답하려는 전략
- 보통 **200ms 정도 대기** (운영체제마다 다름)
- 목적: **ACK 수를 줄여 네트워크 효율 향상**
- 단점: **응답 지연 가능**

---

### ⚠ 문제 상황: Nagle + Delayed ACK

두 알고리즘이 **같이 작동하면 지연 시간이 길어질 수 있음**

- 송신자는 ACK이 오기 전까지 대기 (Nagle)
- 수신자는 ACK을 일부러 늦게 보냄 (Delayed ACK)

> 결과: 데이터 전송 지연 심화
> 
> 
> → **인터랙티브 앱, 채팅 등에서 큰 문제가 됨**
> 

---

### 💡 해결 방법

- 필요시 **Nagle's Algorithm 비활성화**
    - `TCP_NODELAY` 옵션 사용 (소켓 설정)
- 또는 **Delayed ACK 비활성화** (운영체제 설정, 신중히)

---

### 🧪 요약 비교

| 항목 | Nagle’s Algorithm | Delayed ACK |
| --- | --- | --- |
| 목적 | 작은 패킷 묶어 전송 | ACK 수 줄이기 |
| 동작 방식 | ACK 오기 전까진 전송 보류 | ACK 전송 잠시 지연 |
| 장점 | 네트워크 부하 감소 | ACK 패킷 감소 |
| 단점 | 전송 지연 | 응답 지연 |
| 함께 작동 시 | **지연 시너지 → 성능 저하** 가능 | Nagle과 함께 사용 시 응답 지연 증가 가능 |
