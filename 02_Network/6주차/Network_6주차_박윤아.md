블로그 정리 글 👇🏻
- [TCP & UDP, TCP의 오류 검출과 재전송](https://0woy.tistory.com/entry/TCP-UDP-TCP%EC%9D%98-%EC%98%A4%EB%A5%98-%EA%B2%80%EC%B6%9C%EA%B3%BC-%EC%9E%AC%EC%A0%84%EC%86%A1)
- [TCP의 흐름 제어 & 혼잡 제어](https://0woy.tistory.com/entry/TCP%EC%9D%98-%ED%9D%90%EB%A6%84-%EC%A0%9C%EC%96%B4-%ED%98%BC%EC%9E%A1-%EC%A0%9C%EC%96%B4)


## 전송 계층

네트워크 계층과 응용 계층 사이에 위치

-   **IP한계 보완**: \`신뢰\`할 수 있는 통신과 \`연결\`형 통신 기능 제공
-   **응용 계층의 프로세스 식별**: 포트 번호 활용

---

#### IP 한계

-   **신뢰할 수 없는 통신**
    -   패킷이 수신지까지 제대로 전송되었다는 보장X
    -   통신 과정에서 패킷이 잘못 전송되어도 확인X, 재전송X, 순서대로 도착 보장X
-   **비연결형 통신**
    -   송수신 호스트 간에 **사전 연결** 수립 작업X
    -   그저 수신지를 향해 패킷을 보내기만 함

> ∴ IP 패킷의 전달 = 신뢰성이 없는 통신 + 비연결형 통신

---

#### IP는 왜 신뢰할 수 없는, 비연결형 통신을 하는가 ?

1.  비연결형 통신이 나쁜 게 아님  
    👉 신뢰할 수 있는 연결형 통신 = \`성능\`에 악영향
2.  신뢰성 있는 전송이 모든 경우에 필요한 게 아님

| **간단함** | 연결 유지 & 상태 저장X = 라우터가 가볍고 빠르게 작동 |
| --- | --- |
| **확장성** | 수십억 기기가 연결되는 환경에서도 유지비용X 동작 가능 |
| **장애 허용성** | 연결 상태 기억X, 중간 라우터가 꺼져도 우회 가능 |
| **계층 분리** | 신뢰성 보장은 TCP의 역할로 분리 → 책임 명확 |

> 📌  
> \`TCP\` :신뢰성 & 연결형 통신이 **필요한 경우** 사용  
> \`UDP\` :신뢰성 & 연결형 통신이 **필요 없는 경우** 사용

---

## TCP (Transmission Control Protocol)

전송 계층에 위치, **신뢰**할 수 있는 통신을 위한 **연결형** 프로토콜

---

## UDP (User Datagram Protocol)

비연결형 프로토콜, 신뢰성 미보장, 최소한의 헤더로 빠른 통신 가능

> 주요 용도: 실시간 통신, 스트리밍, 게임, DNS 

#### UDP 통신 특성

1.  **연결 과정 없음**
    -   핸드셰이크 없이 바로 데이터 전송
    -   오버헤드가 작고 빠름
2.  **신뢰성 보장X**
    -   순서 보장 X
    -   손실/중복 방지X
    -   수신 확인, 재전송X

---

## TCP 통신 단계

![1](https://github.com/user-attachments/assets/7ea8d9de-faa8-4749-91dc-f5b974929978)


1.  **연결 설정**
    -   클라이언트 → SYN → 서버
    -   서버 → SYN+ACK → 클라이언트
    -   클라이언트 → ACK → 서버
2.  **데이터 전송**
    -   순서 보장 (Sequence Number)
    -   수신 확인 (ACK)
    -   재전송 (Timout or 중복 ACK)
    -   **흐름 제어** (Sliding Window)
    -   **혼잡 제어** (Slow  Start, AIMD 등)
3.  **연결 해제**
    -   FIN → ACK → FIN → ACK

---

### MSS (Maximum Segment Size)

TCP로 **한 번에 전송**할 수 있는 \`데이터 (payload)\`의 최대 크기

![1](https://github.com/user-attachments/assets/94c35e2a-0dfa-46bf-b6db-94f033087a0c)


-   TCP 세그먼트에서 IP헤더와 TCP헤더를 제외한 **순수 데이터 부분의 최대 크기**
-   TCP 연결을 **설정**할 때 협상됨
-   MSS 값이 너무 큰 경우, 네트워크에서 IP 패킷이 분할되어 _성능이 떨어질 수 있음_

> ❓ **MTU (Maximum Transmission Unit)**  
> IP 계층에서 전송 가능한 전체 패킷의 최대 크기  
> \= IP헤더 + TCP 헤더 + 페이로드  
>   
> 일반적인 이더넷 MTU =1500Byte  
> ∴ 일반적인 MSS = 1500 - 20(IP 헤더) - 20(TCP 헤더) = 1460Byte

---

### 3 Way Handshake

TCP 프로토콜로 통신하기 위해 데이터 전송 전 **상호 연결을 수립**하는 과정

상대방과 논리적 세션을 맺는 \`시작점\`으로 해당 과정을 거친 후, 데이터들을 정상적으로 송수신

_UDP는 이 과정이 없으므로 신뢰성이 없는 계층이라고 함_

> 즉, 데이터를 전송할 준비가 되었음을 보장 & 데이터 전송 준비 확인 과정  
> 3-Way handshake 과정에서 정상적으로 세션이 맺어지지 않으면 통신 종료

![1](https://github.com/user-attachments/assets/2b471075-6754-4540-8b3f-1a065f11b484)


#### 1\. Closed

-   아직 연결 시도 전 Cliend, Server의 상태
-   TCP 포트가 닫힌 상태

#### 2\. Listen

-   TCP 포트가 열려 있고, 요청 대기 상태

#### 3\. SYN-SENT (Client)

-   Client가  Server에게 연결을 요청하는 **SYN 패킷 전송**
-   자신의 ISN 을 보냄

#### 4\. SYN-RECEIVED

서버가 클라이언트의 SYN 패킷을 수신하고, SYN-ACK 응답을 보낸 후, 클라이언트의 최종 ACK를 기다리는 상태

-   SYN 패킷을 받은 서버는 요청을 수락하게 되면, **SYN+ACK 패킷을 전송**하여 응답
-   임의의 ISN 값 전달
-   해당 패킷의 응답이라는 표시로 Client로 부터 받은 \`seq(100)+1\` 값인 ack 넘버 전달

#### 5\. Established (Client)

-   서버로부터 SYN+ACK 응답을 받아 클라이언트는 연결 수립 상태
-   다시 서버에게 **ACK로 수립 완료 패킷 전달**
-   이전에 보낸 \`seq(100)+1\` 하여 새로운 seq 넘버 전달
-   해당 패킷의 응답이라는 표시로 서버로 부터 받은 \`seq(200)+1\` 하여 ack 넘버 전달

#### 5\. Established (Server)

-   클라이언트로부터 ACK 패킷을 전달 받아 서버도 연결 수립 상태로 전환
-   서버와 클라이언트가 **Established 모드**가 된 후 데이터 송수신 이루어짐

> **❓ 용어 설명**  
> **\- ISN (Initial Sequence Number)**  
> TCP 연결 시작 (초기 네트워크 연결) 시 각 호스트가 임의로 생성하는 32bit 고유 시퀀스 번호  
>   
> **\- SYN (SYNchronization):** 연결 요청 플래그  
> **\- ACK (ACKnowledgement)**: 응답 플래그

---

### 4 Way Handshake 

TCP는 양방향 통신이 가능하므로, **연결 종료도 양쪽이 각각 종료 의사를 명시**해야 함

이를 위해 총 4단계 (FIN/ACK/FIX/ACK)의 통신과정을 거쳐 연결 종료

이 과정에서 각각의 방향에 대해 반이중식 종료(Half-close) 가능

![1](https://github.com/user-attachments/assets/7eec155b-45cd-4bb9-a8ac-0d30d40255f6)


#### 1\. 초기 상태: Established

연결이 완료 되어 데이터 송수신 중

#### 2\. FIN\_WAIT-1 (클라이언트 종료 요청)

-   클라이언트가 데이터 전송을 끝내고 종료 의사를 보냄 (FIN)
-   클라이언트는 \`FIN\_WAIT-1\` 상태 진입

#### 3\. 서버: CLOSE\_WAIT, 클라이언트: FIN\_WAIT-2

-   서버가 FIN을 수신하고 ACK 전송
-   클라이언트는 \`FIN\_WAIT-2\` 상태 진입
-   서버는 \`CLOSE\_WAIT\` 상태 (아직 데이터를 보낼 수 있음)

#### 4\. LAST\_ACK (서버 종료 요청)

-   서버도 전송을 마치고 종료 요청 (FIN)
-   서버는 \`LAST\_ACK\` 상태 진입

#### 5\. 클라이언트: TIME\_WAIT & 서버: CLOSED

-   클라이언트가 FIN을 확인하고 ACK 응답
-   클라이언트는 \`TIME\_WAIT\` 상태, **일정 시간 후 CLOSED**
-   서버는 CLOSED 상태 진입

---

#### TIME\_WAIT을 하는 이유?

#### TIME WAIT ?

소켓이 바로 소멸되지 않고 일정 시간 유지되는 상태를 말하며, 지연 패킷 등의 문제점을 해결하는 데 사용

우분투는 60초, 윈도우는 4분으로 설정 👉 _OS 마다 다름_

#### 1) 지연 패킷이 발생할 경우 대비

패킷이 뒤늦게 도달하고, 이를 처리하지 않으면 \`**데이터 무결성**\` 문제 발생

> ex) 전체 데이터가 100일때, 일부인 50만 들어오는 현상

---

#### 2) 두 장치가 연결이 닫혔는지 확인하기 위함

\`**LAST\_ACK**\` 상태에서 닫히게 된 경우,  
다시 새로운 연결을 하려고 할 때 장치는 줄곧 LAST\_ACK 상태이므로 접속 오류 발생

---

#### TCP의 기능

**재전송**을 기반으로 다양한 오류를 제어

**흐름 제어**를 통해 처리할 수 있을 만큼의 데이터 송수신

**혼잡 제어**를 통해 네트워크가 혼잡한 정도에 따라 전송량 조절

TCP 세그먼트 헤더 (UDP 데이터그램 헤더) 에는 \`**checksum\`**이라는 오류 검출 필드 존재  
하지만, _checksum 필드만으로는 충분한 오류 검출하기 어려움_  
∵ 데이터가 훼손 되었는지 여부만 알리기 때문에 자체가 유실된 경우에는 검출이 어려움

---

## TCP 오류 검출과 재전송

#### TCP가 신뢰성을 제대로 보장하려면?

-   송신 호스트가 송신한 세그먼트에 문제가 발생했음을 인지해야 함
-   오류를 감지하면 해당 세그먼트를 재전송 해야함

---

#### TCP는 언제 오류를 검출하고 재전송 하는가?

1.  **중복된 ACK 세그먼트를 수신**한 경우
2.  **타임 아웃**이 발생한 경우

---

### 1) 중복된 ACK 세그먼트를 수신한 경우

![1](https://github.com/user-attachments/assets/63d71737-04c1-4bd5-9974-8e5e9594353f)


> 호스트 B 입장에서는 n+1을 받지 못했으므로, 다시 n+1번의 ACK 세그먼트 수신  
> → 호스트 A는 중복된 ACK 수신으로 n+1번의 세그먼트가 손실됐음을 확인

---

### 2) 타임아웃이 발생한 경우

호스트가 세그먼트를 전송할 때마다 \`**재전송 타이머**\`(retransmission timer) 시작

타임아웃이 발생할 때까지 ACK 세그먼트를 받지 못하면 재전송

![1](https://github.com/user-attachments/assets/299dae90-0d23-4208-90ae-8bf3b98f439f)


> 📌 **빠른 재전송 (fast retransmit)  
> **재전송 타이머가 만료되기 전에 세 번의 동일한 ACK 세그먼트를 받으면 곧바로 재전송  
> \= 타이머가 끝날 때까지 기다리는 시간 절약  
>   
> 오늘 날 TCP에선 대부분 활성화 돼있음

---

## ARQ (Automatic Repeat Request, 자동 재전송 요구)

수신 호스트의 답변 (ACK) & 타임아웃을 토대로 문제를 진단하고,  
**문제가 생긴 메시지를 재전송**함으로써 **신뢰성을 확보**하는 방식

> ARQ는 전송 계층 이외에도 여러 계층과 프로토콜에서 사용하지만,  
> 대표적인 계층이자 프로토콜은 전송계층의 TCP임

#### ARQ의 대표적 방식

1.  Stop-and-Wait ARQ
2.  Go-Back-N ARQ
3.  Selective Repeat ARQ

---

### 1) Stop-and-Wait ARQ

제대로 전달했음을 확인하기 전까지 **새로운 메시지를 보내지 않는 방식**

-   **장점**: 단순 & 높은 신뢰성 보장
-   **단점**: 네트워크 이용 효율 ↓ , 성능 저하

> 송신 호스트 (A): 확인 응답을 받기 전에는 더 보내고 싶어도 못 보냄  
> 수신 호스트 (B): 더 많은 데이터를 처리할 수 있어도 하나씩만 확인 응답

#### 문제 해결 방법

각 세그먼트에 대한 ACK 세그먼트가 도착하기 전이더라도 여러 세그먼트를 보낼 수 있어야 함

👉 **\`파이프라이닝(pipelining)**\`: 연속해서 메시지를 전송할 수 있는 기술

![1](https://github.com/user-attachments/assets/1fd3d654-7bd1-4e51-8119-87d02fc880dd)


> 오늘날 실 TCP 환경의 전송 기법은 파이프라이닝 기법임

---

### 2) Go-Back-N ARQ

파이프라이닝 기반 ARQ 일종

여러 세그먼트 전송 중 오류가 발생하면 해당 세그먼트부터 **전부 재전송**

![1](https://github.com/user-attachments/assets/082e6a1a-6375-4ff9-9f59-fd2e62df5f9c)


순서 번호 N번에 대한 ACK 세그먼트는 N번만의 확인 응답이 아닌 **\`n번까지의 누적 확인 응답\`  
**∴ **누적 확인 응답** (Cumulatice Acknowledgement) 라고 불림

---

### 3) Selective Repeat ARQ

-   선택적 재전송, 각각의 패킷들에 대해 ACK 세그먼트를 보내는 방식
-   Selective Repeat ARQ의 ACK 세그먼트는 **개별 확인 응답**(Selective Acknowledgement)임.
-   오늘날 대부분 호스트는 Selective Repeat ARQ 지원. (그렇지 않으면 Go-Back-N 으로 동작)

![1](https://github.com/user-attachments/assets/0eddcad7-c97c-44b5-9a13-9f639abd29f1)

---

## 흐름 제어 (Flow Control)

파이프라이닝 기반 전송으로 **한 번에 무한히 많은** 데이터를 주고 받을 수 있는가? 👉 No!  
수신 측이 송신 측보다 데이터 처리 속도가 빠르면 문제 없지만, 송신 측의 속도가 더 빠를 경우 문제가 생김

수신 호스트가 **한 번에 받아서 처리할 수 있는 세그먼트의 양에는 한계**가 있기 때문에,  
한계를 초과한 이후 도착하는 패킷은 손실될 수 있고 만일 손실된 경우 불필요한 추가 패킷 전송 발생

![1](https://github.com/user-attachments/assets/1b3a7213-bcdf-4af1-b2ff-26e446f793d5)


> **📌 TCP의 흐름 제어**  
> 송신 호스트가 수신 호스트의 처리 속도를 고려하여 **송수신 속도를 균일하게 유지**하는 기능

-   Stop-and-Wait ARQ를 사용하면, 흐름 제어 필요 없음
-   **파이프 라이닝 기반 ARQ**를 사용하면 **흐름 제어 필요!**

![1](https://github.com/user-attachments/assets/87df23a6-59e7-434a-aa22-6484bea260c2)


ACK 응답 마다 윈도우 크기를 포함하여, 수신자가 이후 허용 가능한 시퀀스 번호 범위를 알림으로 흐름 제어.

윈도우 크기는: 송신자가 다음 허가(ACK)를 받기 전까지 전송할 수 있는 바이트(octet)의 수

---

#### 시퀀스 번호 범위

TCP에서 수신자가 어떤 시퀀스 번호 범위의 데이터까지 수신 가능한지 송신자에게 알리는 방식  
👉 \`**ACK+윈도우 크기**\` 필드 사용

ACK 패킷에 들어있는 정보

-   \`**ACK 번호**\`: 수신자가 다음으로 기대하는 시퀀스 번호, 현재까지 정상적으로 받은 마지막 바이트 + 1
-   \`**Window Size**\`: 수신자가 현재 수신 버퍼에 수용할 수 있는 여유 공간

즉, 수신자가 허용하는 시퀀스 번호 범위 = _수신자가 기대하는 다음 바이트 + 수신 가능 크기_

> **📌 예시  
> **수신자가 ACK 번호로 1001, 윈도우 크기로 5000 전송  
> 송신자는 \`**1001 ~ 6000**\`까지 전송 가능 (총 5000byte)

---

### 슬라이딩 윈도우 (Sliding Window)

TCP 흐름제어 기법, 윈도우의 크기 만큼 확인 응답(ACK)을 받지 않고도 한 번에 전송 가능

-   **윈도우 (Window)**: 송신 호스트가 파이프라이닝할 수 있는 최대량
-   수신 호스트는 TCP 헤더 (윈도우 필드)를 통해 송신 측에 **자신이 받을 데이터의 양**을 알려줌
-   **송신 윈도우**: 헤더로 전달받은 수신 윈도우를 토대로 연산

![1](https://github.com/user-attachments/assets/c00d7e16-5a7e-4e5c-b133-53ade593b257)


#### LastByteAcked

수신자로부터 **ACK를 받은** 가장 마지막 바이트의 시퀀스 번호.  
→ 수신자가 성공적으로 받았다고 확인한 마지막 바이트

#### LastByteSent

송신자가 **전송을 시도**한 마지막 바이트의 시퀀스 번호  
→ 아직 ACK을 받지 못했을 수 있음

> **📌 추가로 전송 가능한 데이터 크기 계산**  
> 윈도우 크기(N)  
> \= LastByteAcked + AdvertisedWindow(수신자가 알려준 수용 가능 윈도우 크기) - LastByteSent

#### 예제 👇🏻

더보기

1.  수신자가 말한 윈도우 크기: \`600\`
    -   수신자는 지금 600바이트만 더 받을 수 있다고 알려줌 (AdvertisedWindow = 600)
2.  송신자가 마지막으로 ACK 받은 시퀀스 번호: \`100\`
    -   즉, 수신자가 1000번까지 잘 받았다고 응답했음 (LastByteAcked = 1000)
3.  송신자가 지금까지 보낸 마지막 바이트: \`1400\`
    -   1001 ~ 1400까지의 총 400바이트를 보냈으나 아직 ACK를 받지 못함 (LastByteSent = 1400)

수신자가 말한 AdvertisedWindow는 **1001번 부터 600byte까지**만 받을 수 있음을 의미  
∴ 수신자가 받을 수 있는 시퀀스 번호 범위 = \`1001 ~ 1600\` (전송 가능 구간)

 송신자는 이 범위 안에서만 데이터 전송 가능 하지만, 송신자는 _이미 1001 ~ 1400번 까지 전송_

남은 수용 공간 = 600 - 400 = 200 바이트 ( \= usable Window)

**∴ 새로 보낼 수 있는 범위 = 1401 ~ 1600** 

---

## 혼잡 제어 (Congestion Control)

#### 네트워크 혼잡 시나리오

![1](https://github.com/user-attachments/assets/c4f49f49-3fcc-44af-bed2-390c281e58d6)


A는 C로, B는 D로 데이터를 전송하는 상황, **경유지 라우터의 버퍼는 유한**함.

![1](https://github.com/user-attachments/assets/26646ee5-bd4a-46b8-a50e-549254a6e186)


-   R: 입/출력 링크 용량
-   λout: 도착하는 데이터
-   λIn: 전송되는 데이터 (원본 + 재전송)

네트워크 혼잡이 발생하여 패킷이 유실 된다면,  
해당 패킷이 링크를 점유했던 시간 & 버퍼링 시간이 무용지물 됨 = **오버헤드**

---

#### 혼잡 제어 vs 흐름 제어

-   **흐름 제어**
    -   **송/수신 측** 간의 전송 속도 조절
    -   **수신측의 버퍼 오버플로우 방지**를 위해 슬라이딩 윈도우 기법으로 데이터 전송 속도 조절
-   **혼잡 제어**
    -   **라우터**에서 발생할 수 있는 네트워크 혼잡 상황 방지
    -   네트워크 상황이 좋지 않을 때, **패킷이 계속 수신되어 유실 되는 상황을 방지**하기 위해 데이터 전송 속도 조절

---

## 혼잡 감지

### 1) TCP Throughput을 계산하여 확 줄어들면 혼잡하다고 판단

모든 ACKed된 패킷에 대해 RTT 측정 후, min(RTT)로 구한 처리율과 현재 처리율 비교

![1](https://github.com/user-attachments/assets/dc746431-e88e-46b5-80a7-9275b1154d6d)


-   **MSS**: Max Segment Size
-   **cwnd**: 윈도우 크기
-   **RTT** (Round Trip Time): 네트워크 요청이 시작점에서 목적지로 갔다가 시작점으로 다시 돌아오는데 소요되는 시간

### 2) 타임아웃

송신한 패킷에 대한 ACK가 일정 시간 내 도착하지 않으면 혼잡이 발생했다고 판단  
👉  **cwnd를 1MSS로 줄이고, Slow Start**

### 3) Triple Duplicate ACKs (중복 ACK 3개)

같은 ACK가 3번 연속 도착하면, TCP는 그 다음 패킷이 유실된 것으로 판단  
👉 **Fast Retransmit + Fast Recovery 사용**

 = 혼잡 윈도우를 절반으로 줄이고, 유실된 패킷만 재전송

---

## 혼잡 회피

### 1) Slow Start 

네트워크 상태를 모르므로 cwnd를 1부터 시작하여 천천히 증가

새로운 TCP 세션 생성 또는 타임아웃 발생 시 진입하는 스테이지

cwnd는 1부터 시작하여 **매 ACK 수신 시마다 1씩 증가**

#### cwnd의 크기는 얼마나 빠르게 증가하는가?

송신자는 한 RTT 동안 cwnd 만큼의 패킷 전송 가능  
→ 모든 패킷에 대한 ACK를 받으면, cwnd는 RTT마다 **2배씩 지수적으로 증가**

#### Slow Start는 언제 종료 되는가?

**\`ssthresh\`** (Slow-start threshold): Slow Start를 종료하는 임계값

-   혼잡 발생 시 현재 cwnd의 ½로 ssthresh 설정, cwnd는 1로 설정
-   Slow start 수행  \`**cwnd > ssthresh**\`가 되면 네트워크 용량 근처에 도달했다고 판단
-   SS 종료 후,  Congestion Avoidence로 전이

---

### 2) AIMD (Additive Increase Multiplicative Decrease)

_\= 혼잡 회피 (Congestion Avoidence)_

**증가는 하나씩, 감소는 공격적으로!**

1.  **Additive Increase (AI)**
    1.  혼잡이 감지되지 않는 한, **매 RTT(왕복 시간)** 마다 cwnd를 조금씩 증가
    2.  보통 1 MSS씩 증가 (선형 증가)
    3.  cwnd = cwnd + 1 
2.  **Multiplicative Decrease (MD)**
    1.  패킷 손실이 감지되면 (예: 중복 ACK 3개 또는 타임아웃)
    2.  cwnd를 **절반으로 급격히 줄임**
    3.  cwnd = cwnd / 2

![aimd](https://github.com/user-attachments/assets/427405ed-0c08-4235-818f-485c3664b11b)


| **항목** | **Slow Start**  | **AIMD (Congestion Avoidance)** |
| --- | --- | --- |
| **목적** | 처음엔 네트워크 대역폭을 **빨리 파악** | 이후엔 **안정적으로 속도 조절** |
| **증가 방식** | **지수 증가 (cwnd ×2)** → 매우 빠름 | **선형 증가 (cwnd += 1)** → 느리지만 안정적 |
| **혼잡 발생 시** | **cwnd = 1로 초기화** | **cwnd를 절반으로 감소** |
| **전환 시점** | cwnd ≥ ssthresh 되면 **AIMD로 전환** | Slow Start 이후 자동 적용 |

---

### 3) Fast Recovery 

네트워크가 덜 혼잡하면 cwnd를 굳이 1로 확 줄이지 않아도 되지 않나?  
 = 패킷 손실이 일어난 경우, **네트워크 성능을 최대한 떨어뜨리지 않고** 복구하기 위한 기법

중복 ACK 3개를 받았을 때, 패킷 손실로 간주하여 빠르게 재전송 & **cwnd를 \`절반\`으로 줄인** 후 전송을 계속하는 알고리즘

#### FastRetransmit (빠른 재전송) & Fast Recovery (빠른 회복)

-   **Fast Retransmit**: 중복 ACK 3개 받으면, **타임아웃 기다리지 않고** 손실된 패킷 즉시 재전송
-   **Fast Recovery**: 그 직후, **혼잡 윈도우를 확 줄이되**, **송신은 멈추지 않고 이어감**

---

#### 왜 사용하는가?

**타임아웃을 기다리는 건 너무 느리기 때문에,**

-   **Fast Retransmit**은 손실된 패킷을 빨리 재전송하고
-   **Fast Recovery**는 "그만 보내고 다시 시작" 대신, **전송 속도를 조절하며 계속 보냄**

---

## TCP Tahoe & TCP Reno

TCP에는 Tahoe, Reno, New Reno, Cubic, Ealstic-TCP까지 다양한 혼잡 제어 정책이 존재.

이러한 혼잡 제어 정책들은 공통적으로 혼잡이 발생하면  
**윈도우 크기를 줄이거나, 혹은 증가시키지 않으며** 혼잡을 회피한다 라는 전제를 깔고 있음

Tahoe와 Reno는 기본적으로 처음에는 Slow Start 방식을 사용,  
네트워크가 혼잡하다고 느껴졌을 때는 AIMD 방식으로 전환하는 방법을 사용하는 정책

![TAHOE](https://github.com/user-attachments/assets/b80681df-de14-4a20-8b15-fbc4503d50d9)


그래프의 Y축은 혼잡 윈도우, X축은 시간으로 하여 Tahoe와 Reno의 작동 방식 설명함.

---

### TCP Tahoe

처음에는 Slow Start를 사용하여 자신의 윈도우 크기를 지수적으로 빠르게 증가시키다가  
ssthresh를 만난 이후부터는 AIMD을 사용하여 선형적으로 윈도우 크기를 증가

ACK Duplicated나 Timeout이 발생하면 네트워크에 혼잡이 발생했다고 판단하고,  
ssthresh와 자신의 윈도우 크기를 수정함

![tahoe1](https://github.com/user-attachments/assets/257ee905-8102-4c68-951a-4a0489c482ae)


혼잡 윈도우 크기는 8로 초기화 되었고, 그에 따라 ssthresh는 4로 설정

1.  송신 측은 임계점을 만나기 전까지 Slow Start 방식을 사용하여 자신의 윈도우 크기를 증가
2.  ssthresh를 넘어선 이후부터는 **선형적**으로 증가
3.  처음 혼잡 상황이 발생한 상태의 혼잡 윈도우 크기는 6임
4.  ssthresh를 3으로 변경 & cwnd 크기를 1로 줄임
5.  다시 Slow Start로 시작하여 임계점에 도달하면 AIMD를 시작

---

### TCP Reno

TCP Tahoe 이후에 나온 정책으로, Tahoe와 마찬가지로 Slow Start로 시작하여 임계점을 넘어서면 AIMD을 사용.

다만, Tahoe와는 다르게 **3 ACK Duplicated와 Timeout 혼잡 상황을 구분**한다.

![reno](https://github.com/user-attachments/assets/4497dc99-9911-45aa-b721-4ac111bf10e6)


1.  중복 ACK가 발생했을 때, AIMD처럼 반으로만 줄이고 sshthresh를 줄어든 윈도우 값으로 설정  
    **👉** **빠른 회복**
2.  타임아웃에 의해서 데이터가 손실되면 Tahoe와 마찬가지로 윈도우 크기를 바로 1로 줄이고 Slow Start 진행  
    이때 ssthresh를 변경X

> 즉, Reno는 ACK 중복은 Timeout에 비해 그리 큰 혼잡이 아니라고 가정하고  
> 혼잡 윈도우 크기를 1로 줄이지도 않는다는 점에서 **혼잡 상황의 우선 순위를 둔 정책**이라 볼 수 있음

---

## UDP가 흐름/혼잡 제어를 하지 않는 이유 ?

UDP는 기본적으로 **흐름 제어나 혼잡 제어를 하지 않음.  
**그 이유는 UDP의 **디자인 목표**와 **역할**에 있음

#### 1\. UDP는 단순하고 빠른 전송을 목표로 함

-   **연결 없음(connectionless)**: 연결 설정 과정 없이 바로 전송
-   **비신뢰성(unreliable)**: 재전송, ACK 없음
-   **순서 보장 없음**: 패킷 순서 보장 X

→ 이런 구조 덕분에 **오버헤드가 매우 적고**,  
**실시간성과 속도**가 중요한 애플리케이션에 적합

---

#### 2\. 흐름 제어, 혼잡 제어는 “상위 애플리케이션”이 책임짐

TCP와는 달리, UDP는 **네트워크의 상태를 감지하거나, 상대의 처리 능력을 고려하지 않음**

대신 **애플리케이션이 직접** 패킷 속도 조절. 손실 감지/복구, 흐름 제어 등을 구현

> 📌 VoIP, 실시간 게임, 스트리밍 등에서는 약간의 손실보다는 지연 최소화가 더 중요하므로 UDP를 선호함

---

####  3. 혼잡 제어를 하면 “속도”라는 장점이 사라짐

UDP에 TCP처럼 혼잡 제어를 넣으면 RTT 측정, 윈도우 계산, 전송 속도 조절 같은 로직이 들어가야 함  
**👉 속도 이점이 없어짐**

| **이유** | **설명** |
| --- | --- |
| **목적이 다름** | UDP는 **빠르고 단순한 데이터 전송용** |
| **책임 분리** | 흐름/혼잡 제어는 **애플리케이션이 직접 처리** |
| **성능 우선** | **지연이 더 중요**한 환경 (VoIP, 게임 등) |
| **TCP와 구분** | TCP가 이미 혼잡 제어를 제공하므로, 선택 가능성 보장 |

---

#### 참고

[https://steady-coding.tistory.com/507](https://steady-coding.tistory.com/507)
