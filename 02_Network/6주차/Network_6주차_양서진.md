# TCP, UDP, 흐름 제어 / 흐름 제어

## TCP, UDP 특징
![image](https://github.com/user-attachments/assets/f25c4fcf-3fee-4e8e-8bb8-9a90440f34f5)


### TCP (Transmission Control Protocol)

<aside>
💡

인터넷상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜 

</aside>

일반적으로 TCP와 IP를 함께 사용한다.

IP → 데이터의 배달을 처리한다.

TCP → 패킷을 추적 및 관리하게 된다.

```java
TCP는 연결형 서비스를 지원하는 프로토콜로 인터넷 환경에서 기본으로 사용
```

- 연결 지향 방식으로 패킷 교환 방식을 사용 (가상 회선 방식이 아니다.)
- 3-way handshaking 과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제.
- 흐름 제어 및 혼잡 제어
- 높은 신뢰성을 보장
- UDP보다 속도가 느리다.
- 전이중(Full-Duplex), 점대점(P2P) 방식이다.

연결 지향 방식 → 패킷을 전송하기 위한 논리적 경로를 배정

3-way handshaking 과정 → 목적지와 수신지를 확실히 하여 정확한 전송을 보장하기 위해서 세션을 수립하는 과정

따라서 연속성보다 신뢰성있는 전송이 중요할 때에 사용하는 프로토콜이다. 

(파일 전송)

### TCP 서버의 특징

- 서버소켓은 연결만을 담당한다.
- 연결과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용된다.
- 서버와 클라이언트는 1대1로 연결된다.
- 스트림 전송으로 전송 데이터의 크기가 무제한이다.
- 패킷에 대한 응답을 해야하기 때문에 (시간 지연, CPU 소모) 성능이 낮다.
- 스트리밍 서비스에 불리하다. (손실된 경우 재전송 요청을 하기 때문)

Q) 패킷(Packet)이란?

인터넷 내에서 데이터를 보내기 위한 경로배정(라우팅)을 효율적으로 하기 위해서 데이터를 여러 개의 조각들로 나누어 전송을 하는데 이때, 이 조각을 패킷이라고 합니다.

Q) TCP는 패킷을 어떻게 추적 및 관리하나요?

위에서 데이터는 패킷단위로 나누어 같은 목적지(IP계층)으로 전송된다고 설명하였습니다. 예를 들어 한줄로 서야하는 A,B,C라는 사람(패킷)들이 서울(발신지)에서 출발하여 부산(수신지)으로 간다고 합시다. 그런데 A,B,C가 순차적으로 가는 상황에서 B가 길을 잘못 들어서 분실되었다고 합시다. 하지만 목적지에서는 A,B,C가 모두 필요한지 모르고 A,C만 보고 다 왔다고 착각할 수 있습니다. 그렇기 때문에 A,,B,C라는 패킷에 1,2,3이라는 번호를 부여하여 패킷의 분실 확인과 같은 처리를 하여 목적지에서 재조립을 합니다. 이런 방식으로 TCP는 패킷을 추적하며, 나누어 보내진 데이터를 받고 조립을 할 수 있습니다.

### UDP(User Datagram Protocol)

<aside>
💡

데이터를 데이터그램 단위로 처리하는 프로토콜

</aside>

데이터그램 : 독립적인 관계를 지니는 패킷

TCP와 달리 UDP는 비연결형 프로토콜이다.

즉 연결을 위해 할당되는 논리적인 경로가 없다. 따라서 각각의 패킷은 다른 경로로 전송된다. 각각의 패킷은 독립적인 관계를 지니고, 데이터를 서로 다른 경로로 독립적으로 처리하게 된다.

- 비연결형 서비스로 데이터그램 방식을 제공한다
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮다
- TCP보다 속도가 빠르다

비연결형 서비스 이기에 연결을 설정하고 해제하는 과정이 존재하지 않는다.

서로 다른 경로로 독립적으로 처리함에도 패킷에 순서를 부여하여 재조립을 하거나, 흐름 제어 또는 혼잡 제어와 같은 기능도 처리하지 않기에 TCP보다 속도가 빠르다.

네트워크 부하가 적지만, 신뢰성 있는 데이터의 전송을 보장하지 못한다.

신뢰성보다는 연속성이 중요한 서비스에서 사용되고, 실시간 스트리밍에 자주 사용된다.

### UDP 서버의 특징

- UDP에는 연결 자체가 없어서(connect 함수 불필요) 서버 소켓과 클라이언트 소켓의 구분이 없다.
- 소켓을 활용해 IP와 PORT를 기반으로 데이터를 전송한다.
- 서버와 클라이언트는 1대1, 1대N, N대M 등으로 연결될 수 있다.
- 데이터그램(메세지) 단위로 전송되며 그 크기는 65535바이트로, 크기가 초과하면 잘라서 보낸다.
- 흐름제어(flow control)가 없어서 패킷이 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.
- 파일 전송과 같은 신뢰성이 필요한 서비스보다 성능이 중요시 되는 경우에 사용된다.

Q) 흐름제어(Flow Control)와 혼잡제어(Congestion Control)이란?

흐름제어는 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것입니다. 예를 들어 송신하는 곳에서 감당이 안되게 데이터를 빠르게 많이 보내면 수신자에서 문제가 발생하기 때문입니다.

혼잡제어는 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것입니다. 만약 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 막습니다.

## TCP VS UDP

![image2](https://github.com/user-attachments/assets/c24999da-94ab-44dd-8e4f-f58e02e2b933)


## TCP의 신뢰성 보장 메커니즘 : Sequence Number, ACK, 재전송, 타이머 등

![image3](https://github.com/user-attachments/assets/250945b5-0589-4a37-b2a4-f87bdc2dadf2)


**Sequence Number([순서 번호](http://terms.naver.com/entry.nhn?docId=2271842&ref=y)) :**

송신자가 지정하는 순서 번호다. 세그먼트 전송 과정에서 전송되는 바이트 수를 기준으로 증가한다. 즉, TCP에서는 전송 데이터의 각 바이트마다 순서 번호가 존재한다. 크기가 32비트인 필드로 표시할 수 있고 최대 범위가 2^ 32개 가능해 크기가 충분히 크므로 순서 번호가 쉽게 중복되지 않는다. 송신자가 최초 데이터를 전송할 때는 임의의 순서 번호를 선택해 전송한다. 이는 전송 연결이 예기치 않은 이유로 끊어졌을 때 순서 번호가 혼선되는 것을 방지하기 위함이다.

Acknowledgement Number(응답 번호) :

수신 프로세스가 제대로 수신한 바이트의 수를 응답하기 위해 사용한다. 필드 값은 ACK 플래그 비트가 지정된 경우에만 유효하며, 다음에 수신을 기대하는 데이터의 순서 번호를 표시해야 한다. ACK 응답을 받은 송신 프로세스는 Acknowledgement Number-1까지의 모든 데이터가 올바로 전송되었음을 확인할 수 있다. 연결 설정이나 연결 해제처럼 데이터 세그먼트가 없는 경우에도 순서 번호가 1씩 증가한다.

![image4](https://github.com/user-attachments/assets/dfd70f1c-32be-4d97-940a-3618d73d7f48)


SYN : Synchronize

TCP는 **3-way handshake**라는 과정을 통해 연결

이 과정의 **첫 번째 단계**에서 사용되는 게 바로 **SYN 플래그**

시퀀스 번호(Sequence Number)를 설정해 통신의 **순서를 보장**

## 3-Way Handshake 과정

1. **클라이언트 → 서버 : SYN**
    - "안녕! 나랑 연결할래? (시작 번호는 이거야!)"
2. **서버 → 클라이언트 : SYN + ACK**
    - "좋아! 나도 연결할게! (내 시작 번호는 이거고, 네 것도 확인했어!)"
3. **클라이언트 → 서버 : ACK**
    - "모든 준비 완료! 이제 데이터 주고받자!"

![image5](https://github.com/user-attachments/assets/aacebd5b-ce84-45c4-9d4b-94bc02091f93)


위 사진과 같이 수신한 패킷의 Sequence Number와 Data의 크기에 따라 ACK 번호가 결정되게 되는데 결정할 때 사용하는 공식은 **"SEQ + (Data Size)"** 이다.

그러나 여기서 반드시 기억해야 할 점은 Data Size가 0이라면 같은 ACK을 반복하게 된다. 이 것을 방지해서 **받은 패킷의 Data Size가 0이라면 Sequnce 번호에 1을 더한 값을 ACK으로 설정**한 후 패킷을 전달하게 된다.

그래서 A는 데이터를 보낸 후 B한테 까지 정상적으로 데이터가 도착했으면 받아야 할 ACK 값인 1461을 받지 못하면 TCP의 에러제어에 의해서 패킷을 재전송 하게된다.

**한마디로 B가 A에게 ACK:1461을 전송하는 것의 의미는 "너가 보낸 패킷의 내 대답은 1461이야. 그리고 너 다음 패킷 보낼 때는 Sequence번호를 1461을 사용해서 보내도록 해!" 이다.**

### 타이머

![image6](https://github.com/user-attachments/assets/222be476-f41c-4d01-b92a-f3b162a19773)



### **Retransmission Timer (재전송 타이머)**

- **설명**: 송신 측에서 **패킷을 보냈지만 ACK가 오지 않을 때**, 일정 시간 기다린 후 **다시 보내기 위한 타이머**
- **역할**: 네트워크 혼잡/손실 상황에 대응함.
- **관련 변수**: RTT(Round Trip Time)를 기반으로 설정됨.

---

### **Persistence Timer (지속성 타이머)**

- **설명**: 수신 측의 수신 버퍼가 **꽉 찼을 때** 사용돼.
- **역할**: 송신 측이 "버퍼 아직 꽉 찼니?" 하고 **주기적으로 확인**하게 도와줌.
- **이유**: 윈도우 크기(Window size)가 0일 때, deadlock을 방지하기 위해.

---

### **Keepalive Timer (유지 타이머)**

- **설명**: 오랫동안 데이터 전송이 없을 때, **연결이 살아있는지 확인**하는 타이머야.
- **역할**: 유휴 연결을 감지하고, **끊어진 연결을 닫는 데 도움**을 줘.

---

### **Time-Wait Timer**

- **설명**: 연결 종료 후 일정 시간 동안 **그 포트를 재사용하지 않기 위해 대기하는 타이머**.
- **시간**: 일반적으로 **2 * Maximum Segment Lifetime (MSL)** = 약 2분.
- **역할**: 지연된 패킷이 다시 나타나는 걸 방지하고, **안전한 종료** 보장.

**RTT (Round Trip Time)**

---

한 패킷이 송신 측에서 수신 측으로 갔다가 다시 ACK 응답이 돌아오는 데 걸리는 시간.

👉 재전송 타이머 설정 기준이 됨.

---

**RTO (Retransmission Timeout)**

---

재전송 타이머의 시간 값.

👉 RTT를 기반으로 계산되며, 이 시간이 지나면 패킷을 다시 보냄.

---

**Zero Window**

---

수신 측 버퍼가 꽉 차서 더 이상 데이터를 받을 수 없다고

**윈도우 크기(Window size)를 0**

으로 보냄.

👉 이때 Persistence Timer가 활성화됨.

---

**MSL (Maximum Segment Lifetime)**

---

네트워크를 통해 떠다니는 패킷이 살아있는 최대 시간.

👉 Time-Wait 타이머는 보통 2 × MSL (예: 2분).

---

## TCP의 흐름 제어 (Flow Control) : 슬라이딩 윈도우

- 수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법이다.
    - 윈도우란 전송, 수신 스테이션 양쪽에서 만들어진 버퍼의 크기를 이야기 한다.
    - 윈도우의 크기 - (가장 최근 ACK로 응답한 프레임 수 ) - (이전에 ACK 프레임을 보낸 프레임 수)

![image7](https://github.com/user-attachments/assets/da7a7fa6-cdcb-4137-beb5-e489a5f6a9c9)


송신 측에서는 1~5까지의 프레임이 전송이 가능합니다. 따라서 1~5까지를 window에 담습니다. 그리고 먼저 1, 2를 전송하게 됩니다. 그럼 송신측의 윈도우는 (이미지에는 표현되지 않았지만) 3, 4, 5만큼 윈도우의 크기가 줄어듭니다.

이때 수신측에서 1, 2 데이터를 정상적으로 수신했음을 알리는 ACK를 송신측으로 보냅니다. 송신측은 ACK를 받고 ACK의 프레임 수만큼 오른 쪽으로 윈도우의 경계를 확장시킵니다.

## TCP의 혼잡 제어 (Congestion Control) : AIMD, Slow Start

송신 측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법.

송신 측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 데이터를 전달하는데, 만약 하나의 라우터에 데이터가 몰려 혼잡할 경우, 자신에게 온 데이터를 모두 처리할 수 없다.

송신측은 다시 데이터를 재전송 하게 되고, 데이터가 가중되어 오버플로우, 데이터 손실 발생

이러한 위험을 줄이기 위해 송신측에서 보내는 데이터의 전송 속도를 강제로 줄이기 되는데 이를 혼잡 제어 라고 함

### AIMD 합 증가 / 곱 감소

처음 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window를 1씩증가시켜 전송하는 방법입니다. 

만일 패킷 전송을 실패하거나 일정 시간을 넘기게 되면 패킷을 보내느 속도를 절반으로 줄이게 됩니다. 이러한 방식을 사용하게 되면 모든 호스트가 공평하게 네트워크를 사용한다는 장점이 있지만 초기의 네트워크 대역폭을 사용하지 못하면 오랜 시간이 걸리고, 네트워크가 혼잡해지는 상황을 미리 감지할 수 없다는 단점이 있습니다. 따라서 사후처리로 네트워크가 혼잡해지고 나서야 대역폭을 줄여야 합니다.

ex) cwnd = 4일 때 한 RTT에 4개 보냄 → 4개의 ACK 받음

→ 그래도 cwnd는 **+1만 증가**해서 → 5가 됨

cwnd : 송신측의 윈도우 사이즈

### Slow start

앞서 이야기 했듯이 합 증가/ 곱 감소 방식은 네트워크가 혼잡해지는 상황을 미리 감지할 수 없습니다. 따라서 전송 속도를 올리는데 걸리는 시간이 너무 길다는 단점이 있습니다. 이러한 단점을 극복한 방법으로 slow start 방식이 있습니다.

slow start 방식 역시 합 증가 / 곱 감소 방식과 마찬가지로 패킷을 하나씩 보내기 시작합니다. 하지만 이 방식은 패킷이 문제없이 도착하면 ACK 패킷마다 window 크기를 1씩 늘립니다. 

즉 하나의 주기가 끝나면 window의 크기가 2배가 됩니다. 따라서 전송 속도가 합 증가/곱 감소 방식과 다르게 지수 꼴로 증가합니다.

대신 혼잡 현상이 발생하면 window 크기를 1로 줄여버립니다. 합 증가 / 곱 감소 방식과 마찬가지로 처음에는 네트워크의 수용량을 예상할 수 없지만, 한번 혼잡 현상을 경험하면 네트워크 수용량을 어느 정도 예상할 수 있으므로 혼잡 현상이 발생하였던 window 크기의 절반까지는 이전처럼 지수 꼴로 window의 크기를 증가시키고, 그 이후부터는 완만하게 1씩 증가시킵니다.

> 일정 임계값(ssthresh)에 도달하면 AIMD 방식으로 전환됩니다.
> 

ex) cwnd = 4일 때 한 RTT에 4개 보냄 → 4개의 ACK 받음

→ 각각 +1씩 →**최종적으로 +4 증가해서 8이 됨**

## UDP가 흐름/혼잡 제어를 하지 않는 이유

UDP의 목적은 빠른 전송이다.

손실보다는 지연이 없는 것이 더 중요하고, 흐름/혼잡 제어를 하면 속도가 늦어질 수 있다.

단, 필요한 제어는 애플리케이션 레벨에서 구현할 수 있다.

## DHCP (UDP와 관련)

DHCP (Dynamic Host Configuration Protocol)는 네트워크에 새로 연결된 장치에게 자동으로 IP 주소, 서브넷 마스크, 게이트웨이, DNS 등을 할당해주는 프로토콜

## DHCP는 왜 UDP를 사용할까?

### 1) 클라이언트는 처음엔 **IP가 없다**

- IP가 없으면 **TCP 연결을 시작할 수 없음** → TCP는 연결을 맺기 전에 IP가 필요함
- 그래서 **비연결형 UDP**를 사용

### 2) 브로드캐스트가 필요하다

- DHCP는 "누가 나한테 IP 줄 수 있나요?"라고 **전체 네트워크에 물어봄**
    
    (→ 이걸 DHCPDISCOVER라고 부름)
    
- TCP는 브로드캐스트 불가, UDP는 브로드캐스트 OK!

### 3) 짧고 단순한 통신

- DHCP는 4번의 메시지로 끝남 (DISCOVER → OFFER → REQUEST → ACK)
- 복잡한 TCP 연결 유지, 종료 과정이 필요 없음

DHCP는 IP 없는 장치에게도 설정 정보를 줄 수 있어야 하므로, **비연결형이며 브로드캐스트가 가능한 UDP를 사용**하며, 포트 번호는 서버 67번, 클라이언트 68번을 사용한다.

## 멀티플렉싱과 디멀티플렉싱(포트 번호와 TCP/UDP 연결)

| **멀티플렉싱** | 여러 애플리케이션(프로세스)의 데이터를 하나의 전송 채널(소켓)로 모아 전송하는 것 |
| --- | --- |

| **디멀티플렉싱** | 도착한 데이터를 **포트 번호에 따라 다시 해당 애플리케이션에 분배**하는 것 |
| --- | --- |

UDP는 비연결형 프로토콜이다. 데이터를 보낼 때 따로 연결을 맺지 않고 그냥 던진다. 
편지처럼 주소만 적어서 우체통에 넣는 셈이다.

디멀티플렉싱에서도 UDP는 목적지 포트 번호만 보고 어떤 소켓으로 데이터를 전달할지 결정한다. 즉, 포트 번호만 일치하면 어떤 출발지에서 오든 간에 같은 소켓으로 전달된다.

TCP는훨씬 정교하다. TCP는 연결형 프로토콜이다. 데이터를 보내기 전에 먼저 상대와 연결을 맺고, 그 연결을 유지하면서 데이터를 주고받는다.이 때 서버 입장에서 보면 여러 클라이언트가 동시에 연결할 수 있다. 따라서 서버는 각 클라이언트와의 연결을 정확하게 구분해서 관리해야 한다.

다음 4가지 정보(4-tuple)를 모두 확인한다.

1. 출발지 IP 주소
2. 출발지 포트 번호
3. 목적지 IP 주소
4. 목적지 포트 번호

<img width="417" alt="image8" src="https://github.com/user-attachments/assets/1312f4fb-fd7c-409d-a577-2fdf9b3f8081" />



이 둘은 모두 동일한 서버 IP와 포트로 연결을 시도하지만, 출발지 IP가 다르다. 두 연결은 모두 목적지 포트 80이지만, 4-tuple 전체가 다르기 때문에 TCP는 이를 서로 다른 연결로 처리한다.


