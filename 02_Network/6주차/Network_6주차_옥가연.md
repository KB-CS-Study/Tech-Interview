# TCP, UDP, 흐름 제어 / 혼잡 제어

## TCP, UDP 특징

### TCP (Transmission Control Protocol)

- 연결 지향성 : 통신을 시작하기 전에 송신자와 수신자 간에 연결을 설정
  - 이를 위해 3-way 핸드 셰이크 과정을 거침
- 신뢰성 : 데이터의 전송의 신뢰성을 보장
  - 데이터가 올바르게 전달되었는지 확인하기 위해 ACK(acknowledgment)메시지를 사용
- 흐름 제어 : 송신자가 수신자의 수신 능력을 초과하지 않도록 조절
  - 이를 위해 윈도우 크기 조절과 같은 메커니즘을 사용
- 오류 제어 : 데이터 전송 중 발생한 오류를 검출하고 수정
  - 데이터가 손상되거나 누락된 경우, 재전송 메커니즘을 사용
- 혼잡 제어 : 네트워크 혼잡을 방지하기 위해 송신 속도를 조절

### UDP (User Datagram Protocol)

- 비연결성 : 연결 설정 과정 없이 데이터를 전송
- 단순함 : 데이터 전송을 위한 오버헤드가 적음
  - TCP와 달리 신뢰성, 흐름 제어, 혼잡 제어를 제공하지 않음
- 빠른 전송 : TCP보다 빠르게 데이터를 전송할 수 있음
  - 이는 실시간 응용 프로그램에 유리
- 데이터그램 : 데이터는 독립적인 데이터그램 단위로 전송
  - 각 데이터그램은 독립적으로 처리되며 순서가 보장되지 않음

<hr />

## TCP VS UDP

| 항목       | TCP                                             | UDP                                                 |
|----------|-------------------------------------------------|-----------------------------------------------------|
| 패킷 교환 방식 | 가상회선 패킷 교환 방식                                   | 데이터그램 패킷 교환 방식                                      |
| 신뢰성      | O                                               | X                                                   |
| 오류 검사    | 재전송, 체크섬                                        | 체크섬                                                 |
| 패킷의 순서 보장 | O                                               | X                                                   |
| 헤더 길이    | 20-60바이트 가변 길이                                  | 8바이트 고정 길이                                          |
| 연결 보장    | 연결을 보장함. 3-way 핸드셰이크로 연결을 맺고 4-way 핸드셰이크로 연결을 해제 | 연결을 보장하지 않음. 그냥 데이터를 보냄. 연결을 유지하고 해제하는 데 드는 비용이 없음. |
| 브로드캐스트 지원 | X                                               | O                                                   |
| 속도       | 상대적으로 느림                                        | 상대적으로 빠름                                           |

<hr />

## 오류검사 메커니즘

1. 재전송 : 시간 초과 기간이 지나면 서버는 전달되지 않은 데이터에 대해 재전송을 시도 
2. 체크섬 : 체크섬을 통해 무결성을 평가
   - 즉, 송신된 데이터의 체크섬과 수신된 데이터의 체크섬 값을 비교해서 올바르게 왔는지를 확인

<hr />

## TCP의 연결 성립 : 3-way 핸드셰이크

TCP(Transmission Control Protocol)는 신뢰성 있는 데이터 전송을 보장하기 위해 
3-WAY 핸드셰이크 과정을 통해 연결을 설정

1. SYN 단계(Synchronize) : 클라이언트가 서버에 연결 요청을 보냄
    - 클라이언트는 자신의 ISN(Initial Sequence Number)을 포함하여 SYN 패킷을 서버에 전송
2. SYN + ACK 단계(Synchronize - Acknowledge) : 서버는 클라이언트로부터 SYN 패킷을 수신한 후, 자신의 ISN을 포함한 SYN 패킷과 클라이언트의 SYN에 대한 응답으로 승인번호를 클라이언트의 ISN + 1로 설정하여 ACK 패킷을 클라이언트에게 전송
3. ACK 단계 : 클라이언트는 서버로부터 SYN + ACK 패킷을 수신한 후, 서버의 ISN + 1을 승인번호로 설정하여 ACK 패킷을 서버에 전송

```
클라이언트                            서버
    |                                  |
    | ---------- SYN (ISN=c) --------> |
    |                                  |
    | <----- SYN (ISN=s) + ACK ------- |
    |        (ACK=c+1)                 |
    |                                  |
    | --------- ACK (ACK=s+1) -------> |
    |                                  |
```

![3-way 핸드셰이크](https://velog.velcdn.com/images/leesfact/post/d1af4852-e695-41ab-9f25-e9dea26559d9/image.png)

### 클라이언트와 서버의 상태

![클라이언트와 서버의 상태](https://velog.velcdn.com/images/leesfact/post/4eeb148e-d89b-4f04-9302-9302c6bfaab0/image.png)

```
1.  클라이언트 -> 서버: SYN (클라이언트 ISN 포함)
      •	클라이언트 상태: CLOSED -> SYN-SENT
      •	클라이언트가 서버에 연결을 요청하는 SYN 패킷을 보냅니다. 이 패킷에는 클라이언트의 초기 시퀀스 번호(ISN)가 포함되어 있습니다.
      •	서버 상태: CLOSED -> LISTEN
      •	서버는 클라이언트의 요청을 기다리는 상태입니다. 이는 서버가 클라이언트의 SYN 패킷을 수신할 준비가 되었다는 의미입니다.
2.	서버 -> 클라이언트: SYN + ACK (서버 ISN 포함, 클라이언트 ISN + 1 승인번호)
      •	서버 상태: LISTEN -> SYN-RECEIVED
      •	서버가 클라이언트의 SYN 패킷을 수신하고, 자신의 ISN을 포함한 SYN 패킷과 클라이언트의 ISN + 1을 승인번호로 설정한 ACK 패킷을 클라이언트에 보냅니다.
      •	클라이언트 상태: SYN-SENT -> SYN-RECEIVED
      •	클라이언트는 서버의 SYN + ACK 패킷을 수신하고, 다음 단계로 넘어갑니다.
3.	클라이언트 -> 서버: ACK (서버 ISN + 1 승인번호)
      •	클라이언트 상태: SYN-RECEIVED -> ESTABLISHED
      •	클라이언트가 서버의 ISN + 1을 승인번호로 설정한 ACK 패킷을 서버에 보냅니다. 이로써 클라이언트는 연결이 설정되었음을 확인합니다.
      •	서버 상태: SYN-RECEIVED -> ESTABLISHED
      •	서버는 클라이언트의 ACK 패킷을 수신하고, 최종적으로 연결이 설정되었음을 확인합니다.
```

<hr />

## TCP의 연결 해제 : 4-way 핸드세이크와 TIME_WAIT

![4-way 핸드셰이크](https://velog.velcdn.com/images/leesfact/post/d8b44f82-3e09-426f-8be2-7a7853cfabba/image.png)

```
1.	클라이언트 -> 서버: FIN
	•	클라이언트 상태: ESTABLISHED -> FIN_WAIT_1
	•	클라이언트가 연결 종료를 요청하는 FIN 패킷을 서버에 보냅니다. 이 패킷은 더 이상 데이터를 보내지 않겠다는 의사를 표시합니다.
	•	서버 상태: ESTABLISHED -> CLOSE_WAIT
	•	서버가 클라이언트의 FIN 패킷을 수신합니다.
2.	서버 -> 클라이언트: ACK
	•	클라이언트 상태: FIN_WAIT_1 -> FIN_WAIT_2
	•	서버가 클라이언트의 FIN 패킷을 수신한 후, 확인 응답(ACK) 패킷을 클라이언트에 보냅니다.
	•	서버 상태: CLOSE_WAIT
	•	서버는 ACK 패킷을 보내고, 여전히 클라이언트로 데이터를 보낼 수 있는 상태를 유지합니다.
3.	서버 -> 클라이언트: FIN
	•	서버 상태: CLOSE_WAIT -> LAST_ACK
	•	서버가 자신의 데이터 전송을 완료한 후, 연결을 종료하겠다는 FIN 패킷을 클라이언트에 보냅니다.
	•	클라이언트 상태: FIN_WAIT_2 -> TIME_WAIT
	•	클라이언트는 서버의 FIN 패킷을 수신하고, 연결 종료를 확인합니다.
4.	클라이언트 -> 서버: ACK
	•	서버 상태: LAST_ACK -> CLOSED
	•	클라이언트가 서버의 FIN 패킷에 대한 확인 응답(ACK) 패킷을 서버에 보냅니다. 이로써 서버는 연결이 종료됨을 확인하고, 상태를 CLOSED로 변경합니다.
	•	클라이언트 상태: TIME_WAIT -> CLOSED
	•	클라이언트는 일정 시간 동안 TIME-WAIT 상태에 머무른 후, 연결이 완전히 종료됩니다.
```

### TIME_WAIT 상태

클라이언트가 서버의 마지막 FIN 패킷에 대한 ACK 패킷을 보낸 후 일정 시간 동안 연결을 유지하는 상태

1. 지연된 패킷 처리 :
네트워크 지연으로 인해 아직 전달되지 않은 패킷이 있을 수 있음
    - TIME_WAIT 상태는 이러한 패킷들이 모두 네트워크에서 사라질 때까지 기다림
2. 연결 재사용 방지 :
동일한 소스 포트와 목적지 포트를 사용하는 새로운 연결이 이전 연결의 잔여 패킷과 혼동되지 않도록 방지
   - TIME_WAIT 기간 동안 해당 포트 번호는 재사용되지 않음
3. 중복 FIN 패킷 처리 :
클라이언트가 보낸 마지막 ACK 패킷이 서버에 도달하지 않은 경우 서버는 FIN 패킷을 다시 보낼 수 있음
   - TIME_WAIT 상태에서 클라이언트는 이러한 중복 FIN 패킷에 대해 ACK 응답을 다시 보낼 수 있음

#### TIME_WAIT 상태를 두는 이유?

- 데이터 무결성 보장 :
  - TIME_WAIT 상태를 유지함으로써 네트워크 지연으로 인해 발생할 수 있는 데이터 손실이나 중복을 방지하여 데이터의 무결성을 보장
- 신뢰성 유지 :
  - 네트워크 통신의 신뢰성을 유지하고 데이터 전송 과정에서 발생할 수 있는 여러 문제를 해결

#### TIME_WAIT 지속 시간

- TIME_WAIT 상태의 지속 시간은 운영 체제에 따라 다를 수 있지만 일반적으로 최대 세그먼트 수명(MSL, Maximum Segment Lifetime)의 두배로 설정
    - MSL은 네트워크에서 패킷이 살아남을 수 있는 최대 시간을 의미

<hr />

## TCP의 흐름 제어 (Flow Control)

- 수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제가 생긴다.
- 수신측에서 제한된 저장 용량을 초과한 이후에 도착하는 데이터는 손실 될 수 있으며, 만약 손실 된다면 불필요하게 응답과 데이터 전송이 송/수신 측 간에 빈번이 발생한다.
- 이러한 위험을 줄이기 위해 송신 측의 데이터 전송량을 수신측에 따라 조절해야한다.
- 해결방법
  - Stop and Wait : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법
  - Sliding Window : 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인응답없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어기법
    - 동작방식 : 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 이 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송
    - Window : TCP/IP를 사용하는 모든 호스트들은 송신하기 위한 것과 수신하기 위한 2개의 Window를 가지고 있다. 호스트들은 실제 데이터를 보내기 전에 '3 way handshaking'을 통해 수신 호스트의 receive window size에 자신의 send window size를 맞추게 된다.

<hr />

## TCP의 혼잡 제어 (Congestion Control)

- 송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 만약 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없게 된다. 이런 경우 호스트들은 또 다시 재전송을 하게되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손신을 발생시키게 된다. 따라서 이러한 네트워크의 혼잡을 피하기 우해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이게 되는데, 이러한 작업을 혼잡제어라고 한다.
- 또한 네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 혼잡이라 하며, 혼잡 현상을 방지하거나 제거하는 기능을 혼잡제어라고 한다.
- 흐름제어가 송신측과 수신측 사이의 전송속도를 다루는데 반해, 혼잡제어는 호스트와 라우터를포함한 보다 넓은 관점에서 전송 문제를 다루게 된다.
- 해결방법
  - AIMD(Additive Increase / Multiplicative Decrease)
    - 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법
    - 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄인다.
    - 공평한 방식으로, 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형상태로 수렴하게 되는 특징이 있다.
    - 문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.
  - Slow Start (느린 시작)
    - AIMD 방식이 네트워크의 수용량 주변에서는 효율적으로 작동하지만, 처음에 전송 속도를 올리는데 시간이 오래 걸리는 단점이 존재했다.
    - Slow Start 방식은 AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 1씩 늘려준다. 즉, 한 주기가 지나면 window size가 2배로 된다.
    - 전송속도는 AIMD에 반해 지수 함수 꼴로 증가한다. 대신에 혼잡 현상이 발생하면 window size를 1로 떨어뜨리게 된다.
    - 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있다.
    - 그러므로 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수 함수 꼴로 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.
  - Fast Retransmit (빠른 재전송)
    - 빠른 재전송은 TCP의 혼잡 조절에 추가된 정책이다.
    - 패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다.
    - 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있다.
    - 중복된 순번의 패킷을 3개 받으면 재전송을 하게 된다. 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄이게 된다.
  - Fast Recovery (빠른 회복)
    - 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법이다. 이 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다.

<hr />

## UDP가 흐름/혼잡 제어를 하지 않는 이유

1. 설계 철학: 단순함과 속도 중시
   - UDP는 "최소한의 오버헤드"와 빠른 데이터 전송을 목표로 설계된 프로토콜
   - TCP와 달리 연결 설정 없이 데이터를 보내기 때문에 초기 지연이 없고, 구현도 단순
   - 흐름/혼잡 제어를 포함하면 패킷 전송 속도가 느려지고, 프로토콜 구조가 복잡해짐.
   - 실시간성이 중요한 서비스(예: VoIP, 스트리밍, 게임)는 지연보다 손실을 감수함.
2. 비연결성(Connectionless) 프로토콜
   - UDP는 연결을 설정하지 않고 데이터를 보내는 비연결형 프로토콜
   - 흐름 제어는 수신자의 수신 능력을 고려해 전송 속도를 조절하는 메커니즘인데,
   - 연결 상태를 추적하지 않기 때문에 수신자의 상태를 알 수 없음 → 흐름 제어 불가능.
3. 수신 확인(ACK)이 없음
   - TCP는 각 패킷에 대해 수신 여부를 확인(ACK) 받으며, 이를 통해 혼잡 상황을 감지
   - UDP는 이러한 확인 절차가 없기 때문에 혼잡 상태를 인지하거나 대응할 수 없음.
4. 애플리케이션 책임
   - UDP는 단순한 전송만 제공하고, 필요한 기능은 애플리케이션이 직접 구현하게 함.
   - 예: RTP(Real-time Transport Protocol)는 UDP 위에 동작하며, 자체적으로 순서 지정과 재전송을 구현.

<hr />

## DHCP

- 네트워크에서 컴퓨터 및 기타 네트워크 장치들에게 자동으로 IP주소와 관련 네트워크 설정을 할당하는 프로토콜
- 네트워크 관리자가 수동으로 IP주소를 할당할 필요가 없음
- IP주소의 중복 사용 최소화, 주소 관리를 효율적으로 도움
- 프로토콜 계층 : 애플리케이션 계층
- 전송 계층 프로토콜 : UDP 사용
- 작동 방식
  1. Discover : 클라이언트가 네트워크에 IP 할당 요청 (브로드캐스트)
  2. Offer : 서버가 IP 및 설정 정보를 제안
  3. Request : 클라이언트가 제안받은 IP를 요청
  4. Acknowledgement : 서버가 IP 할당 완료를 알림
- DHCP에서 UDP를 사용하는 이유
  - 클라이언트는 아직 IP가 없음 → TCP 연결 불가
  - 브로드캐스트 필요 → TCP는 브로드캐스트 지원 안 함
  - 간단한 요청/응답 → 연결 유지 필요 없음 → UDP 적합
  - 지연보다 빠른 응답 중요 → UDP의 저지연 특성 활용

<hr />

## 멀티플렉싱과 디멀티플렉싱

### 멀티플렉싱

여러 개의 데이터 스트림을 하나의 물리적 통신 채널을 통해 동시에 전송할 수 있도록 하는 기술이다. 
네트워크에서 이 과정은 전송 계층(Transport Layer)에서 주로 이루어진다.
- 예시 : 웹 브라우저, 이메일 클라이언트, 파일 전송 프로그램 등 여러 애플리케이션이 동시에 작동하며 각각의 데이터를 전송하는 경우, 이 데이터들이 모두 하나의 네트워크 연결을 공유한다.

### 디멀티플렉싱

멀티플렉싱된 데이터를 수신 측에서 다시 개별 데이터 스트림으로 분리하는 과정이다. 
수신된 데이터는 Transport 계층에서 포트 번호를 사용해 각 데이터가 어느 애플리케이션으로 가야 하는지 결정된다.
- 예시 : 웹 브라우저에서 오는 데이터는 포트 80 또는 443을 사용하고, 이메일 클라이언트에서 오는 데이터는 포트 25나 587을 사용하여 각각의 애플리케이션에 올바르게 전달된다.

### 디멀티플렉싱 과정

1. 데이터 수신: 데이터 패킷이 수신된다. 이 데이터는 TCP/UDP 패킷으로, 전송 계층에서 처리된다.
2. 헤더 분석: 수신된 패킷의 헤더를 분석하여 패킷의 출발지와 목적지 IP 주소, 포트 번호 등을 확인한다.
3. 포트 번호 매칭: 패킷의 목적지 포트 번호를 바탕으로 운영체제 내에서 해당 포트를 사용하고 있는 애플리케이션을 확인한다. 이 포트 번호에 따라 각 패킷이 어느 애플리케이션에 속하는지를 식별한다.
4. 데이터 전달: 식별된 애플리케이션으로 데이터를 전달한다. 운영체제는 포트 번호를 기준으로 데이터 패킷을 올바른 애플리케이션으로 분리하여 보낸다.
5. 애플리케이션 처리: 애플리케이션은 자신에게 전달된 데이터를 처리하여, 사용자에게 필요한 정보나 서비스를 제공한다.
