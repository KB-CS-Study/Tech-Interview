## 1. 로드 밸런싱

### 로드 밸런서란?

서버에 가해지는 부하를 분산해주는 장치 또는 기술

여러 대의 서버를 두고 서비스를 제공하는 분산 처리 시스템에서 필요한 기술

**장점**

- 애플리케이션 서버와 방문자 또는 클라이언트 간의 인터넷 트래픽을 지시하고 제어
- 애플리케이션의 가용성, 확장성, 보안 및 성능 향상

### L4 vs L7

한 대의 서버에 각기 다른 포트 번호를 부여하여 다수의 서버 프로그램을 운영하는 경우 최소 L4이상 로드밸런서 사용이 필요하다

|  | L4 | L7 |
| --- | --- | --- |
| 네트워크 계층 | 트랜스포트 계층(TCP, UDP)의 정보를 바탕으로 로드 분산 | 애플리케이션 계층(HTTP, FTP, SMTP)에서 로드를 분산 |
| 특징 | TCP/UDP 포트 정보를 바탕 | TCP/UDP 정보는 물론 HTTP의 URI, FTP의 파일명, 쿠키 정보등을 바탕으로 함 |
| 장점 | L7 로드밸런서보다 가격 저렴
데이터의 내용을 복화할 필요가 없기 때문에 안전
데이터 안을 들여다보지 않고 패킷 레벨에서만 로드를 분산하기 때문에 속도가 빠르고 효율이 높음 | 상위 계층 로드를 분산하기에 훨씨 ㄴ더 섬세한 라우팅이 가능
캐싱 기능을 제공
비정상적인 트래픽을 사전에 필터링할 수 있어 서비스 안정성이 높음 |
| 단점 | 패킷의 내용을 살펴볼 수 없기 때문에 섬세한 라우팅이 불가
사용자의 IP가 수시로 바뀌는 경우라면 연속적인 서비스를 제공하기 어려움 | 패킷 내용을 복호화해야 하기에 더 높은 비용을 지불해야 함
클라이언트가 로드 밸런서와 인증서를 공유해야하기 때문에 공격자가 로드밸런서를 통해서 클라이언트에 데이터에 접근할 보안 상의 위험성이 존재 |

### 로드밸런싱 알고리즘 종류

- 정적 로드 밸런싱
    - 고정된 규칙을 따르며 현재 상태와 무관
    - 라운드 로빈
        - 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식
        - 클라이언트의 요청을 순서대로 분배하기 때문에 여러 대의 서버가 동일한 스펙을 갖고 있다
        - 서버와의 연결(세션)이 오래 지속되지 않는 경우에 활용하기 적합
    - 가중 라운드로빈 방식
        - 각각의 서버마다 가중치를 매기고 가중치가 높은 서버에 클라이언트 요청을 우선적으로 배분
        - 주로 서버 트래픽 처리 능력이 상이한 경우 사용되는 부하 분산 방식
    - IP 해시 방식
        - 클라이언트의 IP주소를 특정 서버로 매핑하여 요청을 처리하는 방식
        - 사용자의 IP를 해싱하여 로드를 분배하기 때문에 사용자가 항상 동일한 서버로 연결되는 것을 보장
- 동적 로드 밸런싱
    - 트래픽을 배포하기 전에 서버의 현재 상태를 검사
    - 최소 연결 방식
        - 요청이 들어온 시점에 가장 적은 연결상태를 보이는 서버에 우선적으로 트래픽을 배분
        - 자주 세션이 길어지거나, 서버에 분배된 트래픽들이 일정하지 않은 경우에 적합한 방식
    - 최소 리스폰 타임
        - 서버에 현재 연결 상태와 응답시간을 모두 고려하여 트래픽을 분배
        - 가장 적은 연결상태와 가장 짧은 응답상태를 보이는 서버에 우선적으로 로드를 배분하는 방식

### 헬스 체크

- 로드 밸런서가 백엔드 서버의 상태를 주기적으로 검사하는 긴으
- HTTP 요청, TCP 연결 등을 통해 서버의 정상 동작 여부를 확인
- 상태가 비정상일 경우 해당 서버로의 트래픽 분산을 자동으로 중단

### **✔️ 체크 방식 예시**

- **HTTP 헬스 체크**: 특정 URL(/health, /ping) 호출해서 200 OK인지 확인
- **TCP 헬스 체크**: 지정 포트에 연결 가능한지만 확인 (간단하고 빠름)

### 장애 조치(Failover)

- 헬스 체크 결과 백엔드 서버가 죽었거나 응답이 없을 경우 해당 서버 대신 정상적인 다른 서버로 트래픽을 자동 전환 하는 것
- 특징
    - 무중단 서비스 제공을 위한 핵심 요소
    - 장애 발생 시 자동 전환을 통해 서비스 신뢰성 보장
    - 클라우드 로드밸런서(AWs, ALB, GCP LB)에서는 헬스 체크와 자동 장애 조치를 기본 제공

### DNS로 하는 로드밸런싱

- DNS서버가 하나의 도메인에 대해 여러 IP주소를 반환하여 로드밸런싱을 수행하는 방식
- 동작 방식
    - 클라이언트가 도메인 조회 요청을 할 때, DNS가 등록된 여러 IP중 하나 혹은 일부를 라운드 로빈 또는 가중 방식으로 반환
- 장점
    - 구현이 간단하고 로드밸런서 장비 없이도 적용 가능
    - 전세계 여러 지역의 서버에 대한 요청 분산이 가능
- 단점
    - 클라이언트 측 DNS 캐싱 때문에 로드밸런싱 효과가 제한됨
    - 헬스체크 미지원
        - DNS는 서버의 상태를 모르기 떄문에 죽은 서버의 IP가 반환될 수 있다
    - 실시간 장애 대응이 어렵다
        - TTL을 낮추는 방식으로 일부 대응 가능하나 완벽하지 않음
- 사용 예시 : CND(Couldflare, Akamai 등) 전세계 노드 분산, 다중 리전 애플리케이션에서 지역 간 트래픽 분산

## 2. 웹 서버 & WAS 관련

### 정적 vs 동적 페이지 차이

1. 정적 페이지
- 바뀌지 않는 페이지
- 항상 동일한 페이지를 반환함
    - image, html, css, javascript 파일과 같이 컴퓨터에 저장된 파일들
1. 동적 페이지
- 인자에 따라 바뀌는 페이지
- 인자의 내용에 맞게 동적인 contents를 반환
- 웹 서버에 의해 실행되는 프로그램을 통해 만들어진 결과물
- 개발자는 Servlet에 doGet() 메소드를 구현함
    - Servlet : was 위에서 돌아가는 자바 프로그램

### 웹 서버와 WAS의 역할 비교

![image.png](attachment:207c027c-1cd6-4816-af27-21a64da5aee1:image.png)

|
구분
|
웹 서버 (Web Server)
|
WAS (Web Application Server)
|
| --- | --- | --- |
|
개념
|
정적 컨텐츠 제공을 위한 서버 (HTTP 요청 응답)
|
동적 컨텐츠 처리를 위한 애플리케이션 서버
|
|
구성 요소
|
하드웨어: 웹 서버 설치 컴퓨터소프트웨어: HTTP 요청을 받아 정적 파일을 응답하는 프로그램
|
JSP, Servlet 등의 웹 애플리케이션 실행 환경을 제공하는 미들웨어
|
|
주요 역할
|
- 정적 컨텐츠 제공(HTML, CSS, JS, 이미지 등)
- 클라이언트 요청을 WAS로 전달
  |
- 동적 컨텐츠 처리(DB 조회, 비즈니스 로직 수행)
- 프로그램 실행 환경 제공- 트랜잭션, 스레드 관리
  |
  |
  동작 방식
  |
1. 클라이언트가 HTTP 요청
2. 정적 파일이면 직접 응답
3. 동적 요청이면 WAS로 전달
   |
1. 웹 서버로부터 요청 전달 받음
2. 비즈니스 로직 처리
3. DB 접근 후 결과 반환
   |
   |
   예시 소프트웨어
   |
   Apache, Nginx, IIS
   |
   Tomcat, JBoss, Jeus, WebSphere
   |
   |
   별칭
   |
   웹 서버
   |
   웹 컨테이너, 서블릿 컨테이너
   |
   |
   특징
   |
   빠름, 가벼움, 정적 자원에 최적화
   |
   무겁지만 동적 처리에 강함보안, 트랜잭션 처리, 분산 환경 지원
   |
   |
   결합 예시
   |
   Nginx + TomcatApache + JBoss 등
   |
   단독 실행도 가능하지만 보통 웹 서버와 함께 사용 |

### 웹 서버 ↔ WAS 협업 구조 (리버스 프록시 포함)

```sql
[Client]
   |
   ▼
[Web Server: Nginx / Apache]  ← 정적 컨텐츠 직접 응답
   |
   ▼
[WAS: Tomcat / Spring Boot]  ← 동적 요청만 전달받아 비즈니스 로직 처리
   |
   ▼
[DB / 외부 서비스]
```

- 웹 서버가 앞단에서 **정적 리소스 처리 + 보안 + 로드밸런싱** 등을 담당
- WAS는 오직 필요한 요청만 받아 **Servlet 실행 / DB 조회 / 로직 처리**

### 웹/WAS를 왜 분리해서 쓰는가?

**역할 분리를 통해 효율성과 안정성을 확보하기 위함**

- WAS는 **동적인 처리**(DB 조회, 로직 처리)에 집중하고,
- 웹 서버는 **정적 리소스 처리**에 집중하도록 분리함으로써 전체 서버의 **부하를 분산할 수 있다**

- **웹 서버가 필요한 이유**
    - 웹 페이지는 HTML 문서를 먼저 받고, 그 안의 이미지/스타일 등 정적 리소스는 **별도로 요청**돼.
    - 이 정적 파일들은 **굳이 WAS를 거치지 않아도 되기 때문에**, 웹 서버가 먼저 받아 처리하면 **응답 속도 향상** + **WAS 부하 감소**
    - **리버스 프록시 역할**도 수행하며, 여러 WAS 서버에 트래픽을 분산할 수 있음 (로드 밸런싱)
- WAS가 필요한 이유
    - 사용자의 요청에 따라 매번 결과가 달라지는 **동적 웹 페이지**를 생성해야 함
    - WAS는 클라이언트의 요청에 맞게 DB에서 데이터를 읽고, 비즈니스 로직을 수행해 **동적으로 결과를 생성**
    - JSP, Servlet을 실행하는 환경을 제공함으로써 웹 서비스의 핵심 기능을 담당
- WAS만으로 안되는 이유
    - 기술적으로 가능하지만, 비효율적이다
    - WAS가 정적 리소스까지 처리하면 → **과부하 발생**
    - **동적 응답 지연**, 성능 저하, **페이지 렌더링 속도 저하** 발생
    - 따라서 WAS는 복잡한 요청 처리에 집중시키고, 정적 처리는 웹 서버가 맡는 게 효율적!

| 목적 | 설명 |
| --- | --- |
| 성능 최적화 | 정적 리소스는 웹 서버가 빠르게 응답하고, WAS는 복잡한 로직에 집중 |
| 서버 자원 효율화 | WAS의 CPU, 메모리를 동적 처리에 집중 사용 가능 |
| 장애 대응 (Failover) | 웹 서버가 여러 WAS 중 정상적인 서버에만 요청 분산 가능 |
| 확장성 | 웹 서버 하나로 여러 대의 WAS를 연결하여 수평 확장 가능
|
| 보안 | WAS는 외부 직접 노출되지 않음 → 내부망 보호에 유리 |
| 유지보수 편의성 | 서비스 무중단 배포, Hot Deploy 등이 쉬움 (WAS 롤링 리스타트 가능) |

---