## ✅ 1. IP (Internet Protocol)

### 개념

- **IP는 컴퓨터 간 통신을 가능하게 하는 핵심 프로토콜**
- 주소 지정과 패킷 전달을 담당
- 통신 대상의 위치를 식별하고, 데이터를 어디로 보낼지 결정함

---

### IP 주소의 기능

| 역할 | 설명 |
| --- | --- |
| **식별** | 인터넷에 연결된 각각의 장치(Host)를 구분하기 위한 **논리 주소** |
| **라우팅** | 목적지까지 **패킷을 전달할 수 있도록 경로 지정** |
- 형식: `192.168.0.1` (IPv4), `2001:0db8::1` (IPv6)
- 고정 IP (Static) / 유동 IP (Dynamic) 등으로 나뉨

---

### IPv4 vs IPv6

| 항목 | IPv4 | IPv6 |
| --- | --- | --- |
| 주소 길이 | 32비트 (4바이트) | 128비트 (16바이트) |
| 표현 형식 | `192.168.0.1` | `2001:0db8:85a3::8a2e:0370:7334` |
| 주소 개수 | 약 42억 개 | 사실상 무한대 |
| 보안 | 옵션 | 기본 내장 (IPSec) |
| 헤더 구조 | 단순 | 확장 가능 구조 |
| NAT 필요성 | 필수 (주소 부족) | 불필요 (주소 풍부) |

> IPv6는 주소 고갈 문제 해결, 보안 강화, 패킷 처리 효율성을 위해 등장
> 

### IP 주소 vs MAC 주소 차이

| 항목 | IP 주소 | MAC 주소 |
| --- | --- | --- |
| 역할 | 논리 주소 (네트워크 계층) | 물리 주소 (데이터링크 계층) |
| 변경 가능 여부 | 변경 가능 | 보통 변경 불가 (하드웨어 고유값) |
| 범위 | 전 세계적 고유 식별자 | 같은 네트워크 내에서만 사용 |
| 예시 | `192.168.0.1` | `00:1A:2B:3C:4D:5E` |

보면 MAC 물리주소 답게 기기당 하나로 딱 정해져있음

### TTL (Time To Live)

- 패킷이 네트워크를 떠돌다가 **무한 루프에 빠지지 않도록** 만들어주는 제한 수명
- **각 라우터를 지날 때마다 1씩 감소**, 0이 되면 폐기됨
- 목적: 패킷이 영원히 돌지 않도록 함

> 예: ping 명령어에서 TTL을 확인할 수 있음
> 

### **Checksum 간단 개념**

- **목적**: 데이터 전송 중 **오류가 발생했는지 검사**
- **방법**: 전송 전 데이터를 수학적으로 계산한 값을 붙여 보내고, 수신자가 다시 계산하여 일치 여부 확인

### IPv4 Checksum vs TCP Checksum

| 항목 | IPv4 Checksum | TCP Checksum |
| --- | --- | --- |
| 위치 | IP 헤더 | TCP 세그먼트 전체 (헤더 + 데이터) |
| 목적 | 헤더의 손상 여부 확인 | 데이터까지 포함한 전송의 신뢰성 확보 |
| 적용 범위 | **IP 헤더만 검사** | **헤더 + 데이터 모두 검사** |
| 오류 복구 | 감지만 가능 | 감지만 가능 (복구는 TCP가 재전송으로 처리) |

> TCP는 더 신뢰성 있는 전송을 위해 더 넓은 범위를 검사함
> 

---

## ✅ 2. HTTP & HTTPS

## HTTP의 Stateless 특성

### Stateless란?

- **서버가 클라이언트의 상태 정보를 유지하지 않는 구조**
- 즉, **각 요청은 독립적이며 이전 요청의 맥락을 알 수 없음**

### 예시

1. 사용자가 로그인 요청을 보냄
2. 서버는 로그인 성공 응답을 보내지만, **그 이후의 요청에 대해 “이 사용자가 로그인한 사람인지” 기억하지 않음**
3. 그래서 매번 요청마다 사용자 정보(세션ID, 토큰 등)을 **명시적으로 전달**해야 함

| 장점 | 설명 |
| --- | --- |
| 확장성 ↑ | 서버가 클라이언트 상태를 저장하지 않기 때문에, 요청을 어떤 서버가 처리해도 무관함 (수평 확장 쉬움) |
| 단순함 | 상태를 저장하지 않으므로 서버 구현이 단순함 |
| 성능 ↑ | 상태 저장/조회 오버헤드가 없음 |

| 단점 | 설명 |
| --- | --- |
| 상태 유지를 위해 매번 정보 전달 필요 | 클라이언트가 상태 정보를 계속 보내야 함 (ex. 세션ID, 인증 토큰) |
| 사용자 맞춤형 서비스 구현 복잡 | 사용자의 상태를 기억하지 않으니 로그인/장바구니 등의 구현은 별도 메커니즘 필요 |

### HTTP가 Stateless 구조를 채택한 이유

- **간단하고 범용적인 통신**을 위해 설계되었기 때문
- 특히 초기 웹은 문서 기반 전송이 목적이었고, 상태 정보가 필요하지 않았음 → **확장성과 단순함**이 우선

> 이후 사용자 맞춤 서비스가 많아지면서 쿠키, 세션, 토큰 등의 기술이 
상태 유지를 위한 별도 메커니즘으로 도입됨
> 

## HTTPS에서 공개키와 대칭키의 차이

### 공개키 암호 방식 (비대칭키, Asymmetric Key)

| 항목 | 설명 |
| --- | --- |
| **키의 종류** | 공개키(Public Key) & 개인키(Private Key) |
| **특징** | 암호화와 복호화를 **다른 키**로 수행 |
| **사용 예** | 공개키로 암호화 → 개인키로 복호화 |
| **장점** | 키를 안전하게 공유할 수 있음 |
| **단점** | 암호화/복호화 속도가 느림 |

→ **서버 인증(SSL 인증서)**, 대칭키 교환에 사용됨

### 대칭키 암호 방식 (Symmetric Key)

| 항목 | 설명 |
| --- | --- |
| **키의 종류** | 하나의 **공통 키(shared key)** 사용 |
| **특징** | 암호화와 복호화를 **같은 키**로 수행 |
| **사용 예** | 클라이언트와 서버가 같은 키를 사용 |
| **장점** | 속도가 빠르고 효율적 |
| **단점** | **키 전달이 어렵고 보안에 취약**함 (가로채기 가능성) |

→ **HTTPS의 실제 데이터 전송 구간에서 사용**

### HTTPS에서의 실제 활용 흐름

1. 클라이언트가 서버에 접속 → **공개키 포함된 인증서 수신**
2. 클라이언트는 이 공개키로 **대칭키(세션키)를 암호화해서 전송**
3. 서버는 **개인키로 복호화**하여 대칭키 획득
4. 이후 데이터는 **대칭키 기반**으로 암호화하여 빠르게 주고받음

> 즉, 공개키는 대칭키를 안전하게 전달하는 데 사용
> 
> 
> **실제 데이터 전송은 빠른 대칭키 방식 사용**
> 

---

## HTTPS Handshake에서 인증서를 사용하는 이유

### 인증서란?

- 서버가 **신뢰할 수 있는 기관(CA)**으로부터 발급받은 **디지털 문서**
- **서버의 공개키 + 서버 정보 + 서명(CA의 개인키로)** 포함
- 브라우저(클라이언트)는 이걸 보고 **서버가 진짜인지 판단**

### 인증서를 사용하는 이유

| 목적 | 설명 |
| --- | --- |
| **서버의 신원 확인** | 인증서를 통해 서버가 **신뢰할 수 있는 기관에 의해 검증된 서버**인지 확인 |
| **Man-in-the-Middle 공격 방지** | 공격자가 중간에서 가짜 서버로 위장해 통신하는 것을 막음 |
| **안전한 공개키 제공** | 공개키를 **위조/변조 없이 안전하게 전달** 가능 |
| **대칭키 암호화를 위한 기반 제공** | 클라이언트가 안전하게 세션키(대칭키)를 서버에 전달할 수 있도록 보장함 |

### 클라이언트는 인증서를 어떻게 검증하나요?

1. 서버로부터 인증서 수신
2. **루트 인증기관(CA)의 공개키**로 서명을 확인
3. 인증서에 포함된 정보(도메인, 만료일 등)와 현재 연결 정보 비교
4. 검증 성공 시 → Handshake 계속 진행

> 인증서가 위조되었거나 만료되었으면 연결 거부됨 (브라우저 경고 표시)
> 

### 요약

- 인증서는 **서버가 진짜인지**를 보장
- **공개키를 안전하게 공유**하고, 그 기반 위에 **대칭키로 데이터 암호화**
- 신뢰 기반 HTTPS 통신에서 **핵심 역할**

---

## ✅ 3. HTTP 응답 코드란?

클라이언트가 서버에 요청(Request)을 보낸 뒤, 서버가 **요청 처리 결과를 숫자로 응답**하는 방식

총 **5가지 범주로 나뉘며**, 상태를 직관적으로 나타냄

### HTTP 응답 코드 분류

| 범위 | 분류명 | 의미 |
| --- | --- | --- |
| 1xx | **정보 (Informational)** | 요청 수신, 처리 중 |
| 2xx | **성공 (Success)** | 요청 정상 처리 완료 |
| 3xx | **리다이렉션 (Redirection)** | 다른 위치로 이동해야 함 |
| 4xx | **클라이언트 오류 (Client Error)** | 요청이 잘못됨 (ex. URL 잘못 입력) |
| 5xx | **서버 오류 (Server Error)** | 서버 내부 오류로 요청 실패 |

### 자주 쓰는 응답 코드

- 이거 진짜 플젝할 때 많이 봤었는데.. 이렇게 다시 정리해서 보니까 새롭네..

### 2xx

| 번호 | 의미 | 설명 |
| --- | --- | --- |
| 200 | OK  | 요청 성공 (GET, POST 등 모든 요청의 일반적인 성공 응답) |
| 201 | Created | POST 요청을 통해 자원이 생성되었을 때 사용 |
| 204 | No Content | 요청은 성공했으나, 응답 본문이 없을 때 사용 (ex. 삭제 완료) |

### 3xx

| 번호 | 의미 | 설명 |
| --- | --- | --- |
| 301 | Moved Permanently | 리소스가 영구적으로 다른 URL로 이동 (브라우저가 자동 리다이렉션) |
| 302 | Found | 리소스가 임시로 다른 위치에 존재함 |
| 304 | Not Modified | 캐시된 리소스를 그대로 사용해도 될 때 사용 |

### 4xx

| 번호 | 의미 | 설명 |
| --- | --- | --- |
| 400 | Bad Request | 잘못된 문법의 요청 (예: 파라미터 오류) |
| 401 | Unauthorized | 인증 필요 (로그인이 필요하거나 토큰이 유효하지 않음) |
| 403 | Forbidden | 권한 없음 (접근 자체가 차단됨) |
| 404 | Not Found | 해당 리소스를 찾을 수 없음 (잘못된 URL 등) |

### 5xx

| 번호 | 의미 | 설명 |
| --- | --- | --- |
| 500 | Internal Server Error | 서버 내부에서 알 수 없는 에러 발생 |
| 503 | Service Unavailable | 서버 과부하 혹은 유지보수 중 |

## GET과 POST의 차이점

| 구분 | **GET** | **POST** |
| --- | --- | --- |
| **목적** | 데이터 요청 | 데이터 생성/변경 |
| **멱등성** | **멱등성 보장**→ 여러 번 요청해도 결과 같음 | 비멱등 (여러 번 요청 시 데이터 중복 생성 가능) |
| **요청 구조** | URL의 **쿼리 스트링**에 데이터를 포함 
(`?key=value`) | HTTP 본문(body)에 데이터를 포함 |
| **기존 자원에 영향** | 가져오는거니까 상관 없음 | 자원 추가 생성 |
| **보안성** | 낮음 (URL에 정보 노출) | 상대적으로 높음 (본문에 숨겨짐) |
| **캐싱** | 가능 (브라우저가 요청을 저장하고 재사용) | 일반적으로 불가능 |

## PUT과 PATCH의 차이점

| 구분 | **PUT** | **PATCH** |
| --- | --- | --- |
| **목적** | 자원 **전체 수정 (대체)** | 자원 **부분 수정** |
| **멱등성** | 멱등 | 보통 멱등이지만, 구현 방식에 따라 다름 |
| **요청 구조** | Body에 **전체 자원** 정보 포함 | Body에 **변경할 필드만** 포함 |
| **기존 자원에 영향** | 기존 자원을 **덮어씀** | 기존 자원의 **일부만 수정** |

### 멱등성(Idempotent)이란?

- 요청을 **한 번 보내나, 여러 번 보내나** 결과가 **같은 상태**로 유지되는 특성
    - GET은 여러번 요청해도 결과가 같아서 멱등성 보장
    - PUT은 항상 같은 데이터를 덮어쓰기 때문에 멱등
    - POST는 호출할 때마다 **자원이 계속 생성**되므로 비멱등
    - PATCH는 대부분 멱등이나, 구현 방식에 따라 다름

---

## ✅ 4. SSL vs TLS

| 구분 | **SSL (Secure Sockets Layer)** | **TLS (Transport Layer Security)** |
| --- | --- | --- |
| **개발 시기** | 1990년대 중반 (Netscape 개발) | 1999년부터 SSL의 후속으로 개발 |
| **버전** | SSL 2.0, 3.0 (현재는 모두 폐기됨) | TLS 1.0 → 1.1 → 1.2 → **1.3** (최신) |
| **보안 수준** | 상대적으로 낮음 | 더 강력한 암호화 및 보안 |
| **핸드셰이크** | 취약한 알고리즘 사용 가능 | 불필요한 암호화 알고리즘 제거, 성능 개선 |
| **호환성** | 구식 시스템과 호환 | 현대 브라우저 및 시스템에서 표준 |
| **사용 여부** | 사용 중단됨 (2020년부터 대부분 비활성화) | HTTPS의 실질적인 표준 보안 프로토콜 |

---

## ✅ 5. DNS(Domain Name System)란?

사용자가 입력하는 도메인 이름(예: `www.google.com`)

컴퓨터가 이해할 수 있는 IP 주소(예: 142.250.196.68)로 변환해주는 **인터넷의 전화번호부 역할**을 하는 시스템

**응용 계층 프로토콜임** (HTTP, FTP처럼 사용자의 요청을 처리하는 최상위 계층)

### 예시 흐름

> 사용자가 www.github.com을 입력하면
> 
> 
> → DNS 서버에 요청
> 
> → 해당 도메인의 IP 주소를 찾아서 반환
> 
> → 브라우저는 그 IP로 요청을 전송
> 

### TCP vs UDP 중 무엇을 사용하는가?

| 상황 | 사용 프로토콜 | 설명 |
| --- | --- | --- |
| 일반적인 DNS 쿼리 | **UDP 53번 포트** | 빠르게 응답 받기 위해 비연결성 프로토콜 사용 |
| 응답이 512바이트 초과 or 재전송 필요 | **TCP 53번 포트** | 큰 응답 데이터를 위해 연결 기반 전송 사용 |

---

## ✅ 6. 쿠키(Cookie)와 세션(Session)

쿠기와 세션의 차이

| 항목 | 쿠키(Cookie) | 세션(Session) |
| --- | --- | --- |
| 저장 위치 | **클라이언트(브라우저)** | **서버** |
| 저장 형태 | 텍스트 파일로 브라우저에 저장 | 서버 메모리에 저장 (혹은 DB 등) |
| 보안성 | 낮음 (사용자에게 노출 가능) | 높음 (서버 내부 관리) |
| 만료 시점 | 설정한 시간 이후 만료 | 브라우저 종료 시 만료 (기본) |
| 용량 제한 | 약 4KB | 서버 메모리 한도까지 |
| 사용 예시 | 자동 로그인, 장바구니 정보 | 로그인 정보, 사용자 인증 관리 |
| 식별 방식 | 브라우저에 저장된 쿠키값으로 | 클라이언트에 발급한 **세션 ID**를 쿠키에 저장해 추적 |

### 쿠키 요약

- 클라이언트에 저장되는 작은 데이터 조각
- 사용자가 사이트에 재방문할 때 상태 유지에 활용
- 보안 민감 정보 저장은 **비추천**

### 세션 요약

- 서버에서 관리되는 상태 정보
- 사용자 인증(로그인 등)에 자주 사용
- 브라우저가 쿠키에 담긴 세션 ID를 함께 보내야 세션을 식별할 수 있음

> 쿠키는 클라이언트 중심, 세션은 서버 중심
> 

## 세션 기반 로그인 과정

1. 클라이언트 로그인 요청

- 사용자가 아이디, 비밀번호를 입력해서 서버에 Post/login 요청을 보냄

```
Request
POST /login
Content-Type: application/json

{
  "username": "greentea",
  "password": "1234"
}
```

2. 서버에서 인증 처리

- 서버는 DB에 저장된 사용자 정보와 비교해서 인증 성공 여부를 판단함
- 인증이 성공하면, 서버는 **고유한 세션 ID**를 생성하고 세션 저장소에 사용자 정보를 저장함

```java
// Java 예시
HttpSession session = request.getSession();
session.setAttribute("userId", user.getId());
```

3. 세션 ID를 클라이언트에 쿠키로 전달

- 서버는 응답 헤더에 세션 ID를 담은 **Set-Cookie**를 함께 전송

```
Response Header
Set-Cookie: JSESSIONID=ABC123DEF456; Path=/; HttpOnly
```

4. 이후 요청 시, 세션 ID 자동 포함

- 브라우저는 저장된 `JSESSIONID`를 자동으로 요청 헤더에 포함시킴

```
Request Header
Cookie: JSESSIONID=ABC123DEF456
```

5. 서버에서 세션 ID 기반 사용자 식별

- 서버는 쿠키에 담긴 `JSESSIONID`를 기반으로 세션 저장소에서 사용자 정보를 조회
- 조회 한 다음에 사용자 요청을 적절히 처리함

---

## 서버가 여러 대일 때 세션 관리 방법

1.  **Sticky Session (Session Affinity)**
- **한 사용자의 요청을 항상 같은 서버에 전달**하도록 로드 밸런서가 고정
- 예: 클라이언트 A는 항상 서버 1로, 클라이언트 B는 항상 서버 2로

| 장점 | 단점 |
| --- | --- |
| 구현이 간단 | 특정 서버에 트래픽 집중 가능 |
| 기존 세션 방식 그대로 사용 가능 | 서버 장애 시 세션 유실 가능성 있음 |

**2. Session Replication**

- **서버 간에 세션 정보를 복제**하여 모든 서버가 동일한 세션 데이터를 갖도록 함
- 예: 서버 1에서 로그인하면, 그 세션 정보가 서버 2에도 복제됨

| 장점 | 단점 |
| --- | --- |
| 장애 시 다른 서버로도 세션 유지 가능 | 서버 간 동기화 비용 발생 (성능 부담) |

3. **Session Store 분리 (외부 저장소 사용)**

- 세션 정보를 **Redis, Memcached, DB 등 외부 저장소**에 저장
- 모든 서버가 같은 세션 저장소를 참조함

| 장점 | 단점 |
| --- | --- |
| 세션 일관성 유지, 확장성 좋음 | 별도의 인프라 필요 |
| 서버 간 동기화 불필요 | 외부 저장소 장애에 대한 대비 필요 |

> 대부분의 실무에서는 Redis를 세션 저장소로 가장 많이 사용한다고 함
> 

### 요약

| 방식 | 설명 | 장점 | 단점 |
| --- | --- | --- | --- |
| Sticky Session | 같은 사용자 → 같은 서버 | 구현 쉬움 | 서버 장애 시 세션 유실 |
| Session Replication | 서버 간 세션 복제 | 고가용성 | 동기화 부하 |
| External Session Store | Redis 등 외부 저장소 사용 | 일관성, 확장성 좋음 | 외부 구성 필요 |

## Stateless vs Connectionless

| 구분 | Stateless | Connectionless |
| --- | --- | --- |
| **정의** | **서버가 클라이언트 상태를 저장하지 않는 방식** | **연결 없이 데이터만 전송하는 통신 방식** |
| **기준** | 서버 또는 시스템의 **설계 철학** | **네트워크 통신 방식** (OSI 4계층 이하) |
| **예시** | HTTP (서버는 클라이언트의 상태를 저장하지 않음) | UDP (데이터를 보내기 전에 연결 설정 없음) |
| **특징** | 클라이언트의 이전 요청 정보를 기억하지 않음 | 송신자는 수신자와의 연결 여부를 모름 |
| **장점** | 확장성, 단순성 | 빠른 전송, 지연 시간 최소화 |
| **단점** | 상태 유지를 위한 별도 구현 필요 (쿠키, 세션 등) | 신뢰성 보장 어려움 (순서, 손실, 중복 감지 없음) |

---

## 간단 요약

- **Stateless**는 서버가 **클라이언트 상태를 기억하지 않는 설계 구조**
    
    → HTTP는 기본적으로 Stateless → 그래서 **쿠키나 세션**으로 상태 유지 보완
    
- **Connectionless**는 **데이터를 보낼 때 연결을 맺지 않고** 바로 전송
    
    → UDP가 대표적인 예 → 빠르지만 **신뢰성 없음**
    

> 비슷해 보이지만, Stateless는 설계의 관점, Connectionless는 통신 방식의 관점이야!
> 

---

### HTTP가 Stateless를 채택한 이유

| 이유 | 설명 |
| --- | --- |
| **단순성과 확장성** | 상태 정보를 저장하지 않기 때문에 서버는 **구현이 단순**하고 
**여러 클라이언트의 요청을 독립적으로 처리**할 수 있어 **확장성에 유리**함 |
| **리소스 효율성** | 클라이언트 상태를 서버에 저장하지 않으므로 **메모리 및 저장소를 절약**할 수 있음 |
| **인터넷 환경에 최적화** | 웹은 수많은 클라이언트가 요청을 보내는 환경 
→ Stateless는 **트래픽 분산 및 서버 간 요청 처리에 유리** |
| **클라이언트 주도 처리 가능** | 클라이언트가 상태 정보를 갖고 서버에 다시 보내는 방식 (ex. 쿠키, 토큰 등) 
→ 유연한 아키텍처 구성 가능 |

### 📦 단점과 보완 방법

| 단점 | 보완 방법 |
| --- | --- |
| 상태 정보가 없으므로 **매 요청마다 인증 필요** | → **쿠키, 세션, 토큰** 등을 통해 상태 관리 |
| 로그인 유지나 장바구니 등 기능 구현 어려움 | → **세션 ID** 또는 **JWT** 등을 사용해 사용자 상태 유지 |

> HTTP가 Stateless를 채택한 이유는 웹의 특성과 서버 확장성을 고려한 효율적인 설계 선택이기 때문이야.
> 
> 
> 하지만 상태 관리가 필요할 경우, **애플리케이션 단에서 별도로 상태 관리 로직을 구현**해주는 것이 일반적이야!
> 

---

## ✅ 7.  [www.github.com](http://www.github.com/) 입력 후 네트워크 상에서 일어나는 일

1. **브라우저 주소창에 `www.github.com` 입력**

- 사용자가 브라우저에 도메인을 입력하고 엔터를 누름
- 이때 브라우저는 **입력값을 파싱**해서 URL인지, 검색어인지 구분

2. **DNS 조회 (Domain Name System)**

- 브라우저는 `www.github.com`의 **IP 주소를 알아내기 위해** DNS 질의를 수행
- 이 과정에는 **캐시 → 로컬 DNS → 루트/권한 서버** 단계가 있음
- 순서:
    1. **브라우저 캐시**에 IP가 있는지 확인
    2. **운영체제(OS) 캐시** 확인
    3. **로컬 DNS 서버**(보통 ISP 제공)로 질의
    4. 없으면:
        - **루트 DNS 서버** → `.com`에 대한 정보 받음
        - **.com TLD 서버** → `github.com` 정보 받음
        - **권한 있는 DNS 서버** → 최종 IP 주소 응답

> 결과적으로 github.com에 해당하는 공인 IP 주소 반환
> 

3. **TCP 연결 수립 (3-Way Handshake)**

- IP 주소를 알아낸 브라우저는 해당 서버(`github.com`)의 **443번 포트**에 접속을 시도
- 이때 **TCP 연결**을 위해 다음의 3-Way Handshake 수행:

```
Client → Server : SYN
Server → Client : SYN-ACK
Client → Server : ACK

-> 이제 양측은 전송로(세션)를 열고 통신할 준비 완료
```

4. **TLS 핸드셰이크 (HTTPS일 경우)**

- github는 `https://` 이므로 보안 연결이 필요
- TLS 핸드셰이크를 통해 다음을 수행:

| 과정 | 내용 |
| --- | --- |
| 서버 인증 | 클라이언트는 서버의 **SSL 인증서**를 확인 |
| 키 교환 | 공개키 기반으로 **대칭키를 생성** (Pre-master secret 공유) |
| 세션 설정 | 암호화 방식 협상, 암호화 키 설정 |

> 이후 모든 통신은 TLS로 암호화됨
> 

1. **HTTP 요청 전송**
- 보안 세션이 열리면, 브라우저는 아래와 같은 HTTP 요청을 전송:

```
GET / HTTP/1.1
Host: www.github.com
User-Agent: Mozilla/5.0 ...
Accept: text/html,application/xhtml+xml ...
```

**6. 서버에서 HTTP 응답 수신**

- github 서버는 요청을 처리하고, 응답을 보냄:

```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: ...
```

> HTML, CSS, JS, 이미지 등 웹페이지 구성요소가 함께 응답됨
> 

7.  **브라우저 렌더링 엔진이 HTML 파싱**

- 브라우저는 응답받은 HTML을 파싱하면서 다음 수행:
    - **DOM 트리** 생성
    - **CSSOM 트리** 생성
    - **렌더 트리** 생성 후 레이아웃 계산
    - **페인팅 및 디스플레이**
    

8. **추가 리소스 요청 (병렬 요청)**

- HTML 안의 `<img>`, `<script>`, `<link>` 등 외부 리소스를 파싱하면서 **동시에 병렬 요청** 수행
- HTTP2 이상에서는 **멀티플렉싱**이 활용되어 더 빠름

1. **최종적으로 페이지 화면 출력**
- 사용자 눈에는 `www.github.com`의 홈 화면이 보이게 됨
    
    ---
    

### 요약 순서 흐름

1. 브라우저에 URL 입력
2. **DNS 조회** → IP 주소 획득
3. **TCP 연결** (3-Way Handshake)
4. **TLS 연결** (HTTPS Handshake)
5. **HTTP 요청 전송**
6. **HTTP 응답 수신**
7. **HTML 파싱 및 렌더링**
8. **리소스 추가 요청**
9. **브라우저에 웹페이지 표시**

---

여기는 궁금해서 GPT 한테 물어봤어요!

## Stateless 구조에서 세션 방식 인증은 적절하지 않은 방식 아닌가요?

### 이 질문의 핵심

- HTTP는 **Stateless인데** 세션 방식은 서버에 상태(Session 정보)를 저장한다는 점에서 **Stateful**한 방식임

 → "이거 HTTP 철학에 어긋나는 거 아냐?"라는 의문이 생길 수 있음

### 결론은

> 세션 방식 인증은 Stateless 구조에 본질적으로는 어긋나지만, **실제 웹 서비스 구현에서는 현실적인 선택**이기 때문에 널리 사용돼
> 

### 왜 어긋나는가?

| 이유 | 설명 |
| --- | --- |
| HTTP는 Stateless | 요청 간 **서버가 클라이언트 상태를 기억하지 않음** |
| 세션은 Stateful | 서버가 세션 ID를 기준으로 **클라이언트의 상태를 저장**함 |

즉, HTTP의 철학과 세션 방식은 **구조적으로는 맞지 않음**

### 그런데도 왜 세션을 쓰는가?

- 현실의 웹 서비스에서는 사용자의 **인증 상태 유지**가 매우 중요
- 사용자가 로그인할 때마다 인증 정보를 다시 보내는 건 **불편하고 비효율적**
- 그래서 상태 정보를 **세션으로 서버에 저장**하고, 클라이언트는 세션 ID만 전달하는 구조를 사용함

### 보완 대안: 토큰 기반 인증 (ex. JWT)

| 항목 | 세션 인증 | JWT 인증 |
| --- | --- | --- |
| 서버 저장소 필요 | 필요 (세션 상태 저장) | 불필요 (Stateless 유지 가능) |
| 확장성 | 낮음 (세션 동기화 필요) | 높음 (토큰만 있으면 인증 가능) |
| 보안 | 상대적으로 안전 (서버 관리) | 노출되면 위험 (클라이언트 보관) |
| 사용 방식 | 세션 ID를 쿠키에 저장 | 토큰을 헤더에 저장 (Authorization) |

### 요약하자면

- 세션 인증은 HTTP의 **Stateless 철학과 어긋나지만**, **웹 서비스 요구에 맞춰 사용되는 현실적인 방식**
- **확장성과 분산 처리 측면에서 한계**가 있어, 요즘은 **JWT 기반 인증**이 더 선호되기도 함

---
