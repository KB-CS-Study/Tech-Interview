블로그 정리 글 👇🏻
- [IP](https://0woy.tistory.com/entry/IP)
- [HTTP 변천사](https://0woy.tistory.com/entry/HTTP-%EB%B3%80%EC%B2%9C%EC%82%AC)
- [DNS](https://0woy.tistory.com/entry/DNS)

## IP 주소

\`IP 주소 (Internet Protocol Address)\`는 **인터넷에 연결된 기기를 식별**하기 위한 고유 주소

집 마다 있는 우편번호 처럼, 네트워크 상에서 데이터를 주고 받기 위해 필요한 위치 정보

> **❓ IP 주소는 왜 필요하지 ?  
>   
> **기기마다 고유한 주소가 있어야 데이터가 **정확한 목적지**로 도달 가능  
> ex) 웹 브라우저로 \`naver.com\`에 접속하면, 그 요청의 내 IP 주소를 포함한 형태로 전송

---

### 1) IPv4 헤더 구조

IPv4 헤더는 기본적으로 **20바이트** 길이이며, 아래와 같은 필드로 구성되어 있음

```
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |Version|  IHL  |Type of Service|        Total Length           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |        Identification         |Flags|    Fragment Offset      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Time to Live |    Protocol   |       Header Checksum         |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                     Source IP Address                         |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                  Destination IP Address                       |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

| 바이트 | **필드명** | 크기 (비트) |  설명 |
| --- | --- | --- | --- |
| 1 | **Version** | 4 | IP 버전 (IPv4면 4) |
| **IHL (Header Length)** | 4 | 헤더 길이 (32비트 단위) |
| 2 | **Type of Service (ToS)** | 8 | 패킷 우선순위 및 서비스 품질 |
| 3-4 | **Total Length** | 16 | 전체 패킷 길이 (헤더 + 데이터) |
| 5-6 | **Identification** | 16 | 조각화된 패킷의 식별 번호 |
| 7 | **Flags** | 3 | 조각화 제어 (DF, MF 등) |
| **Fragment Offset** | 13 | 조각의 순서 |
| 8 | **Time to Live (TTL)** | 8 | 패킷 생존 시간 (라우터 거칠 때마다 감소) |
| 9 | **Protocol** | 8 | 상위 계층 프로토콜 (예: TCP=6, UDP=17) |
| 10-11 | **Header Checksum** | 16 | 헤더 오류 검출용 체크섬 |
| 12-15 | **Source IP Address** | 32 | 송신자 IP |
| 16-19 | **Destination IP Address** | 32 | 수신자 IP |
| 20+ | **Options + Padding** (선택) | 가변 | 확장 옵션 (필요 시만) |

---

### 2) TTL (Timt To Live) 필드

IP 패킷이 네트워크에서 살아남을 수 있는 **생존 시간** 정의 (8비트)

패킷이 네트워크에서 순환하다 무한 루프에 빠지는 것을 방지하는 필드

> 초기 TTL 값은 OS 별로 상이함 (Linux: 64, Windows: 128)

#### 동작 방식

-   라우터를 지날 때마다 1씩 감소
-   0이 되면 패킷 폐기 _∵ 무한 루프 방지_
-   폐기 시 ICMP 메시지 (Time Exceeded)발송

---

### 3) IPv4 Checksum VS TCP Checksum

둘 다 오류 검출을 위한 용도이지만, **계산 대상 범위 & 위치**가 다름

**IPv4 체크섬**은 **IP 헤더**만 검사, 패킷이 전송되는 동안 **IP 헤더의 무결성**을 확인하는 데 사용

![1](https://github.com/user-attachments/assets/b1cfb1ca-3e5f-4c89-8b22-0a436303cca3)


| **항목** | **IPv4 Checksum** | **TCP Checksum** |
| --- | --- | --- |
| **위치** | IP 헤더 내 | TCP 세그먼트 내 |
| **대상** | **IP 헤더만** | **TCP 헤더 + 데이터 + 의사헤더** |
| **목적** | IP 헤더 오류 검출 | TCP 데이터 전송 오류 검출 |
| **변화 여부** | TTL 등 필드 변화 시 계속 **재계산** | 전송 시 한 번 계산 (라우터는 변경 안 함) |
| **사용 여부** | IPv4에 존재, **IPv6에서는 제거됨** | TCP에 계속 존재 (IPv6에서도) |

---

#### TCP 체크섬과의 차이 ?

-   TCP 체크섬은 \`헤더 + 데이터 + IP 주소 정보\`까지 포함한 **의사 헤더** 사용
-   이는 **패킷 전송 중 발생할 수 있는 더 다양한 오류를 검출**하려는 목적

**TCP 체크섬은 데이터 오류뿐만 아니라, 전송된 IP 주소의 오류도 확인  
****👉** 더 신뢰성 있는 오류 검출이 가능

> ****❓ 의사 헤더 (pseudo-header)**** 
> 
> **TCP/UDP 체크섬 계산을 위한 가상의 헤더**로, 실제 전송되는 패킷에 포함되지 않지만 체크섬 계산 시 사용  
>   
> **IP 패킷의 IP 주소, 프로토콜 정보**가 전송 중의 오류를 감지하는 데 필요한 중요한 부분임  
> ∴ 체크섬 계산 시 이를 함께 고려하는 것

---

#### TTL 변경 시 체크섬 재계산 문제

TTL이 감소할 때마다, **IPv4 헤더의 체크섬을 다시 계산**해야 하는데, 이는 **추가적인 계산 비용**을 초래.

라우터에서 패킷을 수정할 때마다 체크섬을 매번 다시 계산해야 하기 때문에, 네트워크 성능에 부정적인 영향

**IPv6에서는 TTL & Checksum을 제거**하고 **Hop Limit**을 도입 = 더 이상 체크섬을 재계산할 필요X

---

## MAC 주소 (Media Access Control 주소)

**물리적 장비**에 할당하는, 네트워크에서 각 장치를 고유하게 식별하는 주소

네트워크 카드나 라우터 등 네트워크 장비에 내장된 하드웨어에 설정

![2](https://github.com/user-attachments/assets/365a42ea-9c3a-421a-8afa-95944afdd605)


물리적 네트워크 장치에 대한 주소이므로 전 세계 어디서나 고유함

| **항목**  | **MAC 주소** |  **IP 주소** |
| --- | --- | --- |
| **용도** | 장비 식별 | 위치 식별 |
| **유형** | 물리적 주소 | 논리적 주소 |
| **고정 여부** | 고정 (보통) | 변경 가능 (DHCP) |
| **형식** | 48비트 16진수 | IPv4 (32비트), IPv6 (128비트) |
| **OSI 계층** | 2계층 (데이터 링크) | 3계층 (네트워크) |

---

### 홉바이홉 통신

IP 주소를 통해 통신화는 과정을 \`홉바이홉 통신\`이라고 함

> **❓ 홉(hop)  
> **건너뛰다 라는 의미, 통신망에서 각 **패킷이** 여러 개의 **라우터를 건너가는 모습**을 비유적으로 표현

수많은 서브네트워크 안에 있는 라우터의 **라우팅 테이블 IP를 기반**으로 패킷을 전달해나가며 라우팅을 수행  
_👉 최종 목적지까지 패킷 전달_

![3](https://github.com/user-attachments/assets/b94d8c98-99d3-4b08-a4aa-1a79b37d654a)


통신 장치에 있는 \`라우팅 테이블\`의 IP를 통해 시작 주소부터 시작하여,  
다음 IP로 계속 이동하는 \`라우팅\` 과정을 거쳐 패킷이 최종 목적지까지 도달하는 통신 방식을 말함.

---

#### 라우팅 테이블 (Routing Table)

-   송신지에서 수신지까지 도달하기 위해 사용
-   라우터에 들어가 있는 목적지 정보들과 그 목적지로 가기 위한 방법이 들어있는 리스트
-   게이트웨이와 모든 목적지에 대해 해당 목적지에 도달하기 위해 거쳐야할 다음 라우터 정보 포함

---

#### 게이트웨이 (Gateway)

서로 다른 통신망, 프로토콜을 사용하는 **네트워크 간의 통신을 가능**하게 하는 **관문** 역할을 하는  
컴퓨터나 소프트웨어를 두루 일컫는 용어

-   사용자는 인터넷에 접속하기 위해 수많은 게이트웨이를 거쳐야 함.
-   게이트웨이는 서로 다른 네트워크상의 통신 프로토콜을 변환해주는 역할을 함

게이트웨이를 확인하는 방법은 \`**라우팅 테이블**\`을 통해 볼 수 있음

> **❓ 라우팅 테이블은 어떻게 확인하는데?  
> **윈도우에서는 명령 프롬프트에서 \`netstat -r\` 명령어 실행하여 확인

![4](https://github.com/user-attachments/assets/2bb97ef3-f317-4816-bb3d-45b8f25318db)


IPv4 경로 테이블, IPv6 경로 테이블 존재 (= 라우팅 테이블)

---

## ARP (Address Resolution Protocol)

컴퓨터 간의 통신은 흔히 IP 주소를 기반으로 통신한다고 말함.

정확히는 IP 주소에서 ARP를 통해 MAC 주소를 찾아 **MAC 주소를 기반으로 통신**한다.

∴ ARP란 IP 주소로부터 MAC 주소를 구하는, 다리 역할을 하는 프로토콜임

-   IP(가상) → MAC(실제\`): ARP 사용
-   MAC → IP : RAPR 사용

### ARP가 주소를 찾는 과정

![5](https://github.com/user-attachments/assets/eb959b6d-c03f-4f7b-9ae6-8d50cab7a352)


-   장치 A가 ARP Request 브로드캐스트를 보내서 IP 주소인 \`127.70.80.3\`에 해당하는 MAC 주소 찾음
-   해당 주소에 맞는 장치 B가 ARP Reply **유니캐스트**를 통해 MAC 주소 반환

> 📌 **브로드캐스트 & 유니캐스트**\`**브로드캐스트**\`: 송신 호스트가 전송한 데이터가 네트워크에 **연결된 모든 호스트에 전송**되는 방식  
> \`**유니캐스트**\`: 고유 주소로 식별된 **하나의 네트워크** 목적지에 **1:1**로 데이터를 전송하는 방식

---

## IP 주소 체계

IP 주소는 IPv6와 IPv4로 나뉜다.

-   **IPv4**: 32비트를 8비트 단위로 점을 찍어 표기, \`123.45.67.89\` 형식
-   **IPv6**: 64비트를 16비트 단위로 점을 찍어 표기, \`2001:db8::ff00:42:8654\` 형식

추세는 IPv6로 가고 있지만 현재 가장 많이 쓰이는 주소 체계는 IPv4 형식임.

> 📌 **IPv6 64비트? 128비트?  
>   
> ** IPv6 주소는 전체적으로 128비트로 앞의 64비트를 네트워크 식별에, 뒤의 64비트를 인터페이스 식별자에 사용함  
> 그래서 인터페이스 ID가 64비트라는 점 때문에 ‘IPv6가 64비트 주소체계’라는 표현이 나오지만,  
> __**전체 주소 길이는 128비트  
>   
> **__\- 네트워크 프리픽스: 네트워크 구간 식별 (라우팅에 사용)\- 인터페이스 식별자: 네트워크 내의 장치 식별 (호스트 주소)

---

### IPv6 헤더 구조 (고정 40 바이트)

```
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version| Traffic Class |           Flow Label                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Payload Length    |  Next Header  |     Hop Limit         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Source Address (128 bits)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|              Destination Address (128 bits)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**👉 TTL = Hop Limit**

---

### 클래스 기반 할당 방식

IP 주소 체계는 발전해오고 있으며 **처음**에는 A, B, C, D, E 다섯 개의 클래스로 구분하는 **클래스 기반 할당방식** 사용

앞단을 **네트워크** 주소, 뒷단을 컴퓨터에 부여하는 주소인 **호스트 주소**로 놓아서 사용

![6](https://github.com/user-attachments/assets/afa6d28e-501d-4cca-85bc-a95fc929d1d6)


-   **클래스 A, B, C**: 일대일 통신으로 사용
-   **클래스 D**: 멀티캐스트 통신
-   **클래스 E**: 앞으로 사용할 예비용

![7](https://github.com/user-attachments/assets/d8b66778-d431-49e3-8b7a-1143abd9e664)


맨 왼쪽에 있는 비트를 \`**구분 비트**\`라고 함 

-   클래스 A의 구분 비트: 0
-   클래스 B의 구분 비트: 10
-   클래스 C의 구분 비트: 110

_👉 구분 비트를 통해 클래스 간의 IP가 나뉘어짐_

네트워크의 첫 번째 주소는 **네트워크** 주소로 사용,  
가장 마지막 주소는 **브로드캐스트용** 주소로 네트워크에 속해있는 모든 데이터를 보낼때 사용

> **예시) 클래스 A로 12.0.0.0이란 네트워크 부여**  
> 호스트 주소: 12.0.0.1 ~ 12.255.255.254 = **사용 가능**  
> 12.0.0.0 (네트워크 주소), 12.255.255.255 (브로드캐스트 주소) = **사용 불가능**

클래스 기반 할당 방식은 사용하는 주소보다 버리는 주소가 많은 단점이 있음

**이를 해소하기 위해 DHCP, IPv6와 NAT 등장**

#### **❓ 버리는 주소가 많다? 👇🏻**

클래스 기반 할당 방식은 **고정된 크기**의 주소 블록을 제공하기 때문에  
실제 필요보다 훨씬 많은 주소를 할당받게 되고, 그 중 대부분은 사용하지 못하고 '버리는 주소'가 됨

  

| **클래스**  | **주소 범위** | **호스트 수 (이론)** |
| --- | --- | --- |
| **A** | /8 (예: 10.0.0.0) | 약 1,670만 개 |
| **B** | /16 (예: 172.16.0.0) | 약 65,000 개 |
| **C** | /24 (예: 192.168.1.0) | 256개 (실사용 254개) |

**문제 시나리오**

 어떤 기업이 **1,000개 정도의 IP 주소**가 필요한 상황

### 클래스 C로는?

-   한 C 클래스(/24)는 **256개 IP 제공**
-   256개로는 부족하니 **5개 C 클래스**가 필요 → 하지만 **연속된 5개를 할당받는 건 어렵고 비효율적**

### 클래스 B를 받으면?

-   B 클래스(/16)는 **65,534개 IP 제공**
-   기업은 1,000개만 필요하므로, 나머지 **64,000개 주소는 사용하지 않고 버림**

> 이렇게 **필요보다 너무 큰 덩어리**를 받게 되어 수많은 IP가 **미사용 상태로 방치됨**  
> 이게 바로 "주소 낭비", 즉 "버리는 주소가 많다"는 말

| **문제점** | **설명** |
| --- | --- |
| **고정된 블록 크기** | 필요한 만큼 못 나눔 (예: 1,000개 필요해도 65,000개 줌) |
| **주소 낭비** | 대부분 미사용 상태로 남음 |
| **라우팅 비효율** | 라우터는 각 클래스 단위로 경로를 기억해야 해서 라우팅 테이블이 커짐 |
| **인터넷 주소 고갈 가속** | 낭비가 심해 주소 소모가 빠름 |

**👉 CIDR의 도입**

---

####  DHCP (Dynamic Host Configuration Protocol)

-   IP주소 및 기타 통신 매개변수를 자동으로 할당하기 위한 네트워크 관리 프로토콜
-   네트워크 장치의 IP 주소를 수동으로 설정X, 인터넷에 접속할 때마다 **자동으로 IP 주소 할당**
-   많은 라우터 & 게이트웨이 장비에 DHCP 기능 O → 대부분 가정용 네트워크에서 IP 주소 할당

---

#### NAT (Network Address Translation)

패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 IP 주소 정보를 수정하여, **IP 주소를 다른 주소로 매핑**하는 방법

IPv4 주소 체계만으로는 많은 주소들을 감당하지 못함  
👉 NAT로 \`**공인 IP**\` 와 \`**사설 IP**\` 로 나누어서 많은 주소를 처리

![8](https://github.com/user-attachments/assets/0284981c-1607-4739-8623-61ef17e8471c)


-   두리, 복남이, 덕구는 \`192.168.0.xxx\`를 기반으로 각각의 다른 IP 소유 = 사설 IP
-   NAT 장치를 통해 하나의 **공인 IP** (121.165.151.200)으로 외부 인터넷에 요청 가능

NAT 장치를 통해 사설 IP와 공인 IP 간 변환 가능

---

### CIDR (Class Inter-Domain Routing)

IP 주소를 더 유연하고, 효율적으로 할당하기 위해 고안된 주소 체계

> 1993년부터 기존의 클래스 기반 주소 할당을 대체함  

#### CIDR의 특징

1.  **가변 길이 서브넷 마스크(VLSM) 사용**
    -   주소 뒤에 /숫자 형태로 네트워크 크기를 표현  
        예: 192.168.10.0/24
    -   숫자는 **네트워크 비트 수**를 의미 (남은 비트는 호스트용)
2.  **IP 주소 낭비 방지**
    -   꼭 256개 단위가 아니라 **필요한 만큼만 할당 가능**  
        예: /30 → 4개 IP만 할당 (2개 usable)
3.  **라우팅 테이블 주소**
    -   여러 네트워크를 **하나로 묶어 광고 가능 (route aggregation)**  
        192.168.0.0/24, 192.168.1.0/24 → 192.168.0.0/23

> 예시) **IP 주소: 192.168.10.0/26  
>   
> **\- /26 : 네트워크 비트 26개  
> \- 서브넷 마스크: 255.255.55.192  
> \- 호스트 비트 수 : 6개  
> \- 사용 가능 IP 수 : 2^6 = 62개 (2개는 네트워크 주소 & 브로드캐스트용 주소)
>
> ---
> HTTP는 애플리케이션 계층에 존재하며, **웹 서비스 통신**에 사용

HTTP/1.0 부터 시작해 발전하여 현재는 HTTP/3이다.

## 1\. HTTP/1.0

HTTP/1.0은 기본적으로 한 연결당 하나의 요청을 처리하도록 설계  
**_👉 RTT 증가 야기_**

![1](https://github.com/user-attachments/assets/9d19381f-8175-4676-81d3-4f003fdbf647)


서버로부터 파일을 가져올 때마다 TCP의 **\`3-Way Handshake\`**를 계속 열어야 하기 때문에 RTT가 증가함

> **RTT (Round Trip Time)**: 패킷이 목적지에 도달하여 다시 출발지로 돌아오는 시간

---

### RTT 증가를 해결하기 위한 방법

연결할 때마다 RTT가 증가하니, 서버에 부담 多, 사용자 응답 시간 長

👉 이미지 스플리팅, 코드 압축, 이미지 Base64 인코딩 사용

#### 이미지 스플리팅

-   많은 이미지를 다운로드 받으면 과부하가 걸리기 때문에, 합쳐 있는 하나의 이미지를 다운로드 받음
-   이를 기반으로 **background-image**의 **position**을 이용하여 이미지 표기

```
#icons>li>a {
	backgound-img: url("icons.png")
}
#icons>li:nth-child(1)>a {
	backgound-position: 2px -8px;
}
#icons>li:nth-child(2)>a {
	backgound-position: -29px -8px;
}
```

하나의 icons.png를 기반으로 background - position 을 활용해 2개의 이미지 설정

---

#### 코드 압축

코드를 압축해서 개행 문자, 빈칸을 제거 → 코드 크기 최소화

---

#### 이미지 Base64 인코딩

-   이미지 파일을 64진법으로 이루어진 문자열로 인코딩
-   서버와의 연결을 열고 이미지에 대해 서버에 HTTP 요청을 할 필요가 없음!
-   크기가 37% 더 커지는 단점 존재

> **❓ 인코딩  
> **정보의 형태나 형식을 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해 다른 형태나 형식으로 변환하는 처리 방식

---

## 2\. HTTP/1.1

-   HTTP/1.0에서 발전함.
-   매번 TCP 연결을 하는 것이 아닌,  
    한 번 TCP 초기화를 한 이후에 \`**keep-alive**\` 옵션으로 여러 개의 파일을 송수신할 수 있도록 변경됨
-   헤더에는 쿠키 등 많은 메타데이터들 들어 있고 압축이  되지 않아 무거움

> 📌 HTTP/1.0 에서도 keep-alive가 있었으나, 표준화가 되어있지 않았음!

![2](https://github.com/user-attachments/assets/a3ed23e3-74ff-41eb-b78d-31a999efb404)


HTTP,1.1은 한 번 3-Way Handshake가 발생하면, 그 다음부터는 발생하지 않음

하지만, 문서 안에 포함된 다수의 리소스(이미지, 동영상, .css, .js)를 처리 시 _**요청할 리소스 개수 ∝ 대기 시간**_

> TCP Teardown = TCP 4-way Handshake (연결 종료)

---

### HOL Blocking (Head Of Line Blocking)

HOL Blocking은 네트워크에서 **같은 큐**에 있는 패킷이 **첫 번째 패킷에 의해 지연**될 때 발생하는 **성능 저하 현상**

-   HTTP/1.1은 기본적으로 하나의 TCP 연결에서 한 번에 하나의 요청/응답만 처리할 수 있는 구조
-   \= A 요청을 보낸 후, 서버의 응답이 오기 전까지는 다음 요청을 보낼 수 없음

👉 이로 이해 앞의 요청이 느리면 뒤의 요청이 대기해야 하는 HOL Blocking 현상 발생

---

## 3\. HTTP/2

HTTP/2는 SPDY 프로토콜에서 파생된 HTTP/1.x 보다 지연 시간을 줄이고 응답 시간을 더 빠르게 함

멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리 지원

### 멀티 플렉싱

하나의 TCP 연결을 여러 스트림으로 나누고, 동시에 요청과 응답을 주고받을 수 있게 하는 기능

-   **여러 개의 스트림**을 사용하여 송수신하는 것 
-   특정 스트림의 패킷이 손실되더라도 해당 스트림에만 영향을 미치고 나머지 스트림에는 영향X

> **❓ 스트림**  
> 데이터를 한꺼번에 모두 다 받는 것이 아니라, 조금씩 순차적으로 받으며 처리할 수 있게 되는 방식

![3](https://github.com/user-attachments/assets/fb5dd3fb-e31f-4c0f-b16b-7fbcdf002bf1)

하나의 연결 내의 여러 스트림이 담겨 있는 모습

병렬적인 스트림들을 통해 데이터를 서빙하고, **스트림 내의 데이터도 쪼개져** 있음.

애플리케이션에서 받아온 메시지를 독립된 프레임으로 조각내어 서로 **송수신한 이후 다시 조립**하며 데이터를 주고 받음

**👉 HTTP 레벨에서의 HOL Blocking  해결**

> **❓ 스트림 데이터, 스트림 헤더**  
> **스트림 데이터**: 실제 콘텐츠나 정보가 담긴 부분 (전송되는 데이터의 **본문**)  
> **스트림 헤더**: 데이터가 무엇인지, 어떻게 처리해야 하는지 설명해 주는 **메타 정보**

---

#### TCP 레벨의 HOL Blocking은 여전히 존재

TCP의 전송 방식은 순서 보장 & 신뢰성 보장, 다음 두 가지는 엄격히 지킴

-   데이터는 순서대로 도착해야 한다.
-   데이터가 손실되면 재전송한다.

HTTP/2에서 A, B, C, D 총 4개의 프레임을 보냈다고 가정,  
프레임 B가 네트워크 문제로 손실되고 나머지가 정상 도착한 경우?

1.  TCP는 C, D를 받았다고 하더라도 HTTP/2 (애플리케이션)에 넘기지 않음
2.  B가 재전송되어 도착할 때까지 C, D는 기다림  = HOL Blocking

| **계층** | **HOL Blocking 해소 여부** | **설명** |
| --- | --- | --- |
| **HTTP/2 (애플리케이션)** | ✅ 해소됨 | 멀티플렉싱으로 여러 요청 동시 처리 |
| **TCP (전송 계층)** | ❌ 여전히 존재 | 하나의 패킷 손실로 전체 지연 발생 가능 |

HTTP 레벨의 HOL Blocking은 해결됐지만, **TCP 레벨의 HOL Blocking은 여전히 존재**  
→ **HTTP/2의 구조적 한계**

---

### 헤더 압축

HTTP/1.x에는 헤더의 크기가 큰 문제가 있었음

HTTP/2는 허프만 코딩 압축 알고리즘을 사용하는 \`**HAPCK**\` 압축 형식을 가짐

#### 허프만 코딩 (Huffman Coding)

문자열을 문자 단위로 쪼개 빈도수를 셈

빈도가 높은 정보는 적은 비트수를 사용하여 표현하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 표현

**\= 전체 데이터 표현에 필요한 비트양을 줄이는 원리**

---

### 서버 푸시

HTTP/1.1 에선 클라이언트가 서버에 요청을 해야 파일을 다운로드 받을 수 있었음

HTTP/2에선 **클라이언트 요청 없이 서버**가 바로 리소스 **푸시** 가능

![4](https://github.com/user-attachments/assets/6e63738f-5226-4a88-a51b-2a0ee6f26f32)


html에는 css나 js 파일이 포함되기 마련

html을 읽으면서 그 안에 들어 있던 css 파일을 서버에 푸시하여 클라이언트에 먼저 줄 수 있음

---

## 4\. HTTP/3

-   HTTP/3은 HTTP/1.1 & HTTP/2와 함께 World Wide Web에서 정보를 교환하는 데 사용되는 세 번째 버전
-   TCP 위에서 돌아가는 HTTP/2와 달리, \`**QUICK\`이라는 계층에서 돌아가며 이는 UDP 기반**임
-   **멀티플렉싱**을 가지고 있으며, **초기 연결 설정 시 지연 시간이 감소**되는 장점

![5](https://github.com/user-attachments/assets/d44c579e-49d6-4efb-b959-5a919293596b)

---

#### 초기 연결 시 지연 시간 감소

QUICK은 UDP를 사용하므로 통신 시작시 TCP의 3-Way Handshake 과정을 거치지 않아도 됨

QUICK은 **첫 연결 설정**에 \`**1-RTT**\`만 소요됨.  
👉 클라이언트가 서버에 어떤 신호를 한 번 주고 서버도 응답하기만 하면 바로 본 통신을 시작할 수 있음

> **📌 참고**  
> QUICK은 순방향 오류 수정 메커니즘 (FEC, Foward Error Correction)이 적용됨  
> 전송한 패킷이 손실된 경우, 수신 측에서 에러를 검출하고 수정  
> \= 열악한 네트워크 환경에서도 낮은 패킷 손실률을 보임

---

## 5\. HTTPS

HTTP/2,3은 HTTPS 위에서 동작

HTTPS는 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 \`SSL/TLS\` 계층을 넣은 신뢰할 수 있는 HTTPS 요청을 말함

**👉 이를 통해 통신을 암호화 함**

HTTPS를 구축하는 방법은 아래와 같이 크게 세 가지로 나뉨

1.  직접 CA에서 구매한 인증키를 기반으로 HTTPS 서비스 구축
2.  서버 앞단에 HTTPS를 제공하는 로드밸런서 사용
3.  서버 앞단에 HTTPS를 제공하는 CDN 사용

---

### SSL/TLS

**SSL** (Secure Soket Layer)은 SSL 1.0 부터 시작하여 SSL 2.0, SSL3.0, TLS 1.0, TLS 1.3까지 버전이 올라감

**TLS(Transport Layer Security Protocol)로 명칭이 변경**되었으나, 통칭하여 SSL/TLS로 부름

-   SSL/TLS는 전송 계층에서 보안을 제공하는 프로토콜
-   제 3자가 메시지를 도청하거나 변조하지 못하도록 함

| **항목** | **SSL** | **TLS** |
| --- | --- | --- |
| **정식 명칭** | Secure Sockets Layer | Transport Layer Security |
| **개발 주체** | Netscape | IETF(인터넷 표준화 기구) |
| **버전** | SSL 2.0, 3.0 (현재 모두 폐기됨) | TLS 1.0, 1.1, 1.2, 1.3 |
| **보안성** | 취약점 존재, 더 이상 사용되지 않음 | 최신 버전은 보안이 강화됨 |
| **호환성** | 과거 시스템과 호환 | SSL과의 하위 호환 제공 (초기 TLS) |
| **사용 여부** | 더 이상 사용하지 않음 | **현재 대부분의 웹에서 사용** 중 |

![6](https://github.com/user-attachments/assets/caf90d10-c8f1-4760-ad73-6edcb994c882)


SSL/TLS를 통해 공격자가 서버인 척하면서  사용자 정보를 가로채는 네트워크상의 \`**인터셉터\` 방지 가능**

-   SSL/TLS는 **보안 세션을 기반**으로 데이터를 암호화
-   **보안 세션 만들기 👉** _**인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘**_ 사용됨

---

### 보안 세션

**보안이 시작되고 끝나는 동안 유지되는 세션**

SSL/TLS는 핸드셰이크를 통해 보안 세션을 생성, 이를 기반으로 상태 정보 등을 공유

> **📌 세션**   
> 운영체제가 어떠한 사용자로부터 자신의 자산 사용을 허락하는 일정 기간  
> 사용자는 일정 시간 동안 응용 프로그램 & 자원 사용 가능

![7](https://github.com/user-attachments/assets/122b943c-6655-4500-9560-3553d3c18880)


클라이언트와 서버가 키를 공유하고, 이를 기반으로 인증, 인증 확인 등의 작업이 발생  
\= **단 한 번의 1-RTT가 생긴 후 데이터를 송수신** 

1.  클라이언트에서 \`사이퍼 슈트(cypher shites)\`를 서버에 전달
2.  서버는 사이퍼 슈트의 암호화 알고리즘 리스트를 제공할 수 있는지 확인
3.  제공할 수 있다면 클라이언트로 **인증서를 보내는 인증 메커니즘** 시작
4.  이후 해싱 알고리즘 등으로 암호화된 데이터 송수신 시작

> 📌 TLS 1.3은 사용자가 이전에 방문한 사이트를 재방문하는 경우, 위 통신을 하지 않아도 됨 **(= 0-RTT)**

---

#### 사이퍼 슈트

**프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘**이 나열된 규약으로 다섯 개가 있음

-   TLS\_AES\_128\_GCM\_SHA256
-   TLS\_AES\_256\_GCM\_SHA384
-   TLS\_CHACHA20\_POLY1305\_SHA256
-   TLS\_AES\_128\_CCM\_SHA256
-   TLS\_AES\_128\_CCM\_8\_SHA256

_EX) TLS\_AES\_128\_GCM\_SHA256_

-   TLS = 프로토콜
-   AES\_128\_GCM: AEAD 사이퍼 모드
-   SHA256: 해싱 알고리즘

> **❓ AEAD 사이퍼 모드  
> **AEAD(Authenticated Encryption with Associated Data)는 **데이터 암호화 알고리즘**을 의미  
> EX)  AES\_128\_GCM  
> **128비트의 키**를 사용하는 표준 블록 암호화 기술 + **병렬 계산**에 용이한 **알고리즘 GCM**이 결합된 알고리즘

---

### 1) 인증 메커니즘

인증 메커니즘은 \`**CA**\` (Certificate Authorities)에서 발급한 인증서를 기반으로 이루어짐

CA에서 발급한 인증서는 안전한 연결을 시작하는 데 있어 필요한 \`**공개키\`를 클라이언트에 제공**하고,  
사용자가 접속한 **서버가 신뢰할 수 있는 서버**임을 보장

CA는 아무 기업이나 할 수 있는 것이 아니며, _신뢰성이 엄격히 공인된 기업들만 참여_ 가능

> Ex) Comodo, GoDaddy, GlobalSign, 아마존 등

---

#### CA 발급 과정

서비스가 CA 인증서를 발급받으려면 \`**사이트 정보**\`와 \`**공개키**\`를 CA에 제출해야 함

이후 CA는 공개키를 해시한 값인 **지문(finger print)**을 사용하는 CA의 비밀키 등을 기반으로 CA 인증서 발급

> **❓ 개인키, 공개키  
>   
> 개인키 (비밀키)**: 개인이 소유하고 있는 키, 반드시 자신만이 소유해야 하는 키  
> **공개키**: 공개된 키

---

#### 인증서를 사용하는 이유

인증서는 **서버가 진짜 신뢰할 수 있는 주체인지 클라이언트에게 증명**하기 위한 수단임

#### 인증서의 역할

1.  서버의 공개키와 도메인이 진짜인지 검증
2.  공개키가 제 3자 (인증기관, CA)에 의해 발급되었는지 확인
3.  중간자 공격 방지

#### 인증서에 들어있는 것

-   서버의 도메인 정보
-   서버의 공개키
-   인증기관의 전자 서명
-   유효기간 등 메타 정보

브라우저는 내장된 신뢰된 루트 CA 목록을 가지고, 서버 인증서의 서명 검증

> **📌 정리  
> **인증서 없이는 **누가 공개키를 보냈는지 알 수 없어서, 신뢰할 수 없는 암호화**가 됨  
> ∴ SSL/TLS 핸드셰이크 (= HTTPS 핸드셰이크)에서 인증서를 먼저 보내는 것

---

### 2) 암호화 알고리즘

### 공개키는 보안을 위해, 대칭키는 **속도를 위해** 사용됩니다.

HTTPS에서는 처음에 **공개키로 대칭키를 안전하게 주고받고**, 이후는 **대칭키로 빠르게 암호화**합니다.

| **항목** | **공개키 암호화** | **대칭키 암호화** |
| --- | --- | --- |
| **키 사용 방식** | 공개키로 암호화, 개인키로 복호화 | 같은 키로 암호화와 복호화 |
| **속도** | 느림 | 빠름 |
| **사용 시점** | **초기 핸드셰이크에서만 사용** (대칭키 전달용) | 이후 **실제 데이터 전송에 사용** |
| **예시 알고리즘** | RSA, ECDHE | AES, ChaCha20 |

---

#### \- 공개키 암호화: 디피-헬만키 교환 암호화 알고리즘 (Diffie-Hellman key exchange)

![8](https://github.com/user-attachments/assets/40ce6cdf-3561-4349-a470-aad98e0ce63e)


g, x, p를 안다면 y를 구하기 쉽다. 하지만**, g, y, p만 아는 경우 x는 구하기 어렵다**는 원리에 기반한 알고리즘

![9](https://github.com/user-attachments/assets/df87e62a-9b0a-4dbf-b596-3cac0f9c0095)


1.  처음 공개 값 공유
2.  각자 비밀 값과 혼합 후 공유
3.  각자의 비밀 값과 혼합
4.  공통 암호키 생성 (= PSK (Pre-Shared Key))

_PSK가 생성된다면, 악의적인 공격자가 개인키 또는 공개키를 가지고도 **PSK가 없기 때문에 아무것도 못 함**_

---

#### \- 대칭키 암호화: AES (Advanced Encryption Standard)

가장 **널리 사용**되는 대칭키 블록 암호화 알고리즘

| **항목** | **내용** |
| --- | --- |
| **이름** | **Advanced Encryption Standard** (고급 암호화 표준) |
| **대체한 것** | 과거 **DES**(Data Encryption Standard)를 대체 |
| **암호 방식** | **대칭키 암호화** – 암호화와 복호화에 같은 키 사용 |
| **블록 크기** | **128비트 고정** |
| **키 길이** | **128, 192, 256비트 중 하나 선택** |
| **라운드 수** | 키 길이에 따라 **10, 12, 14 라운드** |
| **사용처** | HTTPS, VPN, 파일 암호화, 하드디스크 암호화 등 |

---

### 3) 해싱 알고리즘

해싱 알고리즘은 **데이터를** 추정하기 힘들도록 **더 작고, 섞여 있는 조각으로** 만드는 알고리즘

SSL/TLS는 SHA-256, SHA-384알고리즘을 사용함.

#### SHA-256 알고리즘

**해시 함수의 결괏값이 256비트**인 알고리즘

해싱을 해야 할 메시지에 1을 추가하는 등의 전처리를 하고, 전처리된 메시지를 기반으로 해시 반환

> 비트 코인을 비롯한 많은 블록체인 시스템에서도 사용됨

| **원문** | **SHA -256 알고리즘 사용** |
| --- | --- |
| Hello World! | 7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069 |

> **❓ 해시, 해싱, 해시 함수**  
>   
> \- **해시**: 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑한 값  
> \- **해싱**: 임의의 데이터를 해시로 바꿔주는 일, 해시 함수가 담당  
> \- **해시 함수**: 임의의 데이터를 해시로 바꿔주는 함수 

---

## HTTP의 무상태 (Stateless) 특성

**HTTP는 무상태(stateless) 프로토콜**

서버는 클라이언트의 이전 요청이나 상태를 "**기억하지 않는다**" 는 의미

#### 왜 Stateless인가?

HTTP는 원래 **간단한 요청-응답 구조**를 위해 설계된 프로토콜임  
클라이언트가 요청을 보내면 서버는 응답하고, 그걸로 끝.

-   서버는 **"누가", "무엇을 요청했는지" 상태 정보를 유지하지 않는다.**
-   매 요청은 **독립적이며, 이전 요청과 관계X**

> EX) 사용자가 로그인 후 상품 페이지를 열람해도, HTTP 자체만으로는 로그인 상태인지 알 수 없음

| **장점** | **단점** |
| --- | --- |
| 서버 확장성: 상태를 기억하지 않기 때문에 서버 부담이 줄어듦 | 클라이언트 상태(예: 로그인, 장바구니 등)를 **따로 관리**해야 함 |
| **구현 단순함**: 각 요청은 독립적으로 처리됨 | **쿠키, 세션, 토큰** 등의 기술이 함께 사용됨 |

**즉, HTTP는 Stateless하므로, 사용자의 상태는 기본적으로 서버가 기억하지 않음  
**따라서 실무에서는 상태를 유지하기 위한 보완 기법(쿠키, 세션, 토큰 등)이 필수

---
## DNS (Domain Name System)

DNS는 애플리케이션 계층 프로토콜로, **인터넷에서 도메인 이름을 IP 주소로 변환**하는 시스템

**웹사이트 주소**를 입력할 때, **DNS는 그 도메인 이름을 컴퓨터가 이해할 수 있는 숫자 형태인 IP 주소로 변환**

> EX) 도메인인 이름: [www.example.com](http://www.example.com) 👉  IP주소: 93.184.216.34

---

### 역할

-   **도메인 이름을 IP 주소로 변환**하여 브라우저가 서버에 접속할 수 있게 함
-   **인터넷 자원의 위치를 쉽게 찾을 수 있도록** 함 (사람들이 기억하기 쉬운 이름을 사용)

---

### TCP와 UDP 중 어떤 것을 사용하는가?

DNS는 기본적으로 **UDP**를 사용, 일부 경우에 따라 **TCP**도 사용됨

#### **UDP (User Datagram Protocol)** 사용

-   빠르고 간단한 요청/응답을 처리하는 데 적합하기 때문에 기본적으로 DNS질의는 UDP를 사용함
-   DNS는 짧은 메시지를 처리하며, 연결을 설정할 필요가 없고 빠른 응답을 제공
-   기본 포트: UDP 53번 포트

#### **TCP (Transmission Control Protocol)** 사용

-   **큰 응답 메시지**(예: 많은 레코드나 데이터를 반환하는 경우)에 대해서는 **UDP에서 처리할 수 없는 경우** TCP로 전환
-   **EX) DNS 응답이 512바이트를 초과하는 경우**, 클라이언트는 **TCP**를 통해 DNS 서버와 통신
-   기본 포트: **TCP 53번 포트**

---

## "www.github.com" 을 브라우저에 입력하면? 

이 과정은 DNS 요청부터 웹 서버 응답까지 이루어짐

1.  **브라우저가 URL을 입력**
    1.  사용자가 \*\*www.github.com\*\*을 브라우저에 입력하고 엔터를 칩니다.
    2.  브라우저는 **URL 파싱**을 통해 해당 주소가 **HTTP/HTTPS**로 시작하는지 확인합니다.
    3.  HTTPS는 보안 연결을 의미하며, 브라우저는 먼저 **DNS 요청**을 통해 해당 도메인의 **IP 주소**를 찾습니다.
2.  **DNS 요청**
    -   브라우저는 \*\*DNS 리졸버(Resolver)\*\*에 \*\*www.github.com\*\*에 대한 **IP 주소**를 요청합니다.
    -   이때 브라우저가 DNS 캐시를 가지고 있다면, 바로 캐시된 IP 주소를 사용할 수 있습니다. 없다면, DNS 요청이 **로컬 DNS 서버**로 전송됩니다.
3.  **DNS 서버와의 상호작용**
    -   **로컬 DNS 서버**는 \*\*www.github.com\*\*에 대한 IP 주소를 찾기 위해, DNS 루트 서버부터 시작하여 **최상위 도메인(TLD) 서버**(예: .com), 그 후 **권한 있는 DNS 서버**(www.github.com을 관리하는 서버)로 순차적으로 요청을 보냅니다.
    -   DNS 서버가 \*\*www.github.com\*\*에 대한 IP 주소를 찾으면, 그 결과를 **브라우저에 반환**합니다.
4.  **서버의 IP 주소 확인**
    -   예를 들어, DNS 서버가 **192.30.255.113**과 같은 **GitHub의 IP 주소**를 반환합니다.
    -   브라우저는 이제 **GitHub 서버의 IP 주소**를 알고 있으므로, 해당 주소로 **TCP 연결**을 시작합니다.
5.  **TCP 연결을 위한 3-way 핸드셰이크 (3단계 연결 과정)**
    -   **브라우저**는 **GitHub 서버**의 IP 주소로 **TCP 연결 요청**을 보냅니다.
    -   이 과정은 **3-way 핸드셰이크**로 이루어집니다:
        1.  **SYN**: 브라우저는 GitHub 서버에 **SYN** 패킷을 보내 **연결 시작**을 요청합니다.
        2.  **SYN-ACK**: GitHub 서버는 **SYN-ACK** 패킷을 응답하여 **연결을 수락**합니다.
        3.  **ACK**: 브라우저는 **ACK** 패킷을 보내 **연결을 확립**합니다.
    -   이렇게 TCP 연결이 **완성**됩니다.
6.  **TLS/SSL 핸드셰이크 (HTTPS 연결 시)**
    
    -   **HTTP/HTTPS**는 **보안 연결**을 위해 **TLS/SSL 핸드셰이크**를 사용합니다. 이 과정은 HTTPS가 안전하게 데이터를 암호화하고 무결성을 보장할 수 있도록 합니다.
    
    1.  **클라이언트 Hello**: 브라우저는 GitHub 서버에 **TLS ClientHello** 메시지를 보내, 지원하는 암호화 알고리즘, 세션 ID 등을 포함하여 **서버에 TLS 설정 요청**을 합니다.
    2.  **서버 Hello**: GitHub 서버는 **TLS ServerHello** 메시지를 보내, 서버가 선택한 암호화 알고리즘과 공개 키 등을 전송합니다.
    3.  **서버 인증서 전송**: GitHub 서버는 **서버 인증서**(SSL 인증서)를 브라우저로 전송하여, **서버의 신뢰성을 인증**합니다.
    4.  **키 교환**: 클라이언트와 서버는 **세션 키**를 안전하게 교환합니다. 일반적으로 **디피-헬만(Diffie-Hellman)** 키 교환 알고리즘을 사용합니다.
    5.  **암호화된 통신 시작**: 이 과정을 마친 후, **클라이언트와 서버**는 **대칭키**를 사용하여 **암호화된 통신**을 시작합니다.
7.  **HTTP 요청 전송**
    -   이제 브라우저는 HTTPS 연결을 통해 **GitHub 서버**에 **HTTP 요청**을 보냅니다.
    -   이 요청은 **GET** 메서드로 **웹 페이지**나 리소스를 요청하는 내용이 포함됩니다.
    -   예를 들어, / (홈페이지 요청) 또는 /index.html와 같은 리소스를 요청할 수 있습니다.
8.  **GitHub 서버의 응답**
    -   **GitHub 서버**는 **HTTP 응답**을 반환합니다. 응답에는 **HTML 파일**, **CSS 파일**, **JavaScript 파일**, **이미지** 등 다양한 리소스가 포함될 수 있습니다.
    -   서버는 **웹 페이지의 HTML**과 필요한 **스타일 시트(CSS)**, **스크립트 파일(JavaScript)** 등을 전송합니다.
    -   서버는 HTTP 응답에 **200 OK**와 함께 웹 리소스를 반환하거나, 페이지가 없으면 **404 Not Found**와 같은 오류 코드를 반환할 수 있습니다.
9.  **브라우저가 응답 처리**
    -   브라우저는 받은 **HTML, CSS, JavaScript** 등을 해석하여 **웹 페이지를 렌더링**합니다.
    -   만약 추가적인 리소스(이미지, 폰트 등)를 로드해야 한다면, **추가 HTTP 요청**을 보내어 필요한 자원을 받습니다.
10.  **연결 종료 (TCP)**
    -   모든 요청과 응답이 완료되면, 브라우저와 GitHub 서버 간의 **TCP 연결**은 **FIN 패킷**을 통해 종료됩니다.
    -   **4-way 핸드셰이크**를 통해 연결이 닫히며, 서버와 브라우저는 연결을 종료합니다.

---

# 쿠키 & 세션

## 쿠키와 세션의 차이점

### 1. 쿠키 (Cookie)
- **클라이언트 측 저장**: 쿠키는 **클라이언트**(사용자 브라우저)에 저장됩니다.
- **저장되는 정보**: 사용자 정보, 세션 ID, 사이트의 설정 등.
- **만료 시간**: 만료 시간 설정 가능 (세션 쿠키는 브라우저 종료 시 삭제, 영구 쿠키는 설정한 시간까지 저장).
- **서버와의 통신**: 브라우저는 **HTTP 요청 시마다 쿠키를 서버로 전송**합니다.
- **용도**: 주로 **사용자 인증**, **선호 설정**, **트래킹** 등.

### 2. 세션 (Session)
- **서버 측 저장**: 세션 정보는 **서버**에 저장됩니다. 서버는 사용자별로 고유한 세션을 유지하고 관리합니다.
- **세션 ID**: 클라이언트는 **세션 ID**만 쿠키로 저장하고, 이 ID를 통해 서버에서 세션 데이터를 조회합니다.
- **만료 시간**: 세션은 보통 **서버의 세션 타임아웃**에 따라 만료됩니다 (세션 타임아웃 설정 가능).
- **용도**: 주로 **로그인 정보 유지**, **쇼핑 카트 관리**, **사용자 상태 관리** 등.

### 쿠키 vs 세션

| 특성 | 쿠키 | 세션 |
|------|------|------|
| 저장 위치 | 클라이언트 (브라우저) | 서버 |
| 만료 시간 | 설정 가능 (영구적 또는 세션 만료) | 서버 타임아웃에 의존 |
| 보안성 | 클라이언트에 저장되므로 상대적으로 취약 | 서버에 저장되므로 보안성 높음 |
| 용도 | 트래킹, 사용자 설정, 간단한 데이터 저장 | 인증, 사용자 상태 관리 |

---

## 세션 방식의 로그인 과정

세션 방식의 로그인 과정은 사용자가 로그인을 한 후, 서버가 사용자 상태를 추적하기 위해 **세션 ID**를 관리하는 방식입니다. 세션을 이용한 로그인 과정은 다음과 같습니다:

### 1. 로그인 요청
사용자가 로그인 폼에 **아이디와 비밀번호**를 입력하고 **서버에 로그인 요청**을 보냅니다.

### 2. 사용자 인증
서버는 **사용자가 입력한 정보**(아이디, 비밀번호)를 확인하여 **인증**합니다.
- 인증이 성공하면 서버는 사용자에게 고유한 **세션 ID**를 생성하여 **세션 저장소**에 저장합니다.

### 3. 세션 ID 전송
서버는 세션 ID를 **쿠키**로 클라이언트(브라우저)에 전송합니다. 이 쿠키는 클라이언트의 브라우저에 저장됩니다.
- 클라이언트는 **다음 요청 시마다** 세션 ID가 포함된 **쿠키를 서버로 전송**합니다.

### 4. 이후 요청 시 세션 확인
클라이언트가 **로그인 후 웹사이트를 탐색**할 때마다, 브라우저는 세션 ID를 포함한 **쿠키를 자동으로 서버에 전송**합니다.
- 서버는 전송받은 세션 ID를 확인하여, **세션 저장소에서 해당 사용자 정보를 조회**하고 요청을 처리합니다.

### 5. 로그아웃
사용자가 **로그아웃**하면, 서버는 해당 세션을 **삭제**하고, 클라이언트의 세션 쿠키를 **삭제**하여 **세션이 만료**되도록 합니다.

---

## 규모가 커져 서버가 여러 개가 될 경우 세션을 관리하는 방법

서버가 여러 개일 경우, **세션 관리**는 중요합니다. 각 서버가 개별적으로 세션 정보를 관리하게 되면, 사용자가 요청할 때마다 서로 다른 서버에 연결될 수 있기 때문에 **세션 불일치**가 발생할 수 있습니다.

### 세션 관리 방법

1. **세션 클러스터링 (Session Clustering)**
   - 여러 서버 간에 세션 정보를 **공유**하는 방법입니다. 예를 들어, Redis나 Memcached 같은 **세션 스토어**를 사용하여 모든 서버가 공통된 세션 저장소에 접근하도록 합니다.
   - 이 방법을 사용하면 **어떤 서버로 요청이 오더라도** 동일한 세션 정보를 사용할 수 있습니다.

2. **세션 복제 (Session Replication)**
   - 각 서버가 세션 정보를 **자신의 메모리에 복제**하여 저장하는 방법입니다. 하나의 서버에 세션 정보가 변경되면 이를 다른 서버로 전파하여 세션을 일치시킵니다.
   - 하지만 이 방법은 **서버 간 데이터 동기화**가 필요하기 때문에 성능에 영향을 미칠 수 있습니다.

3. **로드 밸런싱 (Load Balancing)**
   - 세션 정보를 **서버 간에 고정**시켜 특정 사용자 요청이 항상 같은 서버로 가도록 하는 방법입니다. 이를 위해 **세션 고정화(Session Stickiness)**를 사용합니다.
   - 이 방식은 **세션 정보를 한 서버에서만 유지**하기 때문에 서버의 부하 분산에 주의해야 합니다.

---

## Stateless와 Connectionless의 차이점

### 1. Stateless
- **Stateless**는 시스템이 **상태를 유지하지 않는 특성**을 의미합니다.
- 즉, **서버**는 각 요청에 대해 **이전 요청과의 관계**를 기억하지 않습니다.
- 예시: **HTTP**는 **Stateless** 프로토콜로, 서버는 각 요청을 독립적으로 처리하고, 이전 요청에 대한 정보를 기억하지 않습니다.

### 2. Connectionless
- **Connectionless**는 **연결을 유지하지 않는** 통신 방식입니다.
- 요청을 보낸 후 **연결을 끊고** 다시 연결할 필요가 없는 방식을 의미합니다.
- 예시: **UDP**는 **Connectionless** 프로토콜로, 연결을 설정하지 않고 데이터를 송수신합니다.

### 차이점
- **Stateless**는 **상태 정보**를 저장하지 않는 특성이고, **Connectionless**는 **연결을 유지하지 않는** 특성입니다.
- **Stateless**는 주로 **서버가 상태를 기억하지 않음**을 의미하고, **Connectionless**는 주로 **연결이 지속되지 않음**을 의미합니다.

---

## HTTP가 Stateless 구조를 채택한 이유

HTTP는 **Stateless** 구조를 채택한 주요 이유는 다음과 같습니다:

1. **단순성**: HTTP는 요청-응답 패턴에 초점을 맞춘 간단한 프로토콜입니다. 각 요청은 **독립적**이고, 서버가 **상태를 유지할 필요가 없습니다**. 이는 서버의 복잡성을 줄여줍니다.
   
2. **확장성**: HTTP가 **Stateless**하면, **서버가 더 적은 메모리**를 사용하고, 여러 서버로 확장할 때 효율적으로 처리할 수 있습니다.

3. **성능 최적화**: 각 요청을 독립적으로 처리함으로써 **서버 리소스**를 절약하고, 서버가 클라이언트 상태를 추적할 필요 없이 요청에 집중할 수 있습니다.

4. **유연성**: HTTP의 Stateless 특성 덕분에 **다양한 환경**에서 동작할 수 있습니다. 클라이언트가 여러 번 요청할 수 있고, 서버 간에도 세션을 처리하기 위한 외부 시스템을 사용할 수 있습니다.
