# IP

## IP 프로토콜

네트워크 계층에 해당하는 통신 프로토콜로 라우팅을 담당한다.

라우팅이란 ❓ 라우팅 테이블의 정보를 기반으로 데이터를 출발지에서 목적지까지 최적의 경로를 따라 전달하는 과정

라우팅 테이블이란 ❓ 각 노드 사이의 연결 정보(전송 속도 or 라우터 개수)를 저장한 테이블

## IP 주소

IP 프로토콜을 사용하는 네트워크 상에서 각 장치(컴퓨터, 스마트폰 등)를 식별하는 고유한 주소

## IPv4 vs IPv6

- IPv4 주소
    - 네트워크 상에서 유일한 주소
    - 특별한 언급 없이 IP 주소라고 하면 IPv4
    - 크기 : 32비트(4바이트)
    - 10진 표현, 8비트씩 네 묶음으로 구성 : 0.0.0.0 ~ 255.255.255.255
    - 약 42억 개의 주소 할당이 2011년 종료 됨 → 신규 주소 할당 중지
- IPv6 주소
    - 크기 : 128비트(16바이트)
    - 유비쿼터스 환경에서 사물마다 주소를 부여할 수 있는 수준
    - 16진 표현, 16비트씩 여덟 묶음으로 구성, ‘:’ 기호로 구분 : 2001:0db8:85a3:0000:0000:8a2e:0370:7334
    - IPv4와 IPv6는 호환이 되지 않음 → IPv6 교체 비용이 높아서 적용이 더딘 상황

## IP주소 vs MAC 주소

| 항목 | IP 주소 | MAC 주소 |
| --- | --- | --- |
| 의미 | 네트워크 상의 논리적 주소 | 네트워크 장치의 물리적 주소 |
| 계층 | 네트워크 계층 (3계층) | 데이터 링크 계층 (2계층) |
| 변경 여부 | 네트워크가 달라지면 변경됨(망에 할당되기 때문) | 일반적으로 고정 (NIC에 할당되기 때문) |
| 역할 | 라우팅과 통신 경로 결정 | LAN 내 장치 식별 |
| 표현 | 십진수로 표현(32bit) ex. 192.168.1.1 | 16진수로 표현(48bit) ex. 00:1A:2B:3C:4D:5E |

## TTL

네트워크 패킷이 얼마나 멀리(몇 번) 전송될 수 있는지를 제한하는 숫자 값

- 패킷이 무한히 네트워크를 떠돌지 않도록 방지
- 라우터를 지날 때마다 TTL 값이 1씩 감소
- TTL이 0이 되면, 라우터는 그 패킷을 폐기
    - ex. TTL이 5인 패킷 → 5개 라우터를 지나면 0이 되어 폐기

## IPv4 Checksum vs TCP Checksum

Checksum이란 **❓** 데이터가 전송 중에 손상되었는지 오류를 검사하는 기능

| 항목 | IPv4 Checksum | TCP Checksum |
| --- | --- | --- |
| 위치 | IP 헤더 | TCP 세그먼트 전체(헤더 + 데이터) |
| 검사 대상 | IP 헤더만 검사 | TCP 헤더 + 데이터 검사 |
| 보호 수준 | 헤더 오류만 탐지 가능 | 전송 데이터 전체 오류 탐지 가능 |
| **IPv6** 지원 여부 | X (IPv6에는 체크섬 없음) | O (IPv6에서도 TCP 체크섬 사용) |

➡️ 둘 다 오류 검출만 하고 오류 복구는 TCP 프로토콜이 한다.

# HTTP & HTTPS

## HTTP의 Stateless 특성

- HTTP는 Stateless 프로토콜로 상태 정보를 저장하지 않는다.
    
    → 즉, 서버가 클라이언트의 이전 요청 상태를 기억하지 않는다.
    
- 각 요청은 독립적이다.
- 클라이언트가 요청할 때마다 모든 정보를 포함해야 한다.

## HTTP가 Stateless 구조를 채택하고 있는 이유

- 단순하고 가볍기 때문
    
    → 각 요청은 독립적으로 처리됨
    
- 확장성, 성능에 유리
    
    → 서버가 클라이언트 상태를 기억하지 않으므로, 서버 간 분산 처리 및 로드 밸런싱에 유리함
    

## HTTPS 공개키 vs 대칭키

## 대칭키 암호화 방식

- 암호화 키와 복호화 키가 같은 암호화 방식
- 장점
    - 비교적 간단한 방식으로 구현이 가능하다
    - 암호화 & 복호화에 걸리는 시간이 짧다
- 단점
    - 키 전달이 어렵다

## 비대칭키 암호화 방식

- 암호화와 복호화를 다른 키로 수행
    
    → 공개키로 암호화 & 개인키로 복호화
    
- 장점
    - 키를 안전하게 공유할 수 있다.
- 단점
    - 암호화 & 복호화에 걸리는 시간이 길다

➡️ HTTPS에서는 비대칭키로 키를 안전하게 전달하고, 대칭키로 통신한다.

## HTTPS에서의 암호화 방식 사용 흐름

- 클라이언트 → 서버 접속
- 서버 → 공개키가 포함된 인증서 전달
- 클라이언트 → 서버의 공개키로 대칭키를 암호화해서 전송
    
    → 여기서 비대칭키 암호화 사용
    
- 서버 → 개인키로 복호화해 대칭키 획득
- 이후 통신은 둘 다 같은 대칭키로 암호화/복호화
    
    → 여기서 대칭키 암호화 사용
    

## HTTPS Handshake 과정에서 인증서를 사용하는 이유

인증서는 **공개키의 주인이 진짜 서버인지 증명하기 위해** 사용된다.

→ 인터넷에서는 누구나 서버처럼 행동할 수 있기 때문에 확실히 서버임을 증명하기 위해 인증서를 보내고 클라이언트는 이를 검증한다.

- 인증서의 역할
    1. 서버의 공개키,  도메인 이름을 포함
    2. 신뢰할 수 있는 인증기관(CA)이 서명함
    3. 만약 인증서가 위조되었거나 유효하지 않으면 → 연결 실패
- 인증서가 없을 경우
    - 클라이언트가 해커 서버의 공개키를 믿고 대칭키를 전달할 수 있음
        
        **→** 중간자 공격(MITM, Man-In-The-Middle) 발생 가능
        

# HTTP 응답 코드

| 범주 | 의미 | 설명 |
| --- | --- | --- |
| **1xx** | 정보 | 요청을 받았고, 처리를 계속함 |
| **2xx** | 성공 | 요청이 성공적으로 처리됨 |
| **3xx** | 리다이렉션 | 클라이언트가 다른 곳으로 이동해야 함 |
| **4xx** | 클라이언트 오류 | 요청에 잘못된 점이 있음 |
| **5xx** | 서버 오류 | 서버에서 요청 처리 중 오류 발생 |

## GET vs POST

| 항목 | **GET** | **POST** |
| --- | --- | --- |
| 목적 | 데이터를 조회 (가져오기) | 데이터를 전송 (생성, 등록 등) |
| 데이터 전달 위치 | URL에 포함 (쿼리 스트링: `?name=abc`) | HTTP Body에 포함 |
| 노출 여부 | URL에 그대로 보임 → 보안에 취약 | **U**RL에 보이지 않음 → 비교적 안전 |
| 길이 제한 | 브라우저/서버에 따라 길이 제한 있음 | 길이 제한 없음 |

## POST vs PUT vs PATCH

| 항목 | **POST** | **PUT** | **PATCH** |
| --- | --- | --- | --- |
| 목적 | 새 리소스 생성 | 전체 리소스를 생성 또는 수정 | 리소스의 일부만 수정 |
| 멱등성 | X (매번 다른 결과) | O (같은 요청 → 같은 결과) | O |
| 사용 예 | 회원가입, 댓글 작성 | 사용자 정보 전체 수정 | 사용자 정보 일부 수정  |
| 요청 내용 | 새로운 데이터 | 전체 데이터 | 변경할 일부 데이터만 포함 |
| 리소스 식별 | 서버가 생성함 (`POST /users`) | 클라이언트가 ID 지정 (`PUT /users/123`) | 특정 리소스의 일부 필드만 수정 (`PATCH /users/123`) |

# SSL & TLS

- SSL/TLS
    - 웹 서버와 클라이언트 사이에 전송되는 데이터를 암호화하여 인터넷 연결 상의 보안을 유지하는 기술
    - 모든 종류의 internet traffic을 암호화한다.
    - 암호화/인증/무결성을 제공한다.
    - SSL이 TLS의 기반 기술
- SSL vs TLS
    
    
    | 항목 | **SSL (Secure Sockets Layer)** | **TLS (Transport Layer Security)** |
    | --- | --- | --- |
    | 개발 | 넷스케이프사 (1990년대) | IETF (1999년부터) |
    | 현재 상태 | 더 이상 사용하지 않음  | 현재 웹의 표준 보안 프로토콜  |
    | 최신 버전 | SSL 3.0 (1996) | TLS 1.3 (2018, 최신) |
    | 보안성 | 취약점 많음 | 더 안전하고 효율적 |
    | 용도 | 과거의 HTTPS 보안 | 현재 모든 HTTPS 통신의 기반 |

# DNS

- 도메인 이름을 IP 주소로 바꿔주는 시스템
    
    → 사람이 이해하기 쉬운 도메인을, 컴퓨터가 이해할 수 있는 숫자 주소(IP)로 변환하는 역할
    
    - 사용자가 브라우저에 `www.google.com` 입력
        
        → DNS가 이를 `142.250.206.4` 같은 IP 주소로 변환
        
        → 브라우저가 해당 IP로 접속함
        
- DNS는 애플리케이션 계층 ****프로토콜이다.
    - 사용자는 직접 DNS를 사용하지 않지만, 웹 브라우저 같은 애플리케이션에서 자동으로 호출된다.
- 기본적으로 UDP를 사용하지만 상황에 따라 TCP도 사용한다.
    
    
    | 구분 | 사용 여부 | 이유 |
    | --- | --- | --- |
    | **UDP**  | 기본 사용 | 빠르게 요청/응답하는 데 적합함 (속도 중요) |
    | **TCP** | 일부 상황에서 사용 | 응답이 크거나, 영역 전송(Zone Transfer) 시 사용 |

# 쿠키 & 세션

## 쿠키 vs 세션

| 항목 | 쿠키 (Cookie) | 세션 (Session) |
| --- | --- | --- |
| 저장 위치 | 클라이언트(브라우저) | 서버 |
| 보안성 | 낮음 (사용자에게 노출) | 높음 (서버에서만 관리) |
| 용량 제한 | 약 4KB | 제한 없음 (메모리나 DB 용량에 따라) |
| 만료 | 클라이언트가 설정 | 서버가 설정 |
| 사용 예 | 자동 로그인, 최근 본 상품 | 로그인 상태 유지 등 민감한 정보 저장 |
| 속도 | 빠름 (로컬에 저장) | 상대적으로 느림 (서버 접근 필요) |

## 세션 기반 로그인 방식 (흐름)

1. 사용자가 로그인 정보 입력 → 서버에 전송
2. 서버가 아이디/비번 확인
3. 로그인 성공 시:
    - 서버는 세션 I**D**를 생성
    - 세션 ID와 사용자 정보 매핑하여 서버 메모리에 저장
4. 세션 ID를 쿠키에 담아 클라이언트에 전달
5. 이후 요청에서 브라우저는 세션 ID 쿠키를 함께 보냄
6. 서버는 세션 ID로 사용자를 식별 → 로그인 상태 유지

## Stateless vs Connectionless

| 구분 | **Stateless** | **Connectionless** |
| --- | --- | --- |
| 정의 | 이전 요청과 상태를 기억하지 않음 | 연결을 유지하지 않음 |
| 대상 | 주로 **HTTP 구조**에 사용 | 주로 **UDP**와 같은 전송 방식에 사용 |
| 특징 | 상태 저장 X → 확장성 좋음 | 연결 설정 없이 데이터 전송 → 속도 빠름 |
| 예시 | HTTP, REST API | UDP (DNS, 스트리밍 등) |

# **www.github.com 입력 시 네트워크 상에서 일어나는 일**

1. **DNS 조회**: 브라우저는 `www.github.com`의 IP 주소를 찾기 위해 DNS 서버에 요청한다.
2. **TCP 연결**: DNS에서 IP 주소를 받은 후, 브라우저는 해당 IP 주소와 TCP 연결을 설정한다. (3-way handshake)
3. **TLS/SSL 핸드셰이크**: 보안 연결을 위해 **HTTPS**를 사용하여 TLS 핸드셰이크가 이루어진다. 서버는 인증서를 보내고, 브라우저는 이를 검증한다.
4. **HTTP 요청**: 브라우저는 GET 요청을 서버에 보내어 웹 페이지를 요청한다.
5. **서버 응답**: 서버는 요청한 웹 페이지를 HTTP 응답으로 보내며, 필요한 리소스(HTML, CSS, JS 등)를 포함한다.
6. **페이지 렌더링**: 브라우저는 응답받은 HTML을 해석하고 웹 페이지를 렌더링하여 사용자에게 표시한다.