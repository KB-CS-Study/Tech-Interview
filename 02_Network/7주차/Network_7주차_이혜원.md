## 1. IP

> 인터넷에 연결된 장치를 식별하는 고유한 숫자 레이블
>

- 개념
    - 인터넷을 통해 데이터를 주고받을 때 사용되는 **통신 규약**(프로토콜)
    - 인터넷 프로토콜(Internet Protocol)의 약자
    - 데이터 패킷이 올바른 목적지에 도착하도록 라우팅 되는데 사용
    - OSI Layer 3계층에 위치

### 1) IP 주소의 개념과 기능

- 개념
    - 인터넷에 연결된 각 기기를 구별하기 위해 사용되는 고유한 번호
    - `고정 IP`와 `동적 IP` 두 가지로 나뉜다
- 기능
    - 인터넷에 연결된 장치가 데이터를 보내고 받기 위해 필요함
    - 인터넷에서 통신을 가능하게 하는 핵심 요소
        - 기기 식별 : 데이터를 전송할 대상을 정확히 식별
        - 데이터 전송 : 데이터를 패킷 단위로 나누어 전송
        - 라우팅 : 네트워크 상에서 데이터 패킷의 최적의 경로를 결정
- 동작 방식
    - Local Network → ISP Router → `DNS Server`
    - Local Network → ISP Router → `Web Server`
- 한계
    - `비연결성`, `비신뢰성`, `프로그램 구분`
        - 프로그램 구분 : 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상일 경우 구분하지 못함
    - 패킷 소실, 전달 순서 문제 발생 등 여러 문제가 발생하는 한계가 있다
    - TCP(연결 지향, 데이터 전달 보증, 순서 보장) 특징으로 보완

### 2) IPv4과 IPv6의 차이점

### IPv4 vs IPv6 비교

| **항목**               | **IPv4**                                                   | **IPv6**                                                   |
|------------------------|------------------------------------------------------------|------------------------------------------------------------|
| **주소 구성**         | 수동 또는 DHCP로 구성                                     | 자동 구성 (Stateless), DHCPv6 지원, 주소 재사용 가능      |
| **중단 간 연결 무결성**| `NAT로 인해 직접 연결 어려움`                             | `종단 간 연결 가능 (NAT 불필요)`                             |
| **주소 공간**         | 약 43억 개 (2³²)                                           | 약 3.4 × 10³⁸ 개 (2¹²⁸)                                    |
| **암호화 및 인증**     | 선택적 제공 (IPSec은 별도 구성 필요)                      | IPSec이 표준에 포함되어 기본 제공                          |
| **주소 길이**         | `32비트 (4바이트)`                                           | `128비트 (16바이트)`                                         |
| **주소 표현**         | `십진수 4개를 점(.)으로 구분 <br> 예: `192.168.0.1`  `       |` 16진수 8개를 콜론(:)으로 구분` <br> 예: `2001:db8::1`       |
| **패킷 흐름 식별**     | 미지원 (QoS 구현 어려움)                                   | 흐름 레이블 필드로 패킷 흐름 식별 가능 (QoS 용이)         |
| **체크섬 필드**       | 사용함                                                    | 체크섬 없음 (상위 계층에서 처리)                          |
| **메시지 전송 방식**   | 브로드캐스트(Broadcast) 지원                               | 멀티캐스트(Multicast), 애니캐스트(Anycast) 지원            |
| **TTL / Hop 제한**     | `Time To Live (TTL)` 필드 사용 <br> 단위: 홉(기본은 초)     | `Hop Limit` 필드 사용 <br> TTL과 동일한 역할, 단위는 홉 수  |
- IPv6은 IPv4의 주소 부족 문제를 해결하고, 보안성과 연결성을 강화한 차세대 인터넷 프로토콜
- TTL, Hop Limit 차이 : 기능은 같으나 IPv4에서 초 단위로 생명을 측정하려고 만든 필드이지만, 실제로 라우터를 지날 때마다 -1씩 줄어듬(Hop Count) 개념으로 동작해서 IPv6에서 이름을 Hop Limit로 변경한 것

### 3) IP주소와 MAC 주소의 차이
> 실질적인 통신은 바꿀 수 없는 하드웨어 주소인 MAC Address를 통해서 하고 논리적인 IP Address로 라우팅을 하기 때문에 둘다 사용해야 한다.
>

| 항목 | MAC 주소 | IP 주소 |
| --- | --- | --- |
| 전체 양식 | 미디어 액세스 제어 주소 | 인터넷 프로토콜 주소 |
| 목적 | 인터넷상의 컴퓨터의 실제 하드웨어 주소 식별 | 인터넷에서 컴퓨터의 연결을 식별 |
| 주소 길이 | 48비트 (6바이트) 16진수 주소 | IPv4: 32비트 / IPv6: 128비트 주소 |
| 주소 할당 | NIC 제조업체가 고정 | 네트워크 관리자 또는 인터넷 서비스 제공자가 할당 |
| 주소 검색 | ARP 프로토콜이 MAC 주소를 검색함 | RARP 프로토콜이 IP 주소를 검색함 |
- MAC 주소는 하드웨어의 고유 ID이고, IP는 네트워크 상의 논리 주소이다
- MAC 주소의 위치는 변하지 않고, IP주소는 네트워크 환경에 따라 바뀐다
- MAC은 같은 네트워크 내에 데이터를 전달하지만, IP주소는 인터넷 상에서 장치를 찾는 것이다.


### 4) TTL(Time To Live)

> 네트워크에서 데이터의 **수명** or **유효기간**을 나타내기 위한 방법
>

- IP 패킷 or 데이터에 붙는 8비트 필드로, 최대값은 255
- TTL값은 패킷이 네트워크를 지날 때마다(=라우터를 거칠 때마다) 1씩 감소
- TTL==0이 되면 해당 패킷은 discard되고, 발신자에게 ICMP Time Exceeded 오류가 전송
- 목적 : 패킷이 무한으로 순환하거나 오래 유지 되지 않도록 제한하는 기능
    - 패킷 : 네트워크 계층에서 통신할 때 쓰이는 하나의 통신 단위

| **목적** | **설명** |
| --- | --- |
| **무한 루프 방지** | 경로가 잘못 지정되었거나, 목적지를 찾지 못한 패킷이 계속 순환하지 않도록 TTL을 이용해 폐기함. |
| **캐시 관리** | DNS, HTTP 등에서 TTL을 이용해 **데이터의 캐싱 주기**를 관리 (예: DNS 레코드 유효시간). |
| **네트워크 테스트** | ping, traceroute 명령에서 TTL을 활용하여 각 구간(=hop)의 응답 여부와 지연 시간 확인 가능. |

### 5) IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum 차이점
- IP는 **헤더만 검사**하고, TCP는 **헤더 + 데이터까지 검사**한다.
  
| 항목 | IPv4 체크섬 | TCP 체크섬 |
| --- | --- | --- |
| 검사 범위 | IP 헤더만 검사 | 의사 헤더(Pseudo Header) + TCP 헤더 + 데이터 전체 검사 |
| 목적 | IP 헤더의 무결성 확인 | TCP 세그먼트 전체의 무결성 확인 (전송 계층) |
| 계산 방식 | 헤더 필드들을 16비트 단위로 더한 뒤 1의 보수 | 의사 헤더 + TCP 헤더 + 데이터 → 16비트 단위 덧셈 후 1의 보수 |
| 의사 헤더 사용 | 사용하지 않음 | 사용함 (출발지/목적지 IP, 프로토콜 등 포함) |
| 데이터 검사 여부 | 데이터는 검사하지 않음 | 데이터까지 검사하여 전송 오류 감지 가능 |


## 2. HTTP & HTTPS

### 0) HTTP 개념

> HTML 문서를 전송 받기 위해 만들어진 응용 프로그램 계층 통신 프로토콜
>

- 1996에 1.0 스펙이 발표됐으며 1999년 6월에 1.1이 발표
- 기본적으로 클라이언트의 요청에 대응하는 응답형식으로 작동
- 일반 헤더, 요청 헤더, 응답 헤더, 엔티티 헤더로 분류 된다
- 요청에 주로 사용되는 메서드는 GET, POST이다

### 1) HTTP의 Stateless 특성

(1) Request & Response

: 클라이언트가 서버로 HTTP 요청을 보내면 서버는 요청에 대한 결과를 만들어서 응답

- `클라이언트`는 서버에 요청을 보내고, 응답을 `대기`
- `서버`가 요청에 대한 결과를 만들어서 `응답`

(2) Stateless(무상태 프로토콜)

![image](https://github.com/user-attachments/assets/69d2e24d-4e5d-48bd-9cf6-61ca8af325d0)


- HTTP가 요청을 보낼 때 마다 새로운 응답이 생성
- 클라이언트와 서버가 서로 연결되어 있는 것이 아니기 때문에 각각의 통신이 독립적
- 서버가 클라이언트 상태를 유지하지 않기 때문에 요청을 보낼 때마다 모든 데이터를 매번 보내야함
- `장점`: 서버 확장성이 높음(Scale out)
- `단점` : TCP/IP 연결을 새로 맺어야 하기 때문에 3-way handshake 시간이 소요된다
    - 사이트 요청 시 html, css, javascript, 이미지 등 많은 자원을 다운로드
        - 자원마다 연결을 생성하기 때문에 overhaed가 너무 크다
- **Staful(상태 유지), Stateless 차이**


    | **구분** | **Stateful (상태 유지)** | **Stateless (무상태)** |
    | --- | --- | --- |
    | 상태 정보 유지 | 서버가 클라이언트의 이전 요청 상태를 **기억**함 | 서버는 **각 요청을 독립적**으로 처리함 |
    | 예시 | 한 점원이 고객을 끝까지 응대해야 하는 구조 | 점원이 바뀌어도 응대에 문제 없는 구조 |
    | 서버 확장성 | 확장이 **어려움** (상태 공유 필요) | 확장이 **쉬움** (서버 간 상태 공유 필요 없음) |
    | 유연성 | 중간에 서버(점원)가 바뀌면 문제 발생 가능 | 중간에 서버(점원)가 바뀌어도 문제 없음 |
    | 유지보수 | 상태 동기화 필요 → **복잡** | 요청만 잘 처리하면 되므로 상대적으로 **단순** |
    | 대표 프로토콜 | FTP, Telnet 등 | HTTP, REST API 등 |
    - `Stateful`은 서버가 상태를 기억해야 하므로 관리가 어렵고 확장성이 떨어지며,
    - `Stateless`는 서버가 상태를 기억하지 않아도 되어 유연하고 대규모 확장에 유리

### 2) HTTPS에서 공개키와 대칭키의 차이

| **항목** | **대칭키(Symmetric Key)** | **공개키(Public Key)** |
| --- | --- | --- |
| 키 종류 | 하나의 동일한 키 사용 | 서로 다른 공개키와 개인키 사용 |
| 암호화 방식 | 암호화와 복호화 모두 같은 키로 수행 | 공개키로 암호화, 개인키로 복호화 |
| 연산 속도 | 빠름 | 느림 (복잡한 수학 연산 필요) |
| 보안성 | 키 유출 위험 있음 | 키 교환 없이 안전하게 암호화 가능 |
| 사용 용도 | 대용량 데이터 전송 등 | 인증, 키 분배, 소량 데이터 암호화 등 |
- 대칭키는 하나의 키로 빠르게 암/복호화 하지만 키 유출 위험이 있고,
- 공개키는 키가 다르며 보안은 강하지만 연산 속도가 느리다

### 3) HTTPS Handshake 과정에서는 인증서를 사용하는 이유

- 서버를 안전하게 검증하고, 대칭키를 교환하기 위해 인증서를 사용(암호화 통신)한다
- HTTP Handshake 과정


    | **단계** | **통신 방향** | **설명** |
    | --- | --- | --- |
    | 1 | 클라이언트 → 서버 | TLS 버전, 암호화 방식 등 접속 요청 (ClientHello) |
    | 2 | 서버 → 클라이언트 | CA 인증서(공개키 포함) 전달 (ServerHello) |
    | 3 | 클라이언트 | 인증서 유효성 검증 (CA 인증서 신뢰 여부 확인) |
    | 4 | 클라이언트 → 서버 | 대칭키(또는 키 교환 재료)를 공개키로 암호화해 전송 |
    | 5 | 서버 ↔ 클라이언트 | 복호화 후 대칭키로 암호화된 Finished 메시지 교환 → 무결성 검증 |

### 4) HTTP 응답 코드

| 응답 코드 | 의미 |
| --- | --- |
| GET | 리소스 조회 |
| POST | 요청 데이터 처리, 주로 등록에 사용 |
| PUT | 리소스를 대체, 해당 리소스가 없으면 생성 |
| PATCH | 리소스 부분 변경 |
| DELETE | 리소스 삭제 |
- HTTP API 설계에서 가장 중요한 것은 `리소스를 식별`하는 것이다

| 상태 코드 | 의미 | 설명 |
| --- | --- | --- |
| 200 | OK | 요청이 정상적으로 처리됨 |
| 201 | Created | 요청에 대한 새로운 자원을 생성하는 데 성공함 |
| 301 | Moved Permanently | 요청한 자원이 영구적으로 다른 위치로 이동함 |
| 302 | Found | 요청한 자원이 임시적으로 다른 위치에 존재함 |
| 400 | Bad Request | HTTP 규약에 맞지 않는 잘못된 요청 |
| 403 | Forbidden | 권한 없음 또는 잘못된 파일 실행 접근 시도 |
| 404 | Not Found | 요청한 자원을 찾을 수 없음 |
| 500 | Internal Server Error | 서버 내부 오류로 인해 요청을 처리할 수 없음 |
- 1xx(Informational) : 요청이 수신되어 `처리 중`
- 2xx(Successful) : 요청 정상 처리 - `성공`
- 3xx(`Redirection`) : 요청을 완료하려면 추가 행동이 필요
    - 요청을 완료하기 위해 유저 에이전트의 추가 조치 필요
- 4xx(Client Error) : `클라이언트 오류`, 잘못된 문법등으로 서버가 요청을 수행할 수 없음
- 5xx(Server Error) : `서버 오류`, 정상 요청 처리 하지 못함

- **GET**과 **POST**의 차이점
    - **GET**은 데이터를 읽을 때 사용하고, **POST**는 데이터를 보낼 때 사용한다

| 항목 | GET | POST |
| --- | --- | --- |
| 의미 | 리소스 조회 (데이터를 "가져오는" 용도) | 리소스 `생성` 또는 처리 (데이터를 "보내는" 용도) |
| 데이터 위치 | URL (쿼리 스트링) | HTTP Body |
| 보안 | URL에 노출되어 상대적으로 **덜 안전함** | 본문에 담겨 **상대적으로 안전함** |
| 데이터 길이 | 제한 있음 (URL 길이 제한) | 거의 없음 (대용량 데이터 전송 가능) |
| 캐싱 | O (브라우저 캐시 가능) | X (기본적으로 캐싱되지 않음) |
| 멱등성 | O (같은 요청 반복해도 결과 동일) | X (반복 시 서버 상태 변경 가능성 있음) |
| 사용 예시 | 검색, 조회 | 회원가입, 게시글 작성, 결제 요청 등 |

- **POST**와 **PUT**, **PATCH**의 차이점
    - **POST는 생성,** **PUT**은 전체 수정, **PATCH**는 부분 수정할 때 사용한다

| **항목**          | **POST**                                       | **PUT**                                                           | **PATCH**                                             |
|-------------------|------------------------------------------------|--------------------------------------------------------------------|--------------------------------------------------------|
| **용도**          | 리소스 생성                                    | 리소스 전체 수정(대체) 또는 생성                                  | 리소스의 일부 수정(부분 변경)                         |
| **URI 예시**      | `/members`                                     | `/members/100`                                                    | `/members/100`                                        |
| **요청 본문 예시**| `{ "username": "hello", "age": 20 }`           | `{ "username": "hello", "age": 20 }`                              | `{ "age": 50 }`                                       |
| **동작 방식**     | 서버가 URI 생성 (클라이언트는 위치 모름)       | 클라이언트가 리소스 위치를 알고 URI 지정 → 기존 리소스 완전히 대체 | 지정한 필드만 수정, 나머지는 유지 (리소스 부분 변경) |
| **기존 값 보존**  | N/A                                            | ❌ (명시하지 않은 필드는 삭제됨)                                  | ⭕ (명시한 필드만 수정, 나머지 유지됨)                |
| **ID 필요 여부**  | ❌ (서버가 부여)                                | ⭕ (클라이언트가 지정)                                            | ⭕ (클라이언트가 지정)                                |
| **사용 예**       | 회원 등록, 글 작성 등                          | 회원 정보 전체 수정                                               | 나이 변경, 이름만 수정 등                             |


### 5) SSL과 TLS의 차이점

| **항목** | **SSL (Secure Sockets Layer)** | **TLS (Transport Layer Security)** |
| --- | --- | --- |
| 의미 | 암호화 기반 인터넷 보안 프로토콜 | 전송 계층 보안, 인터넷 상의 커뮤니케이션을 위한 개인정보와 데이터 보안을 용이하게 하기 위해 설계되었으며 널리 채택된 보안 프로토콜 |
| 등장 시기 | 1990년대 초반 | 1999년 (SSL의 후속) |
| 보안 수준 | 낮음 (이미 취약점 발견되어 사용 권장 X) | 높음 (계속 업데이트되고 있음) |
| 최신 버전 | SSL 3.0 (더 이상 사용되지 않음) | TLS 1.3 (2024년 기준 최신 표준) |
| 관계 | TLS는 SSL을 개선한 프로토콜 | SSL을 대체한 표준 프로토콜 |
| 사용 여부 | 폐기 | 웹 브라우징, 이메일, 인스턴트 메시징 등 다양한 애플리케이션에서 사용 |
- SSL 인증서와 TLS 인증서를 비교하면 데이터 흐름을 암호화하는 기능은 동일 하지만,
  SSL이 개선되고 더 안전한 버전이 TLS이다
- **TLS**의 동작 원리

![image](https://github.com/user-attachments/assets/aad8c722-4d3f-4ce2-bf4b-69033552b393)


| **단계** | **메시지** | **설명** |
| --- | --- | --- |
| ① | **ClientHello** | 클라이언트가 서버에 연결 요청. 지원하는 TLS 버전, 암호화 방식, 세션 ID 전달 |
| ② | **ServerHello** | 서버가 응답. 선택된 TLS 버전, 암호화 방식, 세션 ID 전달 |
| ③ | **서버 인증서 전송** | 서버는 SSL 인증서(공개 키 포함)를 전송하고, 클라이언트는 이를 검증 |
| ④ | **ServerHelloDone** | 서버가 인증 및 키 교환 메시지 전송을 완료했음을 알림 |
| ⑤ | **ClientKeyExchange** | 클라이언트가 pre-master secret 생성 후 서버의 공개키로 암호화하여 전송 |
| ⑥ | **ChangeCipherSpec** | 이후 메시지부터는 암호화 방식 적용하겠다는 신호 (양쪽 모두 보냄) |
| ⑦ | **Finished** | 양쪽에서 Finished 메시지를 주고받아 핸드셰이크 완료, 세션 무결성 확인 |

### 6) DNS(Domain Name System)

- DNS란?
    - 사용자가 기억하기 쉬운 도메인 이름(www.example.com)을 컴퓨터가 이해할 수 있는 IP 주소(192.0.2.1)로 변환해주는 시스템
- 몇 계층 프로토콜인지, TCP와 UDP 중 어떤 것을 사용하는지
    - Application 계층 프로토콜, 기본 전송은 UDP 포트를 사용하지만 데이터가 크거나 영역 전송 시 사용할 때는 TCP를 사용한다

  | **항목** | **설명** |
  | --- | --- |
  | **역할** | 도메인 이름 ↔ IP 주소 변환 |
  | **구조** | 트리(Tree) 구조의 **계층적 네이밍 시스템** |
  | **데이터베이스 유형** | **분산형 데이터베이스 시스템** (각 네임서버가 분산하여 관리) |
  | **도메인 이름** | 고유한 식별자 (예: google.com) |
  | **프로토콜 계층** | **애플리케이션 계층 프로토콜** (TCP/IP 7계층 중 7계층) |
  | **사용 프로토콜** | 일반적으로 **UDP 53번 포트** 사용전송량이 크거나 중요 요청 시 **TCP 53번 포트** 사용 |
  | **대표 포트 번호** | 53번 포트 |

### **DNS 동작 예시 흐름**

![image](https://github.com/user-attachments/assets/90d4d131-21cc-4b47-b5a4-2116b7359277)

1. 사용자가 www.google.com 입력
2. **로컬 DNS 캐시** 확인 → 없으면
3. **ISP의 DNS 서버**에 요청
4. 루트 → TLD → 권한 있는 DNS 서버 순으로 요청 전파
5. 응답 받은 IP 주소를 로컬에 **캐싱 후 사용자에게 전달**

## 3. 쿠키 & 세션

### 1) 쿠키와 세션

- **쿠키**

> 클라이언트(브라우저)에 저장되는 작은 데이터 조각
>

- **특징**
    - 쿠키 정보는 **모든 HTTP 요청에 자동 포함**되어 서버에 전송됨
    - 브라우저 종료 후에도 살아 있는 **영속 쿠키** 설정 가능 (`Expires`, `Max-Age` 이용)
    - 보안에 민감한 데이터는 저장 X (쿠키는 클라이언트에 저장됨 → 노출 가능성)
- **문제점**
    - 네트워크 트래픽 증가 (모든 요청에 포함되기 때문)
    - 브라우저에 저장되므로 변조·탈취 가능성 존재 (→ `Secure`, `HttpOnly`, `SameSite` 설정으로 보완)

- **세션**

> 서버 측에서 사용자 정보를 저장하는 방식
>

- **특징**
    - 서버는 클라이언트와의 연결마다 고유한 세션 ID를 발급
    - 이 세션 ID는 클라이언트의 쿠키에 저장되어 **요청마다 세션 ID만 서버로 전송**
    - 서버는 이 ID를 기준으로 **사용자 상태 정보를 관리**
    - 중요한 정보는 클라이언트가 아닌 **서버에 저장** (보안성 ↑)
    - 클라이언트는 세션 ID만 갖고 있고, 실제 정보는 서버에 보관
    - 브라우저 종료 시 세션 종료됨 (기본 동작)

- 쿠키와 세션 **공통점**
    - HTTP의 stateless 단점을 극복하기 위함
    - 사용자의 로그인 정보나 인증 상태 유지에 사용
- **차이점**

    |  | Cookie | Session |
    | --- | --- | --- |
    | 보안 | 취약 | 쿠키보다 나음 |
    | 속도 | 빠름 | 느림 |
    | 종료 | 브라우저 종료 시 남아있음 | 만료 시간에 상관없이 브라우저 종료 시 삭제 |

    - **쿠키와 세션의 단점보완**
        - **Token 기반의 인증 방식 :** 보호할 데이터를 토큰으로 치환하여 원본 데이터 대신 토큰 사용
            - 중간에 공격자로부터 토큰이 탈취당하더라도 데이터에 대한 정보를 알 수 없으므로, 보안성이 높음
            - 대표적으로는 **`OAuth`**와 **`JWT`**이 있다

### 2) 세션 방식의 로그인 과정에 대해 설명해주세요

: 서버가 사용자 정보를 저장하고, 클라이언트는 세션 ID만 쿠키로 주고 받으며 로그인 상태를 유지하는 방법

![image](https://github.com/user-attachments/assets/053bdad9-281a-441d-8bf2-1be4ba5cd58b)

| **단계** | **설명** |
| --- | --- |
| **1. 로그인 요청** | 사용자가 아이디와 비밀번호를 입력하여 서버로 로그인 요청을 보냄 |
| **2. 계정 정보 검증** | 서버는 DB에 저장된 사용자 정보를 조회하여 입력한 로그인 정보와 일치하는지 확인 |
| **3. 세션 생성** | 로그인 정보가 유효하다면, 서버는 사용자 고유 식별자(ID)를 기반으로 **세션 객체를 생성**하여 세션 저장소(메모리 또는 DB 등)에 저장 |
| **4. 세션 ID 발급** | 서버는 세션 객체에 대한 키인 **세션 ID**를 생성하고, 이 값을 HTTP 응답의 쿠키(Set-Cookie)에 담아 클라이언트에게 전달 |
| **5. 쿠키 저장** | 클라이언트(브라우저)는 받은 세션 ID를 **쿠키에 저장** |
| **6. 상태 유지** | 이후 클라이언트가 서버에 요청을 보낼 때, 쿠키에 포함된 세션 ID도 함께 전송되고, 서버는 이를 통해 **사용자의 로그인 상태를 확인** |

### 3) 규모가 커져 서버가 여러 개가 될 경우 세션을 관리하는 방법

- 웹 서버가 여러 대일 경우, 서버간 세션 정보를 공유 하지 않는다면?
    - 사용자가 서버를 이동할 때마다 로그인 정보가 사라지는 문제가 발생
    - 해결법 : 모든 서버가 동일한 세션 저장소(Session Store)을 바라보도록 구성
        - 대표적인 세션 저장소 : Redis, Memcached
        - 고가용성을 위해 Replication or Failover 구성이 중요

### 4) Stateless와 Connectionless에 대한 차이점

| **항목** | **Stateless** | **Connectionless** |
| --- | --- | --- |
| 정의 | 요청 간 **상태 정보를 저장하지 않음** | **연결 없이** 요청-응답을 처리하는 방식 |
| 예시 | HTTP | UDP |
| 특징 | 이전 요청의 상태나 컨텍스트를 서버가 기억하지 않음 | 데이터 전송 시 연결 설정 과정이 없음 |
| 주요 적용 기술 | HTTP, REST API | DNS, SNMP, TFTP 등 |
- **Stateless**: 서버가 클라이언트의 이전 상태를 기억하지 않음
    - 매 요청은 독립적이며 필요한 모든 정보를 포함해야 함
- **Connectionless**: 통신을 위한 **연결 설정 없이** 데이터를 바로 전송함
    - 수신 여부 확인은 하지 않음 (UDP)

### 5) HTTP가 Stateless 구조를 채택하고 있는 이유

> 서버의 단순성과 확장성을 최대화 하기 위해서이다.
>

- Stateless 구조를 사용하면 서버가 사용자의 상태 정보를 저장할 필요가 없어져, 서버 설계가 단순해지고, 서버 간에 요청을 자유롭게 분산 시킬 수 있다.

| 장점 | 설명 |
| --- | --- |
| 확장성 (Scalability) | 서버가 클라이언트 상태를 저장하지 않으므로, 서버 수를 늘려도 사용자 상태 공유 없이 확장 가능 |
| 단순성 (Simple) | 요청과 응답이 독립적이어서 구현이 간단하고, 서버 자원 소모도 줄어듦 |
| 유연성 (Flexibility) | 요청을 어느 서버가 받아도 되므로 로드 밸런싱이 쉬움 |
| 캐싱 효율성 | 동일 요청은 상태 영향 없이 응답 가능해 캐시 적용이 수월 |

## 4.  [www.github.com을](http://www.github.xn--com-of0o/) 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요**.

![image](https://github.com/user-attachments/assets/6adbda10-ceca-4e1d-9971-d4bb0f72b275)


1. **TCP/IP 연결 및 HTTP 세션 생성**
    - 브라우저(클라이언트)가 웹 서버에 접속을 시도합니다. 이때 TCP 3-way handshake 과정을 통해 물리적 연결을 맺고, HTTP 세션을 시작
2. **HTML 문서 요청 (GET 요청)**
    - 연결이 되면 클라이언트는 GET /과 같은 형식으로 HTML 문서를 요청합니다. 이 요청은 HTTP 프로토콜을 통해 전달
3. **서버 응답 및 연결 종료**
    - 서버는 요청된 HTML 문서를 찾아 클라이언트에 전송하고, 전송이 완료되면 TCP 연결을 종료하고, 이때 받은 HTML은 브라우저가 렌더링

## 💬 CS 기술 면접 준비

### Q. Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법아닌가요?

A. Stateless 방법이 이상적이긴 하지만, Stateless을 유지하기 위해서는 요청마다 필요한 정보를 모두 담아서 통신해야 되기 때문에 부하와 비용이 더 클 수 있다. 그렇기 때문에 토큰 기반 인증(ex JWT) `클라이언트`가 로그인 정보를 담은 `토큰`을 발급 → 요청마다 HTTP 헤더에 `토큰`을 담아 보냄 → `서버`는 `토큰 검사` → `Stateless 유지`(어떤 서버든 동일하게 요청 가능)

### Q. HTTP Method의 멱등성에 대해 설명해 주세요

A. 멱등성이란 동일한 요청을 여러 번 보내더라도 서버의 상태가 변하지 않는 속성을 의미합니다. 예를 들어 멱등한 메소드는 : GET, PUT, DELETE이고, 멱등 하지 않는 메소드는 POST, PATCH입니다. POST와 PATCH는 요청을 반복할 때마다 서버 상태가 달라질 수 있기 때문입니다.

### Q. Connectionless의 논리대로이면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?

A. Connectionless 모델은 각 요청마다 별도 연결을 생성하지 않기 때문에 초기 연결 설정에 드는 리소스와 시간을 줄일 수 있는 장점이 있습니다.

하지만 연결을 유지하지 않기 때문에 데이터 손실, 연결 지연 같은 신뢰성과 성능 문제가 발생할 수 있는데요,

이러한 문제는 **지속 연결(Keep-Alive)**, **멀티플렉싱**, **헤더 압축**, **서버 푸시**, 그리고 **QUIC 프로토콜(HTTP/3)** 같은 기술로 보완할 수 있습니다.
