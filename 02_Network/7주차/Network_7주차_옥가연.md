# IP + HTTP & HTTPS + TLS/SSL + 쿠키 & 세션

## IP

### IP 주소의 개념과 기능

- 네트워크 상에서 장치들을 식별하고 통신을 가능하게 하는 주소 체계
- 네트워크 상에서 장치(호스트)를 고유하게 식별
- IP 주소는 네트워크 계층에서 사용되며 인터넷 상의 모든 장치는 고유한 IP 주소를 가져야 함

### IPv4과 IPv6의 차이점

1. IPv4
    - 32비트 주소 체계를 사용 (2^32개의 주소, 41억 9천만 주소)
    - 8비트 단위로 점을 찍어 4개로 구분(8비트이 단위를 옥텟이라고도 함)
    - 이 주소체계만으로 부족하기 때문에 NAT, 서브네팅과 같은 부수적인 기술이 필요

![img.png](https://velog.velcdn.com/images/leesfact/post/5f965c80-65f0-4cc9-ad8f-9a0187ee01cb/image.png)

2. IPv6 :
    - 128비트, 2^128개의 주소 표현(많은 주소 처리 가능하며 NAT, 서브네팅이 필요하지 않음)
    - 16비트 8개로 구분, 16비트는 16진수로 변환되어 콜론(:)으로 구분, 앞의 연속된 0은 생략 가능
    - 앞 64비트 - 네트워크 주소, 뒤 64비트 - 인터페이스 주소

![img_1.png](https://velog.velcdn.com/images/leesfact/post/066819ef-bb3d-4ab4-bb3b-ad62f56dd575/image.png)
![img_2.png](https://velog.velcdn.com/images/leesfact/post/f4fb4318-68c5-43fd-9c6c-97f55839a748/image.png)

| 특징      | 	IPv4                        | 	IPv6                                                     |
|---------|------------------------------|-----------------------------------------------------------|
| 주소 길이   | 	32비트                        | 	128비트                                                    |
| 주소 형식   | 	10진수 점 표기법 (예: 192.168.0.1) | 	16진수 콜론 표기법 (예: 2001:0db8:85a3:0000:0000:8a2e:0370:7334) |
| 주소 개수   | 	약 43억 개                     | 	사실상 무제한                                                  |
| 구성 복잡성  | 	비교적 단순                      | 	더 복잡하지만 자동 구성 지원                                         |
| 브로드캐스트  | 	지원                          | 	지원하지 않음 (멀티캐스트 및 애니캐스트 사용)                               |
| 보안      | 	IPSec는 선택 사항                | 	IPSec는 필수                                                |
| 헤더 크기   | 	20바이트                       | 	40바이트                                                    |
| 프래그멘테이션 | 	송신자와 라우터가 처리                | 	송신자가 처리                                                  |

![img_3.png](https://velog.velcdn.com/images/leesfact/post/d0447866-7891-4d9a-8624-e11b7f6694fd/image.png)

### MAC 주소

- 네트워크 인터페이스 카드(NIC)에 할당된 고유 식별자

![img_4.png](https://velog.velcdn.com/images/leesfact/post/c7dd7627-efcf-4cda-a002-9e46830f07fd/image.png)

- MAC 주소는 데이터 링크 계층에서 사용되며 네트워크 내의 물리적 장치를 식별
- 48비트 주소 체계를 사용하며 12자리의 16진수로 표현
    - 예: 00:1A:2B:3C:4D:5E
- MAC 주소는 네트워크 카드 제조업체에 의해 할당되며 일반적으로 변경되지 않음
- 네트워크 내에서 데이터 패킷을 올바른 장치로 전달하는 데 사용

<hr />

## HTTP & HTTPS

### HTTP

- 웹에서 클라이언트와 서버 간에 데이터를 주고 받기 위해 사용하는 프로토콜
- HTTP는 요청/응답(request/response) 모델을 따르며 주로 웹 브라우저(클라이언트)가 웹 서버에 리소스를 요청하고 서버가 해당 요청에 응답하는 방식으로 작동함
- HTTP는 상태를 유지하지 않는(stateless) 프로토콜로 각 요청은 독립적으로 처리

### TLS(Transport Layer Security)에서의 암호화

1. 대칭 키 암호화

- 사용 목적 : 데이터를 빠르고 효율적으로 암호화 및 복호화하기 위해 사용
- 동작 방식 : 클라이언트와 서버는 TLS 핸드세이크 과정에서 대칭 키를 공유
    - 이 대칭 키는 이후의 데이터 전송을 암호화하는 데 사용
- 특징 : 같은 키로 암호화와 복호화를 수행하며 매우 빠른 속도로 데이터를 처리할 수 있음

2. 비대칭 키 암호화

- 사용 목적 : 초기 핸드세이크 과정에서 대칭 키를 안전하게 교환하기 위해 사용
- 동장 방식 : 클라이언트와 서버는 공개 키(공개된 키)와 개인 키(비공개 키) 쌍을 사용하여 데이터를 암호화하고 복호화함
    - 예를들어, 클라이언트는 서버의 공개 키를 사용하여 대칭 키를 암호화하고 서버는 자신의 개인 키를 사용하여 복호화함
- 특징 : 서로 다른 키로 암호화와 복호화를 수행하며 보안성이 높지만 대칭 키 암호화보다 속도가 느림

```declarative
공개 키(Public Key) : 누구나 사용할 수 있는 공개 자물쇠

- 많은 사람들이 이 자물쇠를 사용해 상자를 잠글 수 있지만, 이 자물쇠로 잠긴 상자는 특정한 키를 사용해야만 열 수 있음
```

```
개인 키(Private Key) : 오직 특정한 사람만 가지고 있는 비밀 키

- 이 키를 사용해야만 공개 자물쇠로 잠긴 상자를 열 수 있음
```

3. TLS 핸드세이크 과정에서의 암호화

- 클라이언트와 서버는 초기 연결 설정을 위해 비대칭 암호화를 사용하여 대칭 키를 안전하게 교환함
- 핸드세이크가 완료되면 이후의 데이터 전송은 대칭 키 암호화를 사용하여 수행

```declarative
클라이언트 헬로 (Client Hello)
|
| - 클라이언트가 서버에 연결을 요청하며, 지원하는 TLS 버전, 암호화 스위트 목록, 랜덤 값(클라이언트 랜덤)을 보냅니다.
v
서버 헬로 (Server Hello)
|
| - 서버가 클라이언트의 요청에 응답하며, 선택한 TLS 버전, 암호화 스위트, 랜덤 값(서버 랜덤)을 보냅니다.
v
서버 인증 및 키 교환 (Server Authentication & Key Exchange)
|
| - 서버는 자신의 디지털 인증서를 클라이언트에 보냅니다. 인증서에는 서버의 공개 키가 포함되어 있습니다.
| - 필요한 경우 서버는 키 교환에 필요한 추가 데이터를 보냅니다.
v
서버 헬로 완료 (Server Hello Done)
|
| - 서버가 클라이언트에게 헬로 메시지 전송이 완료되었음을 알립니다.
v
클라이언트 키 교환 (Client Key Exchange)
|
| - 클라이언트는 서버의 공개 키를 사용하여 프리마스터 시크릿(Pre-Master Secret)을 암호화한 후 서버에 보냅니다.
v
변경 암호 사양 (Change Cipher Spec)
|
| - 클라이언트가 Change Cipher Spec 메시지를 보내고, 이후의 통신을 대칭 키로 암호화할 준비가 되었음을 알립니다.
v
클라이언트 완료 (Client Finished)
|
| - 클라이언트가 Finished 메시지를 보내 핸드셰이크가 무결하게 완료되었음을 확인합니다.
v
서버 변경 암호 사양 (Server Change Cipher Spec)
|
| - 서버가 Change Cipher Spec 메시지를 보내고, 이후의 통신을 대칭 키로 암호화할 준비가 되었음을 알립니다.
v
서버 완료 (Server Finished)
|
| - 서버가 Finished 메시지를 보내 핸드셰이크가 무결하게 완료되었음을 확인합니다.
```

### TLS 핸드세이크 (TLS 1.3 기준)

![img_5.png](https://velog.velcdn.com/images/leesfact/post/3c100129-4cc3-407a-baeb-da7d7e845561/image.png)

1. Client Hello
    - 클라이언트가 서버에 메시지 전송
        - 클라이언트는 핸드세이크를 시작하면서 Client Hello 메시지를 서버에 전송
        - 이 메시지에는 다음 정보가 포함됨
            - 지원하는 TLS 버전(TLS 1.3)
            - 지원하는 암호 스위트 목록
            - 클라이언트의 랜덤 값(nonce)
            - 세션 복원 및 O-RTT 데이터를 위한 옵션
            - 공개 키 교환을 위한 키 공유 값(임시 DH 매개변수)
2. Server Hello
    - 서버가 클라이언트에 메시지 전송
        - 서버는 클라이언트의 Client Hello 메시지를 수신하고 이에 대한 응답으로 Server Hello 메시지를 클라이언트에 전송
        - 이 메시지에는 다음 정보가 포함됨
            - 선택한 TLS 버전 (TLS 1.3)
            - 선택한 암호 스위트
            - 서버의 랜덤 값(nonce)
            - 공개 키 교환을 위한 키 공유 값(임시 DH 매개변수)
3. Server’s Encrypted Extensions
    - 서버가 추가 설정 정보 전송
        - 서버는 선택적으로 Encrypted Extensions 메시지를 전송하여 추가 확장 정보를 제공
        - 이 메시지는 이미 설정된 세션 키로 암호화되어 있음
4. Server Certificate (Optional)
    - 서버 인증서 전송
        - 서버는 클라이언트에게 자신의 인증서를 전송
            - 이 인증서는 서버의 공개 키를 포함하고 있으며 클라이언트는 이를 통해 서버의 신원을 확인
        - 이 단계는 서버 인증서가 필요한 경우에만 수행
5. Certificate Verify (Optional)
    - 서버가 인증서 검증 메시지 전송
        - 서버는 Certificate Verify 메시지를 전송하여 인증서의 유효성을 증명
            - 이 메시지에는 서버의 개인 키로 서명된 값이 포함
        - 클라이언트는 이 서명을 확인하여 서버 인증서의 진위를 검증
6. Server Finished
    - 서버가 핸드세이크 완료 알림
        - 서버는 Finished 메시지를 전송하여 자신의 핸드세이크 단계가 완료되었음을 클라이언트에게 알림
        - 이 메시지는 세션 키로 암호화된 해시 값을 포함하여 핸드세이크 과정의 무결성을 검증
7. Client Finished
    - 클라이언트가 핸드세이크 완료 알림
        - 클라이언트는 Finished 메시지를 전송하여 자신의 핸드세이크 단계가 완료되었음을 서버에게 알림
        - 이 메시지도 세션 키로 암호화된 해시 값을 포함하여 핸드세이크 과정의 무결성을 검증
8. 데이터 전송 시작
    - 암호화된 데이터 전송
        - 핸드세이크 과정이 완료되면 클라이언트와 서버는 상호간에 암호화된 데이터를 안전하게 주고받을 수 있음

<hr />

## HTTP 응답 코드

### GET과 POST의 차이점

#### GET Method

- 서버에서 정보를 가져오는데 사용
- URL의 쿼리 스트링을 통해 데이터를 전달
    - 예: http://example.com/page?name=John&age=30
- GET 요청은 브라우저에서 캐싱될 수 있으며 북마크에 저장할 수 있음
- URL 길이에 제한이 있어 전달할 수 있는 데이터의 크기가 제한됨(2000자 미만)
- GET 요청은 서버의 상태를 변경하지 않으므로 안전

![img_6.png](https://velog.velcdn.com/images/leesfact/post/e7286095-3851-4c9a-90ed-7b7b391bd573/image.png)

`GET 요청 예시`

![img_7.png](https://velog.velcdn.com/images/leesfact/post/52a43faa-8ac7-4a77-bb55-ab1d0797d4c7/image.png)

#### POST Method

- 서버에 데이터를 제출하거나 서버의 상태를 변경하는 데 사용
- 요청 본문(body)을 통해 데이터를 전달
- URL에 나타나지 않으므로 상대적으로 더 안전
- POST 요청은 브라우저에서 캐싱되지 않음
- 본문을 통해 데이터를 전달하므로 GET보다 훨씬 큰 데이터를 보낼 수 있음
- POST 요청은 서버의 상태를 변경할 수 있으므로 안전하지 않음

![img_8.png](https://velog.velcdn.com/images/leesfact/post/76e57f9b-dbcf-4910-b390-78db9c7613c6/image.png)

### PUT과 PATCH의 차이

#### PUT Method

- 전체 업데이트 : PUT 메서드는 요청한 URI에 대해 해당 리소스를 전체적으로 업데이트 함
    - 기존 리소스를 완전히 대체하며 리소스가 존재하지 않는 경우 새로 생성하기도 함
- 정확한 상태 : 클라이언트는 서버에 전달하는 데이터가 리소스의 정확한 상태를 반영해야 함
    - 이는 리소스의 모든 필드를 포함해야 하며 생략된 필드는 기본값이나 null로 처리될 수 있음
- 예 : {"a" : 1, "b" : 2}가 있을 때 b를 3으로 바꾼다면, put method의 경우 {"a" : 1, "b" : 3}으로 전체 데이터 전부를 보내야 함

#### PATCH Method

- 부분 업데이트 : PATCH 메서드는 요청한 URI에 대해 해당 리소스를 부분적으로 업데이트 함
    - 이는 전체 리소스를 대체하지 않고, 일부 필드만 수정하거나 추가함
- 변경사항만 전달 : 클라이언트는 서버에 전달하는 데이터가 리소스의 전체 상태가 아닌 변경할 부분만 포함
- 예 : {"a" : 1, "b" : 2}가 있을 때 b를 3으로 바꾼다면, patch method의 경우 {"b" : 3}으로 부분 데이터를 보내야 함

<hr />

## SSL과 TLS의 차이점

### SSL

- 인터넷 상에서 데이터를 안전하게 전소하기 위해 넷스케이프(Netscape)에 의해 개발된 보안 프로토콜
- SSL은 클라이언트(예 : 웹브라우저)와 서버 간에 전송되는 데이터를 암호화하여 제3자가 데이터를 도청하거나 조작하지 못하도록 보호함

`기능`

- 암호화 : 데이터를 암호화하여 전송 도중의 도청을 방지
- 무결성 : 데이터의 무결성을 보장하여 전송 도중 데이터가 변조되지 않도록 함
- 인증 : 서버(선택적 클라이언트)를 인증하여 통신이 신뢰할 수 있는 대상과 이루어지고 있음을 보장

### TLS

- SSL의 후속 프로토콜로 SSL의 문제점을 보완하고 보안을 더욱 강화한 표준 프로토콜
- TLS는 인터넷 엔지니어링 테스크 포스(IETF)에 의해 표준화되었으며 SSL과 유사한 보안 기능을 제공

`기능`

- 암호화 : 클라이언트와 서버 간의 모든 데이터를 암호화하여 보호
- 무결성 : 데이터의 변조를 방지하는 메시지 인증 코드를 사용하여 데이터 무결성을 보장
- 인증 : 서버 인증을 필수적으로 하고 클라이언트 인증을 선택적으로 함

<hr />

## 도메인 네임을 입력했을 때 생기는 과정 그리고 DNS

![img_9.png](https://velog.velcdn.com/images/leesfact/post/1679fc84-c71a-47d1-ae82-d7c6171c136a/image.png)

- 리다이렉트, 캐싱, DNS, IP 라우팅 & ARP, TCP 연결 구축을 거쳐 요청, 응답이 일어나는 TTFB(Time to First Byte)가 시작되고 이 후 컨텐츠를 다운받아 브라우저 렌더링 과정을 거쳐
  네이버라는 화면이 나타나게 됨

### 리다이렉트

- 웹 서버가 클라이언트(웹 브라우저)에게 요청한 URL 대신 다른 URL로 이동하도록 지시하는 방법
    - HTTP 응답 상태 코드와 함께 사용되며 사용자가 원래 요청한 리소스 대신 다른 리소스로 안내

### 캐싱

- 캐싱은 요청된 값의 결과를 저장하고 동일한 요청이 다시 들어올 때 저장된 값을 반환하는 기술
    - 이를 통해 성능을 향상시키고 서버 부하를 줄일 수 있음
- 캐싱은 `브라우저 캐시`와 `공유 캐시`로 나눌 수 있음

![img_10.png](https://velog.velcdn.com/images/leesfact/post/4d7f9824-d905-4dc1-8842-5d4b590a091a/image.png)

1. 브라우저 캐시(private cache)

- 사용자의 웹 브라우저가 요청한 리소스(예: HTML, CSS, JavaScript, 이미지 등)를 저장
    - 동일한 리소스를 재요청할 때, 서버에 다시 요청하지 않고 로컬에 저장된 캐시를 사용

2. 공유 캐시(Proxy cache)

- 프록시 서버나 CDN(Content Delivery Network) 등 중간 서버가 요청된 리소스를 저장
    - 여러 사용자가 동일한 리소스를 요청할 때, 원 서버에 요청을 보내지 않고 프록시 서버에서 직접 응답

![img_11.png](https://velog.velcdn.com/images/leesfact/post/11414bdb-2072-4481-95e6-a73ec217e2ff/image.png)

### DNS(Domain Name System)

- 계층적인 도메인 구조와 분산된 DB를 이용한 시스템으로 FQDN(Fully Qualified Domain Name)을 인터넷 프로토콜인 IP로 바꿔주는 시스템
- DNS는 도메인 이름을 IP 주소로 변환하는 네임서버(Name Server)와 클라리언트의 DNS 쿼리를 네임서버로 전달하고 응답을 클라이언트에게 전달하는 리졸버(Resolver)로 구성되어 있음

```declarative
예를들어, www.github.com에 DNS 쿼리가 오면 오른쪽부터 역순으로
[Root DNS] → [.com DNS] → [.github DNS] → [.www DNS] 과정을 거쳐 완벽한 주소를 찾아 IP 주소를 매핑
```

![img_12.png](https://velog.velcdn.com/images/leesfact/post/8e05c6a1-6286-47dc-84bf-9b4251c98aa0/image.png)

#### DNS 캐싱

- 미리 해당 도메인 이름을 요청했다면 로컬 PC에 자동적으로 저장

### IP 라우팅 & ARP(Address Resolution Protocol)

- 네트워크 상 패킷이 출발지에서 목적지까지 가장 효율적인 경로를 통해 전달되도록 하는 과정
- ARP는 IP 네트워크에서 IP 주소를 물리적 주소(MAC 주소)로 변환하는 프로토콜
    - 로컬 네트워크 내의 통신에서 IP 주소를 사용하여 데이터를 전송할 때, 실제로는 물리적 주소(MAC 주소)를 사용하여 통신

### TCP 연결 구축

- TCP 3-WAY Handshake은 클라이언트와 서버 간에 TCP 연결을 설정하기 위해 사용되는 세 단계의 프로세스
- 이 과정은 신뢰성 있는 데이터 전송을 보장하기 위한 첫 단계

### 컨텐츠 다운로드

- 사용자가 요청한 컨텐츠를 서버로부터 다운받음

### 브라우저 렌더링

- 받은 데이터를 바탕으로 브라우저 엔진이 브라우저 렌더링 과정을 거쳐 화면을 만듦

<hr />

## 쿠키 & 세션

### 쿠키와 세션의 차이점

#### 쿠키(Cookie)

- 웹사이트가 사용자의 웹 브라우저에 저장하는 작은 데이터 파일로 사용자의 세션 정보를 유지하고 웹사이트 간의 상호작용을 추적하는 데 사용
    - 사용자의 경험을 맞춤화하고 웹사이트의 기능을 개선하며 사용자 활동을 분석하는 데 중요한 역할을 함

`특징`

1. 작은 데이터 파일 : 쿠키는 일반적으로 4KB 이하의 작은 데이터 파일로 텍스트 형식으로 저장
2. 키 - 값 쌍 : 키 - 값 쌍의 형태로 저장
    - 예를들어, username=JohnDoe와 같은 형태
3. 도메인 범위 : 쿠키는 특정 도메인과 관련이 있으며 해당 도메인에서만 접근할 수 있음
4. 만료 시간 : 쿠키는 만료 시간을 설정할 수 있음
    - 만료 시간이 지나면 쿠키는 자동으로 삭제됨

`HTTP 헤더를 통해 쿠키 정보를 주고 받음`

![img_13.png](https://velog.velcdn.com/images/leesfact/post/08f3e52b-5a7f-4624-bca3-3aad3d505b26/image.png)

<br />

#### 세션스토리지(Session Storage)

- 클라이언트 측 웹 스토리지 매커니즘 중 하나로 웹 페이지가 로드될 때마다 생성되고 페이지가 닫히면 자동으로 삭제되는 데이터를 저장하는 공간

`특징`

1. 세션 범위 : 세션스토리지는 웹 브라우저 탭 또는 창의 생명 주기와 동일한 범위를 가짐
    - 즉, 사용자가 웹 브라우저 탭이나 창을 닫으면 세션스토리지에 저장된 데이터는 자동으로 삭제
        - 따라서, 다른 탭이나 창에서 동일한 데이터를 공유하지 않음
2. 키 값 형태로 저장 : 키와 값은 모두 문자열로 저장되며 자바스크립트를 이용해서 데이터를 저장하고 읽을 수 있음
3. 데이터 용량 : 일반적으로 세션스토리지는 도메인당 약 5MB의 데이터를 저장할 수 있음
4. 보안 : 클라이언트 측에 저장되기 때문에 민감한 데이터를 저장하는 데는 적합하지 않음
    - 동일한 출처 정책(Same Origin Policy)에 따라 같은 도메인에서만 접근 가능

<br />

| 특징      | 	세션스토리지           | 	쿠키               |
|---------|-------------------|-------------------|
| 저장 위치   | 	클라이언트            | 	클라이언트            |
| 저장 용량   | 	최대 5MB           | 	약 4KB            |
| 데이터 지속성 | 	브라우저를 닫으면 삭제     | 	설정에 따름           |
| 접근성     | 	클라이언트에서만 접근 가능   | 	클라이언트 및 서버       |
| 접근 범위   | 	탭                | 	오리진              |
| 만료 시점   | 	브라우저 세션 종료 시     | 	설정된 만료 시점        |
| 용도      | 	일시적인 데이터 저장      | 	세션 관리, 사용자 추적    |
| 보안      | 	비교적 안전 (XSS에 취약) | 	취약 (XSS, CSRF 등) |

<br />

### 세션 기반 인증 방식

- HTTP의 주요 특징 중 하나는 Stateless(무상태)하다는 것
- 이는 각 HTTP 요청이 독립적이며 요청 간에 상태 정보가 유지되지 않는다는 것을 의미
    - 예를들어, 사용자가 로그인 요청을 보내고 나면 서버는 다음 요청이 동일한 사용자로부터 왔는지 알지 못함, 요청이 끝나면 사용자 정보나 상태는 서버에 남지 않기 때문에 매번 새로운 요청처럼 처리됨
- 이러한 무상태 특성 때문에 웹 애플리케이션은 사용자의 로그인 상태를 유지하기 위해 추가적인 방법이 필요한데, 이를 해결하기 위해 세션 기반 인증 방식이 사용됨

```declarative
1. 로그인 요청(Login Request)
- 클라이언트 : 사용자가 로그인 페이지에서 사용자명과 비밀번호를 입력하고
이를 포함한 POST 요청을 서버로 전송

POST /login
username = david
password = davidh

2. 서버 인증(Server Authentication)
- 서버 : 사용자가 보낸 자격 증명을 확인
데이터베이스를 참조하여 사용자명과 비밀번호가 일치하는지 검증
- 인증 성공 시 :
1. 세션 ID를 생성
2. 생성된 세션 ID를 쿠키에 담아 클라이언트로 반환
3. 세션 ID와 관련된 세션 데이터를 DB에 저장

3. 세션 ID 설정(Set Session ID)
- 서버 : 생성된 세션 ID를 클라이언트로 전송
이때, HTTP 응답 헤더에 Set-Cookie를 사용하여 세션 ID를
클라이언트의 쿠키에 저장하도록 지시

Set-Cookie: SESSIONID = 86C530ACAF44D1B05588019ECBC0C737C

4. 클라이언트의 세션 ID 저장(Cient Stores Session ID)
- 클라이언트 : 클라이언트 브라우저는 서버로부터 받은 세션 ID를 쿠키에 저장

5. 인증된 요청 처리(Handling Authenticated Requests)
- 클라이언트 : 사용자가 인증된 상태에서 서버에 요청을 보낼 때마다, 브라우저는 자동으로 쿠키에 저장된 세션 ID를 포함하여 서버로 전송

Cookie: SESSIONID = 86C530ACAF44D1B05588019ECBC0C737C

6. 세션 검증(Session Validation)
- 서버 : 요청에 포함된 세션 ID를 확인
1. 세션 ID가 데이터베이스에 저장된 세션 데이터와 일치하는지 확인
2. 세션이 유효한지(예: 만료되지 않았는지) 검증
- 유효한 세션일 경우 : 요청을 처리하고, 해당 사용자의 데이터를 반환

7. 컨텐츠 제공(Providing Content)
- 서버 : 세션 검증이 완료되면, 요청된 컨텐츠를 클라이언트로 전송
```
