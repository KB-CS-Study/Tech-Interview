# 키(Key) + RDB vs NoSQL + 스키마 + 인덱스 + 정규화

## 수퍼키/후보키/기본키/외래키 차이

![](https://velog.velcdn.com/images/kon6443/post/37fe31d9-5043-462e-ab4a-fcee28bfca15/image.png)

### Super key (수퍼키)

- 유일성 O, 최소성 X
- 유일성의 특성을 만족하는 속성들의 집합. 중복된 값이 존재하지 않는다. 서로 구분만 가능하면 수퍼키라 할 수 있다.
    - [학생번호]의 경우 중복되는 경우가 없기 때문에 유일성을 만족하므로 슈퍼키가 될 수 있다.
    - [이름,나이,성별]의 경우 이 세가지 모두가 일치하는 사람이 존재할 수 있으므로 유일성을 만족하지 못한다. 따라서 수퍼키로 사용할 수 없다.
    - [학생번호,나이,성별]의 경우 학생번호 한가지만으로 각 튜플(레코드,행)을 구별할 수 있기 때문에 유일성을 만족한다. 따라서 수퍼키로 사용할 수 있다.

### Candidate key (후보키)

- 유일성 O, 최소성 O
- 수퍼키 중에서 최소성을 만족하는 키를 칭한다. 즉, 유일성과 최소성을 모두 만족하는 속성들의 집합이다.
- 아래와 같이 수퍼키가 있다고 할때,
    - [학생번호,나이,성별]의 경우, 학생번호가 있다면 나이와 성별은 특정 학생을 구별할 때 필요없다. 없어도 전혀 문제가 안됨. 여기서 나이와 성별을 제거한 [학생번호]의 경우 최소성을 만족하며 후보키가 될
      수 있다.

### Primary key (기본키)

- 주 키, 프라이머리 키, PK 등으로 불리운다. 후보키들중 메인으로 선정되는 키로 후보키의 성질을 갖는다.
- 유일성과 최소성을 가지며(후보키), 해당 레코드를 식별할때 기준이 되는 반드시 필요한 키이다.
- 추가로 기본키는 다음과 같은 조건을 따른다.
    - 값의 변동이 잦은 후보키는 기본키로 부적절하다.
    - NULL값을 가질수 있는 속성이 포함된 후보키는 부적절하다.
    - 후보키중 단순한 키를 기본키로 선택한다.
    - 하나의 테이블에는 반드시 하나의 기본키만 존재한다.

### Foreign key (외래키)

![](https://velog.velcdn.com/images/kon6443/post/b31eae83-a9b8-4ede-915b-c88f527175e7/image.png)

- 테이블간의 관계를 나타낼때 사용하며, 다른 테이블의 기본키를 참조해 외래키로 사용한다.
    - 즉, 한 테이블의 외래키는 연결되어있는 다른 테이블의 기본키중 하나다.
    - 위의 왼쪽 테이블에서 student_id는 기본키이며, 오른쪽 테이블에서는 외래키이다.
        - 학생 목록을 나타내는 왼쪽 테이블에서 1~4의 학생이 있으며, 오른쪽 테이블에서 외래키로 사용되는 student_id는 그 외 값이 나타날 수 없다.
- 사실 외래키 설정을 따로 하지 않아도 데이터 조회가 가능하지만, 굳이 하는 이유는 데이터 무결성 때문이다.
    - 무결성: 데이터가 항상 정확한 값을 유지하는 성질
- 위 테이블중 왼쪽 테이블에서 student_id가 변경되었는데 오른쪽 테이블의 student_id가 변경되지 않았다면 문제가 생긴다. 이런 상황을 예방하기 위해 외래키가 존재한다.

<hr />

## NoSQL과 RDB의 선택 기준과 구조 차이

### RDB와 NoSQL의 차이

#### 관계형 데이터베이스(RDB)

![](https://velog.velcdn.com/images/zsmalla/post/9a23e6fc-db76-4313-bb59-2fc2a4c0db15/image.png)

- 데이터 구조 : 테이블 형태로 데이터를 저장하며, 각 테이블은 레코드(행)와 속성(열)으로 구성된다. 테이블 간의 관계는 외래키(Foreign Key)를 사용하여 정의된다.
- 데이터 스키마 : 엄격한 스키마를 가진다. 데이터의 구조와 타입을 미리 정의해야 하며, 데이터의 변경이 필요한 경우, 스키마 변경이 복잡할 수 있다.
- 쿼리 언어 : 대표적인 쿼리 언어로 SQL(Structured Query Language)을 사용한다. SQL을 이용하여 데이터를 조회, 수정, 삭제할 수 있다.
- 트랜잭션: ACID 원칙(원자성, 일관성, 고립성, 지속성)을 준수하여 데이터의 일관성과 무결성을 보장한다.
- 스케일링 : 수평적 확장이 어려워서 대부분 수직적 확장을 사용한다. 대용량 트래픽 처리에 어려움이 있을 수 있다.

#### NoSQL 데이터베이스(NoSQL)

![](https://velog.velcdn.com/images/zsmalla/post/0ed62b96-8769-47e6-84cf-781d5ff2c1b1/image.png)

- 데이터 구조 : 다양한 형태의 데이터 모델을 사용한다. key-value, document, graph 등의 다양한 데이터 모델이 있다.
- 데이터 스키마 : 유연한 스키마를 가지며, 필요한 속성을 동적으로 추가할 수 있다. 스키마 변경이 간단하며, 다양한 형태의 데이터를 수용할 수 있다.
- 쿼리 언어 : SQL 대신 데이터베이스마다 다양한 쿼리 언어를 사용한다. 예를 들어, MongoDB는 자체 쿼리 언어를 사용한다.
- 트랜잭션 : 몇몇 NoSQL 데이터베이스는 ACID원칙을 준수하거나, 비교적 느슨한 일관성 모델(Consistency Model)을 따른다. 그러나 모든 NoSQL 데이터베이스가 이를 보장하지는 않는다.
- 스케일링 : 수평적 확장이 용이하다. 대용량 데이터 처리와 분산 환경에서 유리한 성능을 보일 수 있다.

### 둘 중 어떤 것을 선택해야 할까?

#### RDB 사용이 더 좋을 때

- 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우
- 사용자와 데이터에 있어서 변경될 여지가 없는 명확한 스키마가 중요한 경우

#### NoSQL 데이터베이스 사용이 더 좋을 때

- 정확한 데이터의 구조를 결정할 수 없거나 변경/확장될 수 있는 경우
- 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
- 데이터베이스를 수평으로 확장해야하는 경우(방대한 양의 데이터를 다뤄야 하는 경우)

<hr />

## 스키마 3계층(외부/개념/내부)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2362DF40571C8BE623)

### 개념스키마

- 데이터 베이스의 전체적인 논리적 구조
- 데이터 베이스에 실제로 어떤 데이터가 저장되었으며 데이터간의 관계는 어떻게 되는가
- 모든 응용프로그램이나 사용자들이 필요로하는 데이터를 종합한 조직전체의 데이터베이스
- 개체간의 관계와 제약조건 명시
- 데이터 베이스의 접근 권한 보안 및 무결성 규칙에 관한 명세를 정의
- 단순한 스키마라고 하면 개념스키마를 의미
- 기관이나 조직체의 관점에서 데이터베이스를 정의
- 데이터베이스 관리자 (DBA)에 의해 구성 * 데이터 베이스당 하나만 존재

### 내부스키마

- 데이터 베이스의 물리적 저장구조를 정의
- 디스크에는 어떤 구조로 저장할 것인가
- 데이터의 실제 저장방법을 기술
- 물리적인 저장장치와 밀접한 계층
- 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마

### 외부스키마

- 실세계에 존재하는 데이터들을 어떤 형식, 구조, 배치 화면을 통해 사용자에게 보여줄 것인가
- 전체 데이터 베이스의 한 논리적 부분 -> 서브 스키마
- 하나의 데이터베이스에는 여러 개의 외부스키마가 존재가능 & 하나의 외부스키마를 여러 개의 응용프로그램이나 사용자가 공용 가능
- 같은 데이터베이스에 대해서도 서로 다른 관점을 정의할 수 있도록 허용
- 일반 사용자는 질의어를 이용 DB를 쉽게 사용

<hr />

## B+Tree 인덱스 구조, 복합 인덱스, 인덱스 성능

### B+Tree 인덱스

![](https://velog.velcdn.com/images/wontaekoh/post/b8377db0-d55b-4090-a811-b17050a78a78/image.png)

- 데이터 저장 위치
    - B+트리에서는 모든 실제 데이터(레코드)가 리프 노드에만 저장된다. 내부 노드는 데이터가 아닌 탐색을 위한 키만을 가지고 있다.
    - 내부 노드는 검색용으로만 사용되고 데이터는 리프 노드에만 존재한다.
- 리프 노드의 연결
    - B+트리의 리프 노드들은 링크드 리스트 형태로 서로 연결되어 있어, 리프 노드를 순서대로 쉽게 접근할 수 있다.
    - 이 연결 덕분에 B+트리는 특정 범위의 데이터를 빠르게 검색할 수 있어 범위 조회(range query)에 유리하다.

### 복합 인덱스

- 복합 인덱스는 둘 이상의 칼럼을 통해 생성한 인덱스를 의미한다.
    - 복합 인덱스의 인덱스 스캔 활용 방식
        1. 인덱스 선두 칼럼부터 시작해서, 조건절에 등호 조건으로 사용한 칼럼들은 모두 인덱스 엑세스 조건으로 활용된다.
        2. 만약 위와 같은 상황에서 처음 범위 탐색 조건을 발견한 경우, 해당 조건까지만 인덱스 엑세스 조건으로 활용하고 그 이후에 인덱스 존재 칼럼 조건절에 대해서는 모두 인덱스 필터 조건으로 활용된다.
        3. 그 후 인덱스 조건으로 사용되지 않은 조건절은 테이블 필터 조건으로 활용된다.
        4. 복합 인덱스 내 모든 칼럼을 활용하지 않더라도, 선두칼럼부터 이어지는 칼럼 구성이 조건절에 포함된 경우 인덱스는 활용될 수 있다.
        5. 통념과는 다르게, 인덱스 카디널리티가 낮을 칼럼을 복합 인덱스 앞쪽에 배치한다고 해서 인덱스 스캔 상 더 효율적인 것은 아니다. 인덱스 자료구조는 2차원 테이블 형태가 아니기 때문에 인덱스를
           순차적으로 확인하지 않고 한번에 목적지를 향해 가기 때문에 이는 의미없는 고려이다.

### 인덱스가 성능에 미치는 영향

#### 성능 향상

- 검색 속도 향상 : 테이블 접근 없이 인덱스만으로 데이터 조회 가능
- 정렬 최소화 : `ORDER BY` 절과 잘 설계된 인덱스를 활용하면 정렬 과정 생략 가능
- JOIN 최적화 : 조인 대상 컬럼에 인덱스를 적용하면 조인 성능 대폭 개선

#### 성능 저하

- 인덱스 남용 : 너무 많은 인덱스는 오히려 쓰기(`INSERT`, `UPDATE`, `DELETE`) 성능 저하시킴
- 낮은 선택도 인덱스는 효과 없음 (예: 성별, 요일 등 소수의 반복 값)
- 인덱스 스캔보다 테이블 전체 스캔이 빠른 경우 존재

<hr />

## 정규화 1~3NF, 이상현상, 역정규화 판단

### 정규화 과정

#### 제1 정규형(1NF, FirstNormal Form)

- 1NF를 만족하지 못하면 관계형 데이터베이스(RDB, Relational Database)가 될 수 없다.
- 릴레이션에 속한 모든 속성의 도메인이 원자 값으로만 구성되어야함
- 1NF를 만족해도 이상 현상이 발생한다
    - 부분 함속 종속을 제거해서 2NF로 만들어 이상 현상 줄임

#### 제2 정규형(2NF, Second Normal Form)

- "1NF를 만족" and "부분 함수 종속"을 제거 -> 완전 함수 종속된 정규형
- 모든 속성이 기본키에 완전 함수 종속
- 2NF를 만족해도 이상 현상 발생
    - 이행적 함수 종속을 제거해서 3NF로 만들어 이상 현상을 줄임

#### 제3 정규형(3NF, Third Normal Form)

- "1NF, 2NF"를 만족 and "이행 함수 종속" 제거
- 모든 속성이 기본키에 이행적 함수 종속이 아님

### 이상현상 (Anomaly)

- 테이블 내의 데이터들이 불필요하게 중복되어 테이블을 조작할 때 발생되는 데이터 불일치 현상
- 테이블을 잘못 설계하여 삽입, 삭제, 갱신할 때 오류가 발생하게 되는 것
- 삽입 이상 (insertion anomaly) : 원하지 않는 자료가 삽입된다든지, key가 없어 삽입하지 못하는(불필요한 데이터를 추가해야 삽입할 수 있음) 문제점
- 삭제 이상 (deletion anomaly) : 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점
- 갱신 이상 (update anomaly) : 일부만 변경하여 데이터가 불일치하는 모순, 또는 중복되는 튜플이 존재하게 되는 문제점

### 역정규화 (Denormalization)

- 역정규화는 성능을 향상시키기 위해 정규화된 DB 를 다시 중복을 포함하는 형태로 변경하는 프로세스이다.
- 테이블을 너무 많이 잘게 쪼개면 여러 테이블들이 모두 동시에 조인을 하게 되기 때문에 성능이 느려지는 이슈가 발생할 수 있고, 관리하기 어려워질 수 있다.
- 일반적으로 쿼리의 성능을 향상시키기 위해 사용되며, 특히 읽기 작업이 많은 시스템에서 유용하다.
- 데이터의 일부를 중복 저장하거나 중복 인덱스를 생성함으로써 데이터에 대한 읽기 액세스를 최적화한다.
- 하지만 데이터 일관성을 유지하기 위해 조심스럽게 사용되어야 한다.
