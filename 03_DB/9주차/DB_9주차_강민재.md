### [9주차] 키(Key) + RDB vs NoSQL + 스키마 + 인덱스 + 정규화

- 기본키/후보키/외래키 차이
- NoSQL과 RDB의 선택 기준과 구조 차이
- 스키마 3계층(외부/개념/내부)
- B+Tree 인덱스 구조, 복합 인덱스, 인덱스 성능
- 정규화 1~3NF, 이상현상, 역정규화 판단

## 🔵 기본키 / 후보키 / 외래키 차이

| 용어   | 정의                                                     | 특징                                                        |
| ------ | -------------------------------------------------------- | ----------------------------------------------------------- |
| 기본키 | 테이블에서 각 행(row)을 유일하게 식별할 수 있는 속성     | NULL 허용 불가, 중복 불가, 하나의 테이블에 하나만 존재 가능 |
| 후보키 | 기본키로 선택될 수 있는 잠재적인 속성 또는 속성들의 조합 | 여러 개 존재 가능, 이 중 하나를 기본키로 선택               |
| 외래키 | 다른 테이블의 기본키를 참조하는 속성                     | 참조 무결성 유지에 사용되며, 부모 테이블의 데이터와 연관됨  |

- 기본키는 레코드를 식별하는 유일한 기준이다.
- 후보키는 여러 속성 조합 중 기본키가 될 수 있는 것들이며, 중복 불가 조건을 만족해야 한다.
- 외래키는 다른 테이블과의 관계를 연결하는 데 사용된다.

---

<br>

## 🔵 NoSQL과 RDB의 선택 기준과 구조 차이

| 비교 항목   | RDB (Relational Database)                         | NoSQL (Not Only SQL)                                                  |
| ----------- | ------------------------------------------------- | --------------------------------------------------------------------- |
| 데이터 모델 | 테이블 기반, 정형화된 구조                        | 문서형, 키-값, 컬럼형, 그래프형 등 다양한 형태                        |
| 스키마      | 사전에 정의된 고정된 스키마                       | 스키마가 유연하거나 존재하지 않음                                     |
| 확장성      | 수직 확장(서버 성능을 높이는 방식)                | 수평 확장(노드를 늘리는 방식)                                         |
| 트랜잭션    | ACID(원자성, 일관성, 고립성, 지속성) 지원         | BASE(기본적 가용성, 상태 소프트, 궁극적 일관성) 지향                  |
| 사용 사례   | 전통적인 금융, ERP, CRM 등 정합성이 중요한 시스템 | 실시간 분석, 캐시, 빅데이터, 소셜 네트워크 등 대규모 분산 환경에 적합 |

- RDB는 데이터 무결성과 정합성이 중요한 경우 유리하다.
- NoSQL은 대규모 분산 환경에서 성능과 확장성을 중시하는 경우 적합하다.
- NoSQL은 유연성과 속도 면에서는 강점을 가지지만, 트랜잭션이나 일관성 면에서는 RDB에 비해 제한적일 수 있다.

---

<br>

## 🔵 스키마 3계층 (ANSI/SPARC)

데이터베이스 시스템은 논리적/물리적 독립성을 위해 3계층 구조로 설계된다.

1. **외부 스키마 (External Schema)**

   - 사용자 또는 애플리케이션이 보는 데이터 뷰
   - 여러 외부 스키마가 존재할 수 있으며, 사용자 맞춤형 데이터 뷰 제공 가능

2. **개념 스키마 (Conceptual Schema)**

   - 전체 데이터베이스의 논리적 구조 정의
   - 엔티티, 속성, 관계 등을 포함한 ERD 수준의 정의

3. **내부 스키마 (Internal Schema)**
   - 물리적 저장 구조와 접근 경로, 인덱스 등을 정의
   - 성능을 고려한 저장 방식이 이 계층에서 결정됨

> 이 구조는 데이터 독립성을 확보하여, 논리적/물리적 변경 시 사용자 영향 최소화를 목표로 한다.

---

<br>

## 🔵 B+Tree 인덱스 구조 / 복합 인덱스 / 인덱스 성능

### B+Tree 인덱스

- 데이터베이스에서 가장 널리 사용되는 인덱스 구조
- 리프 노드에만 실제 데이터를 저장하고, 모든 리프 노드가 연결 리스트 형태로 연결됨
- 균형 트리 구조이기 때문에 탐색, 삽입, 삭제 성능이 일정하게 유지됨 (O(log N))

### 복합 인덱스

- 두 개 이상의 컬럼을 조합하여 인덱스를 생성
- 생성 순서가 중요하며, 선두 컬럼 없이 후속 컬럼 단독으로는 인덱스가 제대로 작동하지 않음
  - 예: INDEX(a, b) → 조건이 `a=...` 또는 `a=... AND b=...` 일 때만 인덱스 사용 가능
  - 단독으로 `b=...`는 인덱스 사용 불가

### 성능 주의점

- 인덱스를 과도하게 만들면 오히려 INSERT, UPDATE 시 부하 증가
- 적절한 인덱스는 SELECT 성능을 획기적으로 개선할 수 있으나, 빈도와 조건을 고려해 설계해야 한다
- 복합 인덱스는 조건이 자주 조합되는 컬럼끼리 묶는 것이 효과적

---

<br>

## 🔵 정규화 1~3NF / 이상현상 / 역정규화

### 정규화의 목적

- 데이터 중복 제거
- 데이터 무결성 유지
- 이상현상 방지

### 정규화 단계 요약

| 단계 | 의미                                                                     |
| ---- | ------------------------------------------------------------------------ |
| 1NF  | 모든 필드가 원자값을 가져야 한다 (더 이상 분해 불가능한 단위)            |
| 2NF  | 1NF 만족 + 기본키의 일부분에 종속된 속성 제거 (부분 함수 종속 제거)      |
| 3NF  | 2NF 만족 + 기본키가 아닌 속성에 종속된 속성 제거 (이행적 함수 종속 제거) |

### 이상현상

- **삽입 이상**: 일부 정보가 없으면 데이터 삽입이 불가능한 문제
- **삭제 이상**: 하나의 데이터를 삭제할 때 관련된 중요한 데이터도 함께 삭제되는 문제
- **갱신 이상**: 데이터 중복으로 인해 일부만 갱신 시 불일치 발생

### 역정규화

- **정의**: 정규화를 되돌려 성능을 개선하는 작업
- **방법**
  - 테이블 병합
  - 중복 컬럼 허용
  - 캐싱용 컬럼 추가
- **적용 시점**: 정규화로 인해 너무 많은 조인이 발생하거나 성능 병목이 생길 때

정규화는 데이터의 정합성과 무결성을 우선하는 설계 원칙이고, 역정규화는 성능 최적화를 위해 제한적으로 적용되는 전략이다.
