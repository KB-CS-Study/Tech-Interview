블로그 정리 글 👇🏻
- [키, 인덱스](https://0woy.tistory.com/entry/%ED%82%A4-Key)
- [RDB, NoSQL](https://0woy.tistory.com/entry/RDB%EC%99%80-NoSQL-%EB%B9%84%EA%B5%90)
- [스키마 3계층](https://0woy.tistory.com/entry/%EC%8A%A4%ED%82%A4%EB%A7%88-3%EA%B3%84%EC%B8%B5)
- [DB 정규화, 역정규화, 이상현상](https://0woy.tistory.com/entry/DB-%EC%A0%95%EA%B7%9C%ED%99%94-%EC%97%AD%EC%A0%95%EA%B7%9C%ED%99%94-%EC%9D%B4%EC%83%81%ED%98%84%EC%83%81)

---

KEY 는 DB에서 레코드를 **고유하게 식별**하는 데 사용되는 **속성** 또는 속성들의 집합을 의미

## Key의 종류

| **이름** | **설명** |
| --- | --- |
| **슈퍼 키 (Super Key)** | 유일성을 만족하는 키, ex) 학번 + 이름, 주민번 |
| **복합 키 (Composite Key)** | 2개 이상의 속성을 사용한 키 |
| **후보 키 (Candidate Key)** | **유일성**과 **최소성**을 만족하는 키, 기본키가 될 수 있는 후보이므로 후보 키라고 불림 |
| **기본 키 (Primary Key)** | 후보 키에서 선택된 키, NULL값과 중복 허용 X |
| **대체 키 (Surrogate Key)** | 후보 키 중에서 기본 키로 선택되지 않은 키 |
| **외래 키 (Foreign Key)** | 어떤 테이블 간의 **기본 키를 참조하는 속성**   테이블 간의 관계를 나타내기 위해 사용 |

---

예시) 학생 테이블 

| 학생ID  | 이름 | 이메일 | 학번 | 반 | 번호 |
| --- | --- | --- | --- | --- | --- |
| 1 | 철수 | [chulsoo@gmail.com](mailto:chulsoo@gmail.com) | 20231001 | 3 | 12 |
| 2 | 영희 | [younghee@gmail.com](mailto:younghee@gmail.com) | 20231002 | 3 | 7 |
| 3 | 민수 | [minsoo@gmail.com](mailto:minsoo@gmail.com) | 20231003 | 4 | 1 |

### 1\. Primary Key (기본 키)

-   학생ID는 각 학생을 유일하게 구별할 수 있음
-   학생ID는 중복될 수 없고 절대 NULL 값을 가질 수 없음
-   테이블 마다 기본 키는 하나만 설정 가능

**\= 학생ID가 Primary Key**

---

### 2\. 후보 키 (Candidate Key)

-   학생ID, 이메일, 학번 모두 각각 학생을 유일하게 식별 가능
-   따라서 위 3개의 속성은 모두 후보 키가 됨

---

### 3\. 대체 키 (Alternative Key)

후보 키 중에서 Primary Key가 아닌 것들, 즉 \`email\`과 \`학번\`이 대체 키

---

### 4\. 외래 키 (Foreign Key)

성적 테이블

| 성적ID | 학생ID | 과목 | 점수 |
| --- | --- | --- | --- |
| 1 | 1 | 수학 | 90 |
| 2 | 2 | 영어 | 85 |
| 3 | 1 | 과학 | 88 |

-   성적 테이블의 학생ID = 학생 테이블의 학생ID
-   따라서 **성적.학생ID는 학생.학생ID를 참조**하는 외래 키임
-   이를 통해 두 테이블간 관계 설정

---

### 5\. 복합 키 (Composite Key)

만일 성적 테이블에서 **학생ID와 과목**이 함께 하나의 PK라면 두 속성을 합쳐서 레코드 구분 가능

_**즉, 한 학생이 같은 과목 성적을 여러번 기록할 수 없도록 보장**_

---

### 6\. 슈퍼 키 (Super Key)

-   \`학생 id\` +\`email\`로 유일하게 학생을 식별할 수 있음
-   유일성을 보장하지만 불필요한 속성이 포함된 경우라 후보 키가 아님

👉 **유일성을 만족하는 모든 키 조합**이 슈퍼 키

![KEY](https://github.com/user-attachments/assets/f7e39c44-9bfe-4adb-864c-dcbff82797b3)


---

## 인덱스 (Index)

데이터베이스에서 **검색 속도를 빠르게** 하기 위해 사용하는 자료 구조

책의 \`목차\`나 색인과 같은 역할을 함

```
-- email 컬럼에 인덱스 생성
CREATE INDEX idx_email ON Users(email);

-- 복합 인덱스 (이름 + 나이)
CREATE INDEX idx_name_age ON Users(name, age);
```

### 예시

Users 테이블에 수만 명의 사용자가 있고, email을 기준으로 특정 사용자를 검색한다고 가정

```
SELECT * FROM Users WHERE email = 'chulsoo@gmail.com';
```

-   **인덱스가 없으면?**  
    → 데이터베이스는 전체 테이블을 처음부터 끝까지 하나씩 확인 (Full Table Scan)  
    → **느림**
-   **인덱스가 있으면?**  
    → 이메일 컬럼에 인덱스를 생성해두면  
    → 마치 책에서 이름순 색인을 찾듯이, **빠르게 해당 이메일 위치로 이동**

---

#### 언제 인덱스를 써야 할까?

-   WHERE 절에 자주 쓰이는 컬럼
-   JOIN 조건에 자주 사용되는 컬럼
-   정렬(ORDER BY), 그룹(GROUP BY)에 자주 사용되는 컬럼
-   고유한 값을 자주 검색하는 컬럼 (ex. email, user\_id 등)

> 📌 **인덱스 주의 사항**  
> 데이터 추가, 수정, 삭제 시 인덱스도 같이 갱신 -> **쓰기 성능 저하**  
> 인덱스는 별도의 **저장 공간** 必  
> 너무 많은 인덱스 사용은 **성능 저하와 관리의 복잡성** 유발

---

#### 성능에 영향을 주는 요소

| **요소**  | 설명 |
| --- | --- |
| **선택도(Selectivity)** | 해당 컬럼이 얼마나 고유한 값을 가지는가 (고유할수록 성능에 유리) |
| **인덱스 컬럼 순서** | 복합 인덱스의 경우 조건 순서가 맞지 않으면 미사용 |
| **데이터 분포도** | 너무 같은 값이 많으면 인덱스 효율 ↓ |
| **쿼리 형태** | LIKE '%abc'처럼 앞이 와일드카드면 인덱스 무효 |

-   **자주 검색하는 컬럼**에 인덱스 부여
-   **조건이 자주 조합되는 컬럼**은 복합 인덱스
-   **쓰기 많은 테이블**에는 최소한의 인덱스만 유지
-   EXPLAIN을 통해 쿼리 실행 계획을 확인하세요!

---

## 인덱스 구조

### 클러스터형 인덱스 (Clustered Index)

-   인덱스가 실제 데이터 자체를 정렬해서 저장 (ex. 영어 사전)
-   테이블 당 1개만 가능 (MySQL은 기본 키에 자동 생성)
-   **\`데이터 = 인덱스\`** 이므로 디스크 접근을 최소화하여 읽기가 빠름

> ex) PRIMARY KEY 인덱스

---

### 보조 인덱스 (Secondary Index)

-   인덱스는 별도로 존재하고, 실제 데이터 위치만 참조
-   여러 개 생성 가능
-   읽기 시 추가로 데이터 위치를 따라 가야 함
-   인덱스 = PK + Row ID 

> ex) UNIQUE, 일반 B-Tree 인덱스

---

### 예시

-   PRIMARY KEY를 만들면 그 컬럼이 **Clustered Index**가 됨
-   나머지 인덱스 (UNIQUE, 일반 INDEX)는 전부 **보조 인덱스**

```
CREATE TABLE Users (
  id INT PRIMARY KEY,          -- 클러스터형 인덱스 (기본키)
  email VARCHAR(255),
  name VARCHAR(100),
  INDEX idx_email(email)       -- 보조 인덱스
);
```

---

## 인덱스 종류

| **종류** | 설명 | 사용 예시 |
| --- | --- | --- |
| B-Tree 인덱스 | 기본 인덱스. 범위 검색, 정렬에 강함.   대부분의 RDB에서 기본 제공 | 숫자, 문 자열, 날짜 등 범용 컬럼 |
| **B+Tree 인덱스** | 데이터는 오직 리프 노드에만 저장, 리프 노드끼리 연결됨 |  "" |
| Hash 인덱스 | 해시 테이블 기반. 정확한 값 검색(=)에 빠름. **범위 검색 불가** | 메모리 기반 NoSQL(DB), Redis 등 |
| Unique 인덱스 | 중복을 허용하지 않는 인덱스. 고유한 값만 허용 | 주민번호, 이메일, ID 등 |
| Full-Text 인덱스 | 텍스트 검색 전용 인덱스. 단어 기준 검색, 유사 검색 등에 사용 | 게시판, 블로그 검색 |
| Spatial 인덱스 | 공간(지리 정보, 좌표 등)을 효율적으로 검색하기 위한 인덱스 | 지도, 위치 기반 서비스 |
| **복합 인덱스** | 여러 컬럼을 묶어 하나의 인덱스로 생성.   조건이 복합적인 쿼리에 유리 | WHERE name='홍길동' AND age=30 |
| 비트맵 인덱스 | 값이 적은(저카디널리티) 컬럼에 효과적. 0/1 비트 배열로 관리 | 성별, 상태값(예/아니오 등) |
| Clustered 인덱스 | 인덱스가 **데이터 자체를 정렬**한 형태   (MySQL InnoDB에서 기본 PK 인덱스) | PK(기본키)에 자동 생성 |
| Non-clustered 인덱스 | 데이터와는 분리되어 별도로 인덱스만 존재하는 형태 | 서브 키, 조회 전용 컬럼 |

---

## B-Tree?, B+Tree란?

MySQL의 DB engine인 InnoDB는 B+Tree로 이루어져 있는데, 이는 **B-Tree의 확장 개념**임

### B-Tree

B-tree의 핵심은 데이터가 정렬된 상태로 유지되어 있음

![btree](https://github.com/user-attachments/assets/725ec246-94f1-402e-b53e-cb8c110b4217)


가장 상단의 노드를 루트 노드, 중간을 브랜치 노드, 맨 아래는 리프 노드라고 칭한다.

B-tree는 Binary search tree와 유사하지만, **한 노드 당 자식 노드가 2개 이상 가능**하다. 

key 값을 이용해 찾고자 하는 데이터를 **트리 구조를 이용**해 찾는 것이다.

---

### 왜 B-Tree는 빠른가?

B-tree의 장점 한 가지는 '어떤 값에 대해서도 같은 시간에 결과를 얻을 수 있다'인데, 이를 '균일성'이라고 함

위의 예시에서 리프노드에 있는 값을 찾는 시간은 동일할 것이다.  
(트리 높이가 다른 경우, 차이는 있겠지만 O(logN)이라는 시간 복잡도를 가짐)

![균형](https://github.com/user-attachments/assets/24dc64cb-80c6-4275-a169-00bd556e86b6)


균형 트리란 루트 노드부터 리프 노드까지의 거리가 일정한 트리 구조 의미  
👉 **트리 중에서 특시 성능이 안정화** 됨

그러나 B-Tree는 처음 생성 당시는 균형트리지만, **테이블 갱신**의 반복을 통해 서서히 **균형이 깨지고 성능이 악화**됨

어느 정도 자동으로 균형을 회복할 수 있지만,  
갱신 빈도가 잦은 테이블에 작성되는 인덱스 같은 경우인덱스 재구성을 통해 트리의 균형을 되찾는 작업 必

![scan](https://github.com/user-attachments/assets/063e7e69-552c-4876-8b69-ead2c8fffb93)


풀 스캔이 테이블 크기에 비례하는 형태로 실행 시간이 늘어가는 데 반해  
인덱스를 사용하면 실행 시간 저하는 보통 완만한 곡선을 그림

---

### B+Tree

B-Tree의 확장 개념, B-Tree는 Internal 또는 Branch 노드에 key와 data를 담을 수 있음

하지만, B+Tree의 경우, 브랜치 노드에 key만 담아두고, data는 담지 않음  
\= **오직 리프 노드에만 key와 data를 저장**하고, **리프 노드끼리 연결 리스트로 연결** 되어 있음

![b+](https://github.com/user-attachments/assets/9f159051-af58-4b01-9eb1-9f09de748fba)


InnoDB에서 B+tree는 단순하게 설명한 B+tree보다 더 복잡하게 구현돼 보임

-   **같은 레벨**의 노드들끼리는 \`Double Linked List\`를 사용
-   **자식 노드**로는 \`Single Linked List\`로 연결되어있다.

key의 범위마다 찾아가야할 **페이지 넘버(**포인터)가 있는데, **해당 페이지 넘버를 통해 곧바로 다음 노드**로 넘어간다.

리프 노드에 다다랐을 때 디스크에 존재하는 데이터의 주소값을 구할 수 있고, Linked List를 통해 탐색도 가능하다. 

| **항목** |  B-Tree  | **B+Tree** |
| --- | --- | --- |
| **데이터 저장 위치** | 모든 노드(내부/리프)에 데이터 저장 가능 | **데이터는 오직 리프(Leaf) 노드에만 저장** |
| **리프 노드 연결** | 연결 안 됨 | 리프 노드끼리 **연결 리스트로 연결** (범위 탐색에 유리) |
| **범위 조회** | 비효율적 | 효율적 (리프 노드만 따라가면 됨) |
| **사용성** | 일반 트리 검색용 | **DB 인덱스에 최적화됨** (범위 검색, 정렬 등 빠름) |

---

## RDB (Relational Database)

관계형 데이터베이스는 가장 많이 사용되고 있는 DB 중 하나로, 데이터를 **테이블 형태**로 표현하여 구조화

각 테이블은 \`행\`과 \`열\`으로 이루어져 있으며, **테이블 간의 관계**를 맺어서 데이터를 조직적으로 관리

```
// MySQL

-- Users 테이블
+----+--------+----------------------+
| ID | Name   | Email                |
+----+--------+----------------------+
| 1  | 철수   | chulsoo@gmail.com    |

-- Orders 테이블 (user_id 외래 키)
+----+----------+-----------+
| ID | user_id  | Product   |
+----+----------+-----------+
| 1  |    1     | Keyboard  |
```

![table](https://github.com/user-attachments/assets/e39a6ae8-2c1b-478b-8b02-263ed520f17b)


![relation](https://github.com/user-attachments/assets/505f9da2-12c8-443e-b0dd-8c98f2d9c510)

이러한 테이블 집합을 관계형 데이터베이스 라고 함.

---

### 특징

-   스키마 기반: 테이블 구조 (컬럼 이름, 데이터 타입 등)를 미리 정의
-   SQL 사용: 데이터를 조회, 삽입, 수정, 삭제하는 표준 언어
-   트랜잭션 지원: \`**ACID**\` 특성을 강력히 보장
-   복잡한 조인을 통해 여러 테이블 데이터 결합 가능

> **❓ ACID란**  
> 원자성 (Atomic): 트랜잭션 내 모든 작업이 전부 수행 또는 전부 수행되지 않아야 함  
> 일관성 (Consistency): 트랜잭션 수행 전후에 db는 항상 일관된 상태 유지  
> 고립성 (Isolation): 여러 트랜잭션 동시 수행 시 서로 간섭X  
> 지속성 (Durability): 트랜잭셩이 성공적으로 완료되면, 그 결과는 영구적 저장

---

## NoSQL (Not Only SQL)

-   비관계형 데이터베이스로 전통적인 RDB와 다르게 **비정형 또는 반정형 데이터**를 저장하는 데이터베이스
-   분산 환경에서 데이터를 **빠르게 처리**하기 위해 개발됨
-   데이터 모델이 자유롭고, 스키마가 미리 정의되지 않거나 유연한 스키마 사용

```
// MongoDB - Document
{
  "_id": 1,
  "name": "철수",
  "email": "chulsoo@gmail.com",
  "orders": [
    { "product": "Keyboard" },
    { "product": "Mouse" }
  ]
}
```

### 특징

-   비관계형 데이터 베이스로 데이터 간의 관계 정의X
-   스키마에 제약을 두지 않으며, 동적으로 스키마 변경 가능
-   다양한 데이터 모델 지원
-   스키마가 유연하므로 비정형 또는 반정형 데이터 효율적 처리 가능
-   SQL을 사용하지 않음
-   분산형 구조를 갖ㅁ
-   여러 대의 저렴한 서버를 사용할 수 있도록 설계되어 효율적

---

### 데이터 모델

![nosql](https://github.com/user-attachments/assets/b4c420b4-0da0-4ca8-a01e-c47d74ec0bb8)


#### Key-Value Store (키-값 스토어)

단순한 키-값 쌍으로 데이터 저장, 복잡한 조회 연산 지원X

구조가 단순하기 때문에 빠른 읽기 & 쓰기가 가능하며 **분산환경**에 적합

> ex) Redis, DynamoDB, Riak 등 

---

#### Document Database (문서 데이터베이스)

-   데이터를 문서 형태로 저장하고 처리하는 데이터베이스
-   주로 \`JSON\`, \`XML\` 등과 같은 형식으로 표현되며, 유연한 데이터 구조를 가짐
-   **중첩된 데이터 구조**를 지원하여 복잡한 데이터 모델 표현 가능

> ex) MongoDB, CouchDB

---

#### Wide-Column Store Database (와이드 컬럼 스토어 데이터 베이스)

-   열에 대한 데이터를 집중적으로 관리하는 데이터베이스로 각 열에는 \`Key-Value\` 형식으로 데이터 저장
-   컬럼 패밀리라고 하는 열의 집합체 단위로 데이터 처리 가능
-   하나의 행 내에 많은 열을 포함할 수 있어 높은 유연성을 가지므로 대규모 데이터 분석, 실시간 데이터 처리에 적합

> ex) Apache Cassandra, Hbase

---

#### Graph Database (그래프 데이터베이스)

-   데이터 간의 관계를 그래프 구조로 표현하는 데이터베이스
-   노드와 간선으로 구성되며, 각 노드는 속성별로 데이터를 저장하고 간선은 노드 사이의 관계 표현
-   복잡한 데이터 관계를 쉽게 표현하고 복잡한 Join 작업도 간단하게 처리 가능
-   지도 서비스, 추천 시스템, 소셜 네트워크 등 다양한 분야에 활용

> ex) Neo4J, InfiniteGraph

---

## RDB, NoSQL 선택 기준

-   **RDB**
    -   정형 데이터, 안정성 & 정확성이 중요한 경우
    -   복잡한 관계, 강한 트랜잭션 필요한 경우
    -   데이터의 구조가 명확하여 명확한 스키마가 필요한 경우
    -   관계를 맺고 있는 데이터가 자주 변경되는 경우
-   **NoSQL**
    -   비정형 데이터, 빠른 개발, 유연성 필요한 경우
    -   대량의 로그, 사용자 행동 기록을 저장하는 경우
    -   정확한 데이터 구조를 알 수 없는 경우
    -   대용량 데이터로 Scale-out 해야하는 경우
    -   읽기는 자주하나, 변경은 자주 없는 경우

---

| **선택 기준** | RDB | NoSQL |
| --- | --- | --- |
| **데이터 구조** | 정형화된 구조 (스키마 엄격) | 비정형/반정형 구조 (스키마 유연하거나 없음) |
| **스키마 변경** | 어렵고 번거로움 | 유연하고 쉽게 변경 가능 |
| **데이터 관계** | 테이블 간 복잡한 관계를 자주 다룸 (Join) | 관계보단 개별 데이터 저장 중심 |
| **트랜잭션 요구** | ACID 보장 필요 (정확성 중요) | 대량 처리, 일부 유실 감수 가능할 때 |
| **확장성** | 수직 확장 (서버 업그레이드) | 수평 확장 (서버 여러 대 분산 저장) |
| **쿼리 복잡도** | 복잡한 SQL 쿼리, 조인 다수 필요 | 단순 조회/삽입 중심, 조인 피함 |
| **개발 속도** | 구조 먼저 설계 필요, 변경 어려움 | 유연한 구조로 빠른 개발 가능 |
| **사용 예시** | 은행, ERP, 회계 시스템, CRM | 소셜미디어, 채팅 앱, IoT, 게임, 로그 저장 등 |

---

데이터베이스를 **사용자와 시스템 관점에서 나누어 설계**하기 위해 ANSI/SPARC 모델에서 제안한 개념

총 3가지 수준으로 나누어 DB 정의

-   외부 스키마 
-   개념 스키마
-   내부 스키마

이 구조는 데이터 독립성을 보장하는 핵심 메커니즘이다.

---

## 외부 스키마 (External Schema)

**사용자 관점**의 스키마

각 사용자 또는 응용프로그램이 보는 **부분적인 데이터** 구조

하나의 DB에 대해 **여러 개 존재** 가능 (사용자마다 다름)

```
-- 실제 테이블에는 이름, 나이, 급여, 주소 등이 있지만
-- 외부 사용자 1은 이름과 급여만 조회하도록 설계
SELECT name, salary FROM employees;
```

---

## 개념 스키마 (Conceptual Schema)

-   DB 전체를 통합적으로 표현한 논리 구조
-   모든 사용자와 응용 프로그램에 공통으로 보이는 구조
-   관계, 속성, 제약 조건 등이 정의
-   **\`ERD (Entitiy Relationship Diagram)\`에 해당**

```
-- 테이블 정의
CREATE TABLE employees (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  age INT,
  salary DECIMAL(10, 2),
  address TEXT
);
```

---

## 내부 스키마 (Internal Schema)

-   DBMS가 실제로 데이터를 저장하고 접근 하는 방식
-   저장 포맷, 인덱스 구조, 압축, 페이지 구조 등 \`**시스템적 요소\`** 포함
-   **사용자에게는 보이지 않음**

> ex) B-Tree 인덱스, 페이지 단위 저장, 데이터 압축 등

![schema](https://github.com/user-attachments/assets/137a4ce4-7ded-4afe-9592-96868cf908df)


---

## 외부 스키마?  SQL View?

외부 스키마의 관점에서 말하는 view와, 우리가 SQL에서 사용하는 VIEW는 개념적으로 거의 동일

| **항목** | 외부 스키마 | SQL View |
| --- | --- | --- |
| **사용자 관점** | 사용자/응용프로그램에게 보여지는 데이터 뷰 | 특정 SELECT 결과를 저장해 놓은 논리적 테이블 |
| **전체 DB의 일부** | 전체 스키마 중 일부만 보여줌 | SELECT 쿼리 결과만 보여줌 |
| **보안/추상화 목적** | 사용자가 볼 수 있는 데이터만 제한 가능 | 민감 정보 숨기기, 복잡한 쿼리 추상화 가능 |
| **개념 수준** | DB 설계/ 모델링의 논리 구조 | SQL 구현 기능 중 하나 |
| **역할 범위** | 사용자, 앱, 그룹 전체의 관점 정의 | 특정 SELECT 쿼리 결과 재사용 |
| **기술적 구현 여부** | DB 설계상 개념, **VIEW로 구현될 수 있음** | 실제로 존재하는 SQL 객체 |

### 예시

"고객은 이름과 연락처만 보이게 하자." → **외부 스키마 설계**

```
CREATE VIEW customer_view AS
SELECT name, phone
FROM customers;
```

→ **SQL View** (외부 스키마 구현 방법 중 하나)

---

## 정규화

**RDB**에서 중복을 제거하고, 데이터 구조를 논리적으로 분해하여 삽입, 삭제, 갱신 이상을 방지하고  
**일관성 있는 구조**를 만드는 과정

### 제 1정규형 (1NF: First Normal Form)

모든 컬럼은 원자값만 가져야 함  
**👉 한 셀에는 하나의 값**만 있어야 한다.

![1nf](https://github.com/user-attachments/assets/26f5d163-d1d2-46f2-a3dc-66b0b39290d1)


수강 과목이 여러 값을 가짐 = \`**비정규형\`**

#### 정규화 후

![1NF2](https://github.com/user-attachments/assets/b4beb0d2-26b9-455d-8eaa-c52459e980e1)


---

### 제 2정규형 (2NF: Second Normal Form)

-   1NF 만족
-   \`**부분 함수 종속 제거\`**  
    **👉** 기본 키가 복합키일 경우, **일부 키에만 의존하는 속성 제거**

  ![2NF](https://github.com/user-attachments/assets/42f85b4e-5501-4c38-82f0-a4d1d0be1792)


-   기본 키 **(학번, 수강 과목)** → 하나의 학생이 여러 과목 수강
-   성적은 **기본키 전체에 종속** 됨 = OK
-   이름은 **학번으로만 결정**됨 = 부분 종속! (2NF 위반)

![2NF2](https://github.com/user-attachments/assets/7032f6e2-8fbb-451b-baf6-a3d1faf76aaf)


---

### 제 3정규형 (Third Normal Form)

-   2NF 만족
-   이행적 함수 종속 제거  
    👉 A →B →C 관계에서, A →C이면 이행적 종속

![3NF](https://github.com/user-attachments/assets/de4cc6d2-37fa-4478-8e58-f378c17408e7)


-   기본키 = (학번, 과목코드)
-   성적, 교수ID는 기본키에 직접 종속 = OK
-   교수이름은 교수ID로 결정됨 즉, **교수이름은 기본키에 이행적 종속**이므로 3NF 위반

![3NF2](https://github.com/user-attachments/assets/a5e52630-2902-4598-9fb0-b44e004010b5)


---

### 정리

| **정규형**  | **제거 대상** | **예시 속 문제점** |
| --- | --- | --- |
| **1NF** | 반복 속성, 다중 값 | 하나의 셀에 여러 값이 있는 경우 |
| **2NF** | 부분 함수 종속 | 복합키의 일부에만 의존하는 속성 존재 |
| **3NF** | 이행 함수 종속 | A → B → C 형태의 간접 종속 존재 |

-   실무에서 3NF까지 정규화하면 **데이터 무결성은 좋지만**, **JOIN이 많아져 성능 저하**가 생기기도 함
-   이럴 땐 **역정규화** 고려 (예: 교수이름을 성적 테이블에 중복 저장).

---

## 역정규화 (Denormalization)

정규화된 DB 구조를 일부러 중복 데이터를 허용하면서 다시 합치는 과정

-   정규화를 통해 테이블을 분리하여 중복 제거 & 무결성을 향상했다면
-   \`역정규화\`는 **조회 성능 향상**이나 **복잡한 JOIN 연산 감소**를 위해 **일부러 테이블을 합치거나 데이터 중복 저장**

---

### 왜 역정규화를 할까?

| **이유** | 설명 |
| --- | --- |
| **성능 개선** | 분리된 테이블을 JOIN하는 비용이 크거나 너무 자주 발생할 때 |
| **단순한 쿼리** | 복잡한 조인 없이 단일 테이블에서 필요한 정보 조회 가능 |
| **읽기 집중 환경** | 분석 시스템이나 리포팅 시스템처럼 **읽기가 많고 쓰기는 적은** 경우 |
| **실시간 응답속도 필요** | 실시간 서비스에서 빠른 응답이 중요할 때 |

---

### 언제 역정규화를 고려할까?

-   정규화된 DB에서 JOIN 때문에 **쿼리 속도가 너무 느릴 때**
-   데이터 일관성 문제보다 **성능이 더 중요할 때**
-   읽기 작업이 많고 쓰기 작업이 적은 OLAP(분석) 환경일 때
-   서비스 요구사항으로 인해 **실시간 응답 시간**이 중요한 경우

---

## 이상 현상 (Anomalies)

**정규화가 되지 않은 테이블**에서 \`삽입, 수정, 삭제\`할 때 발생하는 **불합리하거나 비정상적**인 현상

-   삽입 이상
-   갱신 이상
-   삭제 이상

![이상현상](https://github.com/user-attachments/assets/81c8767b-b8c8-4119-a622-8d61ecc363ef)


### 삽입 이상 (Insertion Anomaly)

새로운 과목을 개설하려고 하는데, 수강한 학생이 없어서 과목 정보를 넣을 수 없음

> ex) "체육" 과목을 추가하려 했으나, 수강한 학생이 없어 과목명만 넣을 수 없는 상황

---

### 갱신 이상 (Update Anomaly)

교수 이름이 바뀌었을 때, 해당 과목을 가르친 **모든 행에서 다 수정**해야 함

> ex)  DU 교수가 "RU" 교수로 개명한 경우, 과목이 여러 개면 전부 수정 & **누락되면 데이터 불일치** 발생

---

### 삭제 이상 (Deletion Anomaly)

어떤 데이터를 삭제하면서, 원하지 않는 다른 정보도 같이 사라지는 상황

> ex) 두리가 "과학" 과목을 드랍했더니, 과학 과목 자체가 사라짐

---

### 해결 방법

| **이상 현상** | **원인** | **해결 정규형** |
| --- | --- | --- |
| **삽입 이상** | 중복된 정보 없이 일부 정보만 저장할 수 없음 | 2NF 이상 |
| **갱신 이상** | 중복된 데이터가 많아 일관성 유지 어려움 | 3NF 이상 |
| **삭제 이상** | 일부 정보 삭제 시 다른 중요한 정보도 손실 | 2NF 이상 |
