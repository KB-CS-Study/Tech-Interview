## ✅ 1. 기본키 / 후보키 / 외래키

![image.png](attachment:73a4a30b-3b81-48b3-ad98-00267b321df9:image.png)

- 유일성: 하나의 키값으로 튜플을 유일하게 식별할 수 있는 성질을 의미함(중복X)
- 최소성: 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질
    - 특정 학교 학생을 구별할 때, 세가지 구별자[`학생번호`, `이름`, `성별`]가있다면 이는 유일성은 만족하지만 최소성은 만족하지 않음
    - `이름`과 `성별`을 제외한 학생번호 만으로 학생을 구별할 수 있으며 `학생번호`는 최소성을 만족함

### 🔹 슈퍼키(Super Key)

- 유일성 O, 최소성 X
- 유일성의 특성을 만족하는 속성들이 모여있기 때문에 중복 X
- 서로 구분만 가능하면 슈퍼라고 할 수 있음

### 🔹 후보키(Candidate Key)

- 유일성 O, 최소성 O
- 후보키는 위의 조건이 맞는 속성들의 집합

### 🔹 기본키(Primary Key)

- 유일성 O, 최소성 O
- **후보키들 중에서 메인으로 선정되는 키**
- 여러 개일 수 있으며, 그 중 하나를 기본키로 선택함
- 추가로 기본키는 다음과 같은 조건을 따름
    - 값의 변동이 잦은 후보키는 기본키로 부적절
    - NULL값을 가질수 있는 속성이 포함된 후보키는 부적절
    - 후보키중 단순한 키를 기본키로 선택
    - 하나의 테이블에는 반드시 하나의 기본키만 존재

### 🔹 외래키(Foreign Key)

- **다른 테이블의 기본키를 참조**하는 컬럼
- 테이블 간 관계(참조 무결성)를 형성
- 값은 참조되는 테이블의 기본키 값 중 하나여야 함

---

## ✅ 2. RDB vs NoSQL

### 🔹 RDB (Relational DataBase, 관계형 데이터베이스)

- 데이터를 행과 열로 구성된 테이블에 저장
- 스키마가 엄격하게 정의되어 있음 (정해진 구조 따라야 함)
- 테이블 간의 관계를 외래키로 표현할 수 있음
- SQL(Structured Query Language)로 데이터 조회/조작
    
    예시: MySQL, PostgreSQL, Oracle, MS-SQL 등
    

**특징:**

- 정형화된 데이터 처리에 적합
- 트랜잭션 처리 강함 (ACID 보장)
- 관계가 복잡한 데이터 구조에 유리

### 🔹 NoSQL (Not Only SQL, 비관계형 데이터베이스)

- 정형화되지 않은 데이터를 유연하게 저장(비정형 데이터)
- 스키마 없이 **JSON, 키-값, 문서, 그래프** 형태로 데이터 저장 가능
- 관계형 데이터베이스처럼 JOIN을 쓰지 않음
- **수평 확장성**에 유리 (대규모 분산 환경)
    
    예시: MongoDB(문서형), Redis(키-값형), Cassandra(Wide Column), Neo4j(그래프형)
    

**특징:**

- 데이터 구조가 유동적인 경우 적합
- 빠른 쓰기/읽기 성능
- 실시간 데이터 처리나 빅데이터 시스템에 활용

### 수직적 확장(Scale-up) va 수평적 확장(Scale-out)

| 항목 | RDB (관계형 데이터베이스) | NoSQL (비관계형 데이터베이스) |
| --- | --- | --- |
| 확장 방식 | **수직 확장(Vertical Scaling)** | **수평 확장(Horizontal Scaling)** |
| 확장 예시 | 더 빠른 CPU, 더 많은 RAM 장착 | 서버 대수 추가로 분산 저장 |
| 설계 구조 | 스키마 기반 / JOIN 중심 / 정규화 | 스키마 유연 / 중복 허용 / 비정규화 |
| 확장 용이성 | 구조 변경 없이 확장 쉬움 (단, 한계 존재) | 초기에 분산 구조 고려해야 함 (복잡하지만 확장성 뛰어남) |
| 사용 사례 | 은행, ERP 등 데이터 정합성이 중요한 시스템 | SNS, 실시간 채팅, 로그 저장 등 트래픽이 큰 시스템 |

### 🔹 수직 확장과 RDB

- RDB는 **단일 서버에서 모든 데이터를 정규화된 구조로 관리**하는 방식
- 트랜잭션 처리와 JOIN 등 복잡한 연산을 지원하지만, 다수의 서버에 분산되면 **정합성 보장이 어려움**
- 그래서 **"더 좋은 서버로 업그레이드"** 방식인 수직 확장이 일반적
- 한계점: 일정 수준 이상의 트래픽 증가에는 **버티기 어려움** → 구조 개편 필요

### 🔹 수평 확장과 NoSQL

- NoSQL은 데이터를 여러 노드에 나눠 저장(샤딩)하도록 설계됨
- JOIN 대신 중복 저장을 허용하며, 스키마가 유연함
- 따라서 **여러 대의 서버에 데이터를 분산 저장**하면서도 처리 속도 유지 가능
- 클라우드, 빅데이터 환경에 적합 (MongoDB, Cassandra, Redis 등)

### 왜 이 차이가 중요할까?

- 대용량 트래픽이나 데이터 처리가 필요한 경우:
    - **RDB만으로는 수직 확장의 한계**를 넘어야 하므로 병목 발생
    - 반면 **NoSQL은 서버를 더 붙이는 수평 확장이 자연스러운 구조**
- 정합성(ACID) vs 확장성(CAP)의 균형에서:
    - RDB: **정합성 우선**, 확장성은 제한적
    - NoSQL: **확장성과 가용성 우선**, 정합성은 약함

### 선택 기준

관계가 명확하고 변경 여지 X, Update가 자주 발생하는 → RDB

정확한 데이터 구조가 정해지지 않은 경우, 데이터 update가 자주 이루어지지 않고,조회가 많은 경우, 또 scale-out이 가능하므로 데이터 양이 매우 많은 경우 → NoSQL

## ✅ 3. 스키마 3계층

### 개념

사용자, 설계자, 개발자가 **데이터베이스를 보는 관점에 따라 데이터베이스를 기술하고 관계를 정의한 것**이다. 이는, **데이터의 독립성을 확보하기 위한 방법**

### 계층 구조

![image.png](attachment:e9cda30a-838e-49dc-a760-a13594bb8b79:image.png)

1. **외부 스키마 (External Schema)**
    - 사용자/앱 관점에서 보는 데이터 구조 (View)
    - 응용 프로그램이 접근하는 데이터베이스라고 하고, 관련 데이터베이스의 뷰를 표시
    - 전체 데이터가 아닌 **관심 있는 부분만 보여줌**
    - 예시
        - 직원 전체 테이블에서 “인사팀만” 보이게 필터링된 뷰
        
2. **개념 스키마 (Conceptual Schema)**
    - 테이블, 속성(컬럼), 관계, 제약조건, 데이터 타입 등 **전체 데이터베이스의 논리적 구조**를 정의
    - **모든 사용자 뷰(외부 스키마)의 기반이 되는 구조**
    - 보통 우리가 ERD, SQL 테이블 설계할 때 말하는 게 이 개념 스키마임
    - 예시
        - Employee, Department 테이블 및 그 관계(ERD 다이어그램) 등
        
3. **내부 스키마 (Internal Schema)**
    - 물리적 저장 방식 (인덱스, 파일 구조 등)
    - 데이터 저장구조, 레코드 구조, 필드 정의, 인덱스 등
    - 데이터가 실제로 **어떻게 저장되고 있는지에 대한 정의**
    - 예시
        - B+ Tree 인덱스, 해싱 방식, 클러스터드/비클러스터드 저장 등
        

## ✅ 4. 인덱스

## 🔹 B-Tree 인덱스

### 개념

- Balanced Tree(균형 트리)의 약자로, RDBMS에서 가장 일반적으로 사용하는 인덱스 구조
- 노드가 **균형을 이루는 트리**이기 때문에 **검색, 삽입, 삭제 모두 O(log N)** 시간 복잡도를 가짐
- 트리의 각 노드는 **정렬된 키 값**을 가지고 있고, 탐색 시 **왼쪽 → 오른쪽**으로 범위를 좁혀가며 탐색

### 구조

![image.png](attachment:033e213b-f2cc-474b-8ed9-50c668fdab24:image.png)

```
      [10 | 20]
     /    |    \
 [1~9] [11~19] [21~]
```

- **루트 노드 → 중간 노드 → 리프 노드**
- **리프 노드까지 가야 데이터 레코드에 접근 가능**
- 모든 키는 리프 노드에 존재하며, **리프 노드끼리는 포인터로 연결되어 있음** (범위 탐색에 유리)

### 장점

- **균형 잡힌 구조** → 성능 안정적
- **정렬된 자료 구조** → 범위 검색 가능 (`BETWEEN`, `>=`, `LIKE 'abc%'` 등)

### 단점

- 변경이 많은 테이블에서는 **인덱스 유지 비용**이 발생
- 데이터가 많아질수록 디스크 I/O 증가 가능성

## 🔹 B+Tree 인덱스

**RDBMS에서 가장 널리 쓰이는 인덱스 구조**

B-Tree를 확장한 버전이며 **모든 데이터는 리프 노드에만 저장**

### 왜 확장을 했을까?

1. B-Tree는 **내부 노드와 리프 노드 모두에 데이터 저장 가능**
    - 반면 B+Tree는 **오직 리프 노드에만 데이터 저장**
        
        → 내부 노드는 검색 경로용 키만 가지고 있어 구조가 단순하고 일관적임
        
        - 탐색 경로가 항상 일정하고 예측 가능
        - 데이터 위치가 고정되어 **I/O 효율이 높음**

2. **범위 검색에 탁월**

- B+Tree는 **리프 노드끼리 연결 리스트로 연결되어 있음**
    
    → 인접한 데이터 탐색이 매우 빠름
    
1. **디스크 기반 저장에 유리**
- DBMS는 디스크 기반으로 작동하므로, **디스크 I/O를 줄이는 게 중요**
- B+Tree는 리프 노드에만 데이터 저장 → **한 번의 리프 접근으로 데이터 확보 가능**
- 내부 노드에는 포인터와 키만 있어서 **트리의 높이를 낮게 유지 가능**

1. **더 많은 키를 담을 수 있음 → 트리 높이 낮음**
- 내부 노드에 데이터가 없기 때문에 **더 많은 키를 담을 수 있음**
- → 트리의 높이가 낮아지고 → 디스크 접근 횟수가 줄어듦 → **빠른 탐색**

### 삽입 / 삭제 / 탐색 성능

- 평균 시간 복잡도: **O(log N)**
- 삽입/삭제 시에도 균형 유지 (노드 split/merge)

### B+Tree 인덱스 흐름 요약

```
[루트]
  ↓
[중간 노드] ← 분기 조건
  ↓
[리프 노드] ← 실제 데이터 저장 + 순차 연결
```

→ **정렬된 데이터**를 탐색하고, 리프 노드 간 이동만으로 **범위 검색** 가능

### 예시 (MySQL InnoDB)

- `PRIMARY KEY`, `UNIQUE`, 일반 `INDEX` 모두 기본적으로 **B+Tree 기반**
- `InnoDB` 스토리지 엔진은 **클러스터형 인덱스 (B+Tree)** 구조를 사용

### 장점

| 항목 | 설명 |
| --- | --- |
| **검색 성능 우수** | 트리의 높이가 낮고 균형을 유지해서 탐색이 빠름 → `O(log N)` |
| **범위 검색 효율적** | 리프 노드가 **Linked List로 연결**되어 있어 `BETWEEN`, `LIKE 'abc%'` 등의 **범위 조회에 최적** |
| **디스크 I/O 최소화** | 리프 노드만 읽으면 되므로 **디스크 접근 횟수 적음** (디스크 기반 저장에 유리) |
| **일관된 탐색 경로** | 모든 데이터가 리프 노드에만 있어 **탐색 경로가 항상 일정**함 |
| **정렬된 인덱스 유지** | 정렬 기반 연산 (`ORDER BY`, `GROUP BY`) 최적화에 유리 |

### 단점

| 항목 | 설명 |
| --- | --- |
| **쓰기 성능 이슈** | 삽입/삭제 시 **노드 Split / Merge 발생 가능** → 쓰기 성능 저하 |
| **공간 사용량 증가** | 내부 노드에는 키만 저장, 데이터는 리프 노드에만 저장 → **중복 저장**에 따른 메모리 사용 증가 가능 |
| **구조 복잡성** | 트리 유지(균형 잡기, 포인터 관리 등)를 위한 **복잡한 연산 필요** |
| **짧은 레코드에는 오버헤드** | 데이터가 작을 경우, 인덱스 구조가 **오히려 공간 낭비**로 이어질 수 있음 |

## 🔹 복합 인덱스 (Composite Index)

### 개념

- **두 개 이상의 컬럼을 묶어서 하나의 인덱스**로 생성한 것
- `CREATE INDEX idx_name ON table(col1, col2);` 와 같은 방식

### 특징: **선두 컬럼 원칙**

- 인덱스는 **왼쪽(선두) 컬럼부터 순서대로만 작동**
- 예: `(name, age)` 라는 인덱스가 있다면,
    - `WHERE name = 'Kim'` → 사용 가능 (O)
    - `WHERE name = 'Kim' AND age = 20` → 사용 가능 (O)
    - `WHERE age = 20` → **사용 불가 (X)**

> 이유는 B-Tree의 키가 name → age 순서로 정렬되어 있어서, name 기준 없이 age로는 인덱스를 활용할 수 없음
> 
- **복합 인덱스 예시 시각화**
    
    간단한 도식 예시를 추가해보면 가독성이 훨씬 좋아져:
    
    ```
    text
    복사편집
    복합 인덱스 (name, age)
    
    ┌─────────────┐
    │  name = A   │ ─→ age = 20, 21, ...
    ├─────────────┤
    │  name = B   │ ─→ age = 18, 30, ...
    └─────────────┘
    
    - WHERE name=‘A’ → 인덱스 타고 접근
    - WHERE age=20 → name 없이 탐색 불가
    
    ```
    
- **인덱스가 타지 못하는 조건**
    - `LIKE '%keyword'` → **인덱스 사용 못함**
    - `OR 조건 다수` → 부분만 인덱스 타거나 전체 무효화될 수 있음

## 🔹 성능 유의사항

### 인덱스가 많을수록 좋은가?

- **NO! 인덱스가 많을수록 쿼리 성능이 느려질 수 있음**
    - 인덱스는 **읽기에는 빠르게**, **쓰기에는 부하**
    - `INSERT`, `UPDATE`, `DELETE` 시 **모든 인덱스를 같이 수정해야 하므로** 성능 저하 발생
    - → 인덱스는 **조회 쿼리 비중이 높은 컬럼에만 선택적으로 적용**

### 인덱스를 적용할 컬럼은?

- 자주 조회되는 컬럼 (`WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`에 많이 사용)
- **선택도가 높은 컬럼**
    
    → 값의 다양성이 높은 컬럼 (`gender`는 선택도 낮음, `user_id`는 선택도 높음)
    

### 범위 조건에서 인덱스 주의점

- 예: `WHERE A = ? AND B > ?`
    - 복합 인덱스에서 **범위 조건이 뒤에 나오면 효율이 떨어짐**
    - **범위 조건 이후의 컬럼은 인덱스를 타지 못함**

## 정리

| 항목 | 설명 |
| --- | --- |
| **B-Tree 인덱스** | 루트-중간-리프 구조, 정렬된 트리 |
| B+Tree 인덱스 | B-Tree의 확장. 리프 노드에만 데이터 저장, 리프끼리 연결 |
| **복합 인덱스** | 여러 컬럼을 조합한 인덱스 (선두 컬럼 순서 중요) |
| **주의사항** | 인덱스 과도하면 쓰기 성능 저하, 범위 조건 유의 |

## ✅ 5. 정규화 (Normalization)

정규화(Normalization)는 데이터의 **중복을 제거**하고, **데이터의 일관성과 무결성을 유지**하기 위한 **테이블 분해 과정**

## 🔹 1NF (제1정규형): **원자값만 저장**

### ❌ 비정규형 테이블 (중첩된 값 존재)

| 학번 | 이름 | 수강과목 |
| --- | --- | --- |
| 1001 | 철수 | DB, 운영체제 |
| 1002 | 영희 | 자료구조 |
- **수강과목**에 **복수 값이 포함** → 비정규형

### 1NF 변환 결과

| 학번 | 이름 | 수강과목 |
| --- | --- | --- |
| 1001 | 철수 | DB |
| 1001 | 철수 | 운영체제 |
| 1002 | 영희 | 자료구조 |

하나의 셀에는 **한 개의 값(원자값)**만 들어가야 함

## 🔹 2NF (제2정규형): **부분 함수 종속 제거**

- **기본키가 복합키**일 때, **일부 키에만 의존하는 컬럼** 제거

### ❌ 문제 예시

| 학번 | 과목명 | 교수명 |
| --- | --- | --- |
| 1001 | DB | 홍길동 |
| 1001 | OS | 이몽룡 |
| 1002 | DB | 홍길동 |
- 기본키: (학번, 과목명)
- `교수명`은 **과목명**에만 의존 → **부분 종속**

### 2NF 변환

- 수강 테이블

| 학번 | 과목명 |
| --- | --- |
| 1001 | DB |
| 1001 | OS |
| 1002 | DB |
- 과목 테이블

| 과목명 | 교수명 |
| --- | --- |
| DB | 홍길동 |
| OS | 이몽룡 |

## 🔹 3NF (제3정규형): **이행적 함수 종속 제거**

- 기본키가 아닌 속성이 **다른 속성에 종속될 경우 분리**

### ❌ 문제 예시

| 사번 | 부서코드 | 부서이름 |
| --- | --- | --- |
| 101 | D01 | 개발팀 |
| 102 | D02 | 기획팀 |
- `부서이름`은 **사번 → 부서코드 → 부서이름**의 **이행적 종속**

### 3NF 변환

- 사원 테이블

| 사번 | 부서코드 |
| --- | --- |
| 101 | D01 |
| 102 | D02 |
- 부서 테이블

| 부서코드 | 부서이름 |
| --- | --- |
| D01 | 개발팀 |
| D02 | 기획팀 |

## 🔹 이상 현상 (Anomaly)

정규화하지 않으면 아래 문제가 발생함:

| 종류 | 설명 | 예시 |
| --- | --- | --- |
| **삽입 이상** | 일부 정보만 삽입 불가 | 과목을 추가하려면 학생 정보도 넣어야 함 |
| **삭제 이상** | 불필요한 데이터까지 삭제 | 마지막 학생이 수강 취소 → 과목 정보도 사라짐 |
| **갱신 이상** | 중복된 정보 일괄 수정 어려움 | 교수명이 바뀌면 모든 튜플을 수정해야 함 |

## 🔹 역정규화 (Denormalization)

### 정의

정규화를 통해 쪼개진 테이블을 **다시 합쳐 중복을 허용**하는 것

→ **조회 성능 향상**, **JOIN 연산 감소** 목적

### 역정규화 예시

- **정규화 구조** (3NF)

```
학생 테이블       수강 테이블       과목 테이블
[학번, 이름]     [학번, 과목코드]   [과목코드, 과목명, 교수명]

```

- → 성적 조회 시 3개의 테이블을 JOIN해야 함

### 🔁 역정규화 구조

| 학번 | 이름 | 과목코드 | 과목명 | 교수명 |
| --- | --- | --- | --- | --- |
| 1001 | 철수 | DB01 | DB | 홍길동 |

자주 사용하는 조회는 하나의 테이블로 만들어 캐시처럼 운용