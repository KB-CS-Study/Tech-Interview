# 키(key) / RDB vs NoSQL / 스키마 / 인덱스 / 정규화
과목: 데이터베이스

목차

## 🗃️ 키
![image](https://github.com/user-attachments/assets/60f948a8-2fce-4b2b-9fc0-34377f3c7b2e)


### 기본키(Primary Key)

- 테이블의 각 행을 유일하게 식별하는 키
- null, 중복 불가
- 하나의 테이블에 하나만 존재

### 후보키(Candidate Key)

- 기본키가 될 수 있는 후보키
- 여러 개 존재 가능, 모든 후보키는 유일성(각 행을 유일하게 식별 → 중복안됨)과 최소성 보장

### 외래키(Foreign Key)

- 다른 테이블의 기본키를 참조하는 키
- 관계형 데이터 모델에서 테이블 간 관계 표현
- 부모 테이블의 기본키를 자식 테이블이 참조

---

## 🗃️ RDB vs NoSQL
![image](https://github.com/user-attachments/assets/090854da-af63-4ba9-a224-dffe0fb5e671)


### RDBMS

관계형 데이터베이스 관리 시스템

모든 데이터를 2차원의 열과 행(테이블)의 형태로 표현

- 수직 확장 중심(Scale-up)
- 정형 데이터, 복잡한 관계형 모델

**장점**

✔ 정해진 스키마에 따라 명확한 데이터 구조 보장

✔ 각 데이터를 중복 없이 저장 -> 데이터 무결성 보장

### **RDBMS 적합 예시**

🔹 **일반적인 웹 서비스 (쇼핑몰, 블로그, 예약 시스템 등)**

- **RDBMS 사용 (예: MySQL, PostgreSQL)**
- 이유:
    - 고객 ↔ 주문 ↔ 상품 등 **명확한 관계**가 존재
    - **정확성, 무결성, 트랜잭션**이 중요
    - JPA 같은 ORM과 잘 연동

<br>

### NoSQL

비관계형 데이터베이스

RDBMS가 갖고 있는 특성뿐만 아니라 다른 특성들도 부가적으로 지원

- 수평 확장 중심(Scale-out)
- 비정형 데이터, 빠른 읽기/쓰기, 유연한 구조

**장점**

✔ 스키마 X, 유연성 -> 언제든 데이터 조정과 새로운 필드 추가 가능

### **NoSQL 적합 예시**

🔹 **실시간 채팅, 메신저, 알림 서비스**

- **NoSQL 사용 (예: MongoDB)**
- 이유:
    - 메시지 형식이 다양하고 유연
    - 빠른 쓰기/읽기가 중요
    - RDBMS로 처리 시 JOIN이 많아 느려질 수 있음

***정리***

> **RDBMS**는 정형화된 데이터와 관계 중심의 모델에 강하고, 
**NoSQL**은 유연한 구조와 대용량 처리에 최적화된 비관계형 DB
> 

---
<br>

## 🗃️ 스키마

데이터베이스의 구조와 제약조건에 관해 전반적인 명세를 기술한 것, 메타 데이터
![image](https://github.com/user-attachments/assets/a040119d-5dba-45ef-b18a-3e286438fb30)


### 외부 스키마(사용자 뷰)

- 사용자나 응용프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
- 서브 스키마
- 질의어를 이용하여 DB를 쉽게 사용 가능

### 개념 스키마(전체적인 뷰)

- 데이터베이스의 전체적인 논리적 구조
- 모든 응용 프로그램이나 사용자들이 필요로하는 데이터를 종합한 조직 전체의 데이터베이스

### 내부 스키마(저장 스키마)

- 물리적 저장장치의 입장에서 본 데이터베이스 구조
- 물리적 저장장치와 밀접한 계층
- 레코드의 물리적인 구조 정의

---
<br>


## 🗃️ 인덱스

추가적인 쓰기 작업과 저장 공간을 활용하여, 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
![image](https://github.com/user-attachments/assets/2c7aba45-b913-44f0-89bf-88e646387b4a)


### 

**[인덱스를 사용하면 좋은 경우]**

- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼
- 기타 등등

### B+Tree 인덱스

- **대부분의 RDBMS가 사용하는 기본 인덱스 구조**
- 정렬된 트리 형태의 자료구조
- **모든 데이터는 리프(leaf) 노드에만 저장**
- 리프 노드끼리는 **연결 리스트**로 연결되어 있어 **범위 검색(RANGE SCAN)**에 유리함

### 인덱스 종류
![image](https://github.com/user-attachments/assets/97657889-ebad-4c60-9826-925ee471d940)


*복합 인덱스는 왼쪽부터 순서를 지켜야 함

<br>

### 인덱스 성능

**장점**

- 빠른 검색 : B+Tree 기반 구조로 인해 검색 속도는 O(log N) 수준
- 디스크 I/O 감소 : 필요한 레코드만 빠르게 찾아 접근 가능
- 정렬 비용 감소 : ORDER BY에 맞는 인덱스가 있으면 정렬 생략 가능
- JOIN 최적화 : 조인 키에 인덱스가 있을 경우 훨씬 빠름

**성능 저하 요소**

- 잦은 데이터 변경
- 디스크 공간 증가
- 잘못된 인덱스 설계
- 중복값이 많은 컬럼

<br>

## 🗃️ 정규화

데이터베이스를 중복 없이, 논리적이고 효율적인 구조로 구성하는 과정

### 1NF (제 1 정규형)

**모든 컬럼의 값은 원자값(더 이상 나눌 수 없는 단위)이어야 한다.**

- 테이블의 각 컬럼은 하나의 값을 가져야 함
- **중첩된 값(리스트, 배열 등)** 제거

### 2NF (제 2 정규형)

**1NF 만족 + 기본키의 일부분에만 종속된 컬럼 제거**

- 복합 기본키(A, B)의 경우, 컬럼이 A 또는 B에만 의존하면 문제
- **부분 종속 → 별도 테이블로 분리**

### 3NF (제 3 정규형)

**2NF 만족 + 기본키가 아닌 다른 컬럼을 통해 또 다른 컬럼이 결정되는 종속 제거**

- **기본키가 아닌 컬럼이 또 다른 컬럼을 결정하면** 문제

### 이상현상(Anomaly)

: 정규화를 하지 않았을 때 발생하는 문제점

- 삽입 이상 : 일부 정보만으로 데이터 삽입 불가
- 갱신 이상 : 중복된 데이터를 모두 갱신해야함
- 삭제 이상 : 하나의 데이터 삭제 시 다른 유용한 정보까지 삭제됨

### 역정규화(Denormalization)

: 성능 개선을 위해 정규화를 부분적으로 되돌리는 작업

- 조인(Join) 횟수가 많아질 경우 성능 저하 발생
- 중복을 일부 허용하고 **읽기 속도를 높이는** 목적
- 예: 주문 테이블에 고객 주소 중복 저장
