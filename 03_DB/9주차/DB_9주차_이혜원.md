✔ 스터디 주제: 키(Key) + RDB vs NoSQL + 스키마 + 인덱스 + 정규화

기초 총정리!

### 기본키/후보키/외래키 차이

![image.png](attachment:f263f5f0-e2a4-4ff6-a44e-b30f73a8d78b:image.png)

- **기본 키 (Primary Key)**
    - 정의 : 테이블 내에서 각 행(Row)을 **유일하게 식별**하기 위해 사용되는 키.
    - 특징
        - NULL 불가, 중복 불가(`유일성`), `최소성`
    - 예시 : `학번`을 기본 키로 선택할 수 있음
- **후보 키 (Candidate Key)**
    - 정의 : `기본키`로 사용할 수 있는 후보들
    - 특징
        - 테이블 내에서 `유일성`과 `최소성`을 만족하는 속성(컬럼)
        - 하나 이상의 후보 키 중에서 하나를 선택하여 기본키로 사용
    - 예시 : `학번`과 `주민번호`는 후보 키가 될 수 있음.
- **외래 키 (Foreign Key)**
    - 정의 : 다른 테이블을 참조하기 위해 사용되는 속성
    - 특징
        - 두 테이블 간 관계를 연결해주는 역할
        - 참조 무결성을 유지해야 함
            - 참조하는 값이 상대 테이블에 반드시 존재해야 한다(삭제/수정 제한)
    - 예시 : `수강 테이블`에서 학생을 참조하는 `학번` 필드.

# NOSQL이란?

- 정의
    - 전통적인 관계형 데이터베이스 관리 시스템(RDBMS)과는 다른 방식으로 데이터를 저장하고 관리하는 데이터베이스 시스템
    - "NoSQL"은 "Not Only SQL"의 약자로, SQL만을 고집하지 않는 유연한 구조를 의미
    - 관계형 데이터베이스의 한계를 극복하고자 개발된 다양한 데이터베이스 유형을 포함한다.

### NoSQL 데이터베이스의 주요 특징

1. **`스키마 유연성`**
    - 컬럼이나 데이터 구조를 사전에 정의할 필요 없음. JSON처럼 자유롭게 저장 가능.
2. **`수평 확장성`**
    - 노드를 추가하여 데이터 처리 능력을 높임. 빅데이터 환경에서 특히 유리
3. **`다양한 데이터 모델`**
    - 사용 목적에 따라 키-값, 문서, 열, 그래프 등 다양한 형태의 DB 구조 제공
4. **`높은 성능`**
    - NoSQL 데이터베이스는 대량의 데이터를 빠르게 읽고 쓸 수 있도록 최적화되어 있으며, 고성능 처리를 지원

### NoSQL 데이터베이스의 유형

| **유형** | **예시** | **특징** |
| --- | --- | --- |
| 키-값 저장소 | Redis, DynamoDB | 가장 단순한 구조. 캐시/세션에 탁월. |
| 문서 저장소 | MongoDB, CouchDB | JSON 문서 기반. 유연한 구조. 복잡한 쿼리 지원. |
| 열 지향 저장소 | Cassandra, HBase | 열 단위 저장. 대규모 분석, 시계열 데이터에 유리. |
| 그래프 DB | Neo4j, Amazon Neptune | 노드-엣지 모델. 관계 기반 추천/소셜 네트워크에 강력. |

### NoSQL 데이터베이스의 장점

1. **`확장성`**: 수평 확장성을 통해 데이터와 트래픽 증가에 따라 쉽게 확장할 수 있다.
2. **`유연성`**: 고정된 스키마가 없어서 데이터 모델 변경이 용이
3. **`고성능`**: 대규모 데이터를 빠르게 처리할 수 있도록 설계
4. **`다양한 데이터 모델 지원`**: 애플리케이션 요구사항에 맞는 다양한 데이터 모델을 제공하여, 특화된 데이터 처리에 적합

### NoSQL 데이터베이스의 단점

1. **`복잡한 트랜잭션 지원 부족`**: 대부분의 NoSQL 데이터베이스는 관계형 데이터베이스만큼 복잡한 트랜잭션을 지원하지 않는다
2. **`학습 곡선`**: 관계형 데이터베이스에 익숙한 사용자에게는 새로운 개념과 사용법을 익히는 데 시간이 필요할 수 있다.
3. **`성숙도`**: 일부 NoSQL 데이터베이스는 상대적으로 새로운 기술로, 커뮤니티 지원이나 도구가 부족

### NoSQL 데이터베이스의 활용 사례

- **빅데이터 분석**: 로그 수집, 사용자 행동 분석
- **웹/모바일 앱**: 빠른 데이터 처리, 유연한 구조 필요할 때
- **IoT 시스템**: 센서 데이터 실시간 처리
- **추천 시스템 / 소셜 네트워크**: 그래프 DB 기반 관계 처리

### NoSQL과 RDB의 선택 기준과 구조 차이

| **항목** | **NoSQL (비관계형 DB)** | **RDB (관계형 DB)** |
| --- | --- | --- |
| **데이터 구조** | JSON, 키-값, 열, 그래프 등스키마 유연함 | 테이블(행/열) 기반스키마 엄격 |
| **정합성(무결성)** | 정합성 약함 (CAP 중 CP 또는 AP 중심) | 트랜잭션(ACID) 강력 지원 |
| **관계 표현** | JOIN 없음. 중첩 구조로 저장 | JOIN으로 다양한 테이블 연결 |
| **확장성** | 수평 확장(Scale-out) 최적화 | 수직 확장(Scale-up) 위주 |
| **쿼리 언어** | 각 DB마다 다름 (MongoDB, Cassandra 쿼리 등) | SQL (표준화됨) |
| **적합 분야** | 실시간 처리, 빅데이터, 캐시IoT, 소셜, 로그 등 | 전통적인 업무 시스템금융, ERP, 회계 |

> 🔸 **대용량 + 빠른 처리 + 유연한 구조 → NoSQL**
>

> 🔹 **정형 데이터 + 강한 정합성 + 복잡한 관계 → RDB**
>

### 스키마 3계층(외부/개념/내부)

### 스키마 종류별 상세 설명

1. **외부 스키마 (External Schema)**
    - **설명**: 데이터베이스의 특정 사용자나 애플리케이션 관점에서 데이터의 부분집합을 정의하며, 사용자별 뷰(View)를 포함
    - **특징**
        - 데이터베이스의 보안과 접근 제어를 위해 사용됩니다.
        - 각 사용자가 필요로 하는 데이터만 접근할 수 있게 합니다.
    - **예시**: 특정 부서나 사용자가 필요로 하는 데이터만을 제공하는 뷰
        - 직원 급여 정보를 보지 못하는 일반 직원용 뷰
2. **개념 스키마 (Conceptual Schema)**
    - **설명**: 데이터베이스의 전체적인 구조를 나타내며, 데이터베이스 설계의 높은 수준에서 개체(Entity)와 그 관계(Relationship)를 정의
    - **특징**
        - 데이터베이스의 논리적 설계를 나타냄
        - 사용자가 데이터베이스를 어떻게 이해할지에 초점을 맞춤
    - **예시**: 모든 테이블과 그 관계를 포함하는 ER 다이어그램
3. **논리 스키마 (Logical Schema)**
    - **설명**: 특정 데이터베이스 관리 시스템(DBMS)에서 구현될 논리적 구조를 정의하며, 테이블, 뷰, 인덱스, 제약 조건 등을 포함
    - **특징**
        - 데이터베이스의 논리적 데이터 모델을 정의
        - DBMS에 독립적
    - **예시**
        - CREATE TABLE, CREATE VIEW 등의 SQL 명령문을 통해 정의된 테이블 구조와 관계

### 

### 인덱스

- 인덱스의 개념

  ![](https://velog.velcdn.com/images/hyeni/post/4ea8ed4a-2d56-439a-be83-647374f31340/image.png)

- 인덱스의 장점
    - 검색 속도 향상
    - 시스템 전체 성능 향상
- 단점
    - 추가적인 공간 필요
    - 처음 인덱스 생성시 많은 시간 소요
    - 데이터 변경 작업(insert, update, delete)이 자주 일어날 경우 성능 저하
- 종류
    - `클러스터형 인덱스`
        - 행 데이터를 자신의 열을 기준으로 정렬함
        - 테이블 당 하나만 생성 가능
    - `보조 인덱스`
        - 별도의 공간을 추가하여 지정한 컬럼만 정렬하여 인덱스를 운영
        - 컬럼 단위로 여러 개의 인덱스 생성 가능
- 자동으로 생성되는 인덱스
    - Primary key 제약 조건
        - 클러스터형 인덱스 자동 생성
    - Unique 제약 조건
        - 보조 인덱스 자동 생성
    - Primary Key가 없고 Unique, Not Null 제약 조건이 설정된 경우
        - 클러스터형 인덱스로 생성
- 인덱스 확인
    - SHOW INDEX FROM 테이블명

### `B-Tree(Balanced Tree, 균형트리)`

- 정의

  데이터를 정렬된 트리 형태로 관리하며, 빠르게 원하는 값을 찾을 수 있도록 도와주는 인덱스 구조

- 특징
    - 키 값이 정렬된 상태로 노드에 저장
    - 루트 → 중간 노드 → 리프 노드까지 내려가며 이진 탐색처럼 검색
    - 성능 : O(log n) 속도로 빠른 검색, 삽입, 삭제

### 구조

```sql
        [30]
       /    \
  [10,20]  [40,50]
```

- 리프/내부 노드에 **값이 모두 저장**됨
- 범위 탐색 시 다시 트리 탐색 필요

### B+Tree 구조(실제 DB 인덱스 구조)

> B-Tree를 확장한 구조로, 리프 노드에만 데이터를 저장하고,
리프 노드끼리 연결되어 있어 **범위 조회와 정렬에 최적화된 인덱스 구조**
>

```sql
        [30]
       /    \
     [10]   [40]
      ↓       ↓
    [10]—[20]—[30]—[40]—[50]
   (리프 노드들끼리 연결됨)
```

- **리프 노드에만 값 저장**
- 리프 노드끼리 연결되어 있어서 → 범위 조회/정렬에 유리

- **B+Tree 인덱스 흐름 요약**

    ```
    [루트]
      ↓
    [중간 노드] ← 분기 조건
      ↓
    [리프 노드] ← 실제 데이터 저장 + 순차 연결
    
    ```


→ **정렬된 데이터**를 탐색하고, 리프 노드 간 이동만으로 **범위 검색** 가능

### 정규화 1~3NF, 이상현상, 역정규화 판단

### **1. 이상현상(Anomalies) 종류와 설명**

| 종류 | 설명 | 예시 |
| --- | --- | --- |
| **삽입 이상 (Insert Anomaly)** | 데이터를 일부만 추가하고 싶은데 불필요한 값까지 넣어야 할 때 | 새로운 강좌 추가 시 학생 정보가 없어서 등록 불가 |
| **삭제 이상 (Delete Anomaly)** | 한 데이터를 삭제하면 다른 중요한 정보도 함께 삭제될 때 | 어떤 학생이 수강 철회 시 해당 강좌 정보도 사라짐 |
| **갱신 이상 (Update Anomaly)** | 하나의 데이터를 수정할 때 여러 군데를 모두 변경해야 할 때 | 교수 이름이 바뀌면 여러 행의 교수명 모두 수정해야 함 |

### 정규화 필요성 요약

- **데이터 무결성 확보**: 동일한 정보는 한 곳에만 저장
- **유지보수 용이성**: 갱신, 삭제, 삽입이 용이
- **중복 제거**: 스토리지 절약 및 성능 향상
- **관계형 모델에 적합한 구조 제공**

### 정규화 필요성

- **데이터 무결성 확보**: 동일한 정보는 한 곳에만 저장
- **유지보수 용이성**: 갱신, 삭제, 삽입이 용이
- **중복 제거**: 스토리지 절약 및 성능 향상
- **관계형 모델에 적합한 구조 제공**

---

## 정규화 전체 요약 테이블

| 정규형 | 제거 대상 | 주요 조건 | 핵심 변화 |
| --- | --- | --- | --- |
| 1NF | 반복/다치값 | 원자값 유지 | 셀 분해 |
| 2NF | 부분 종속 | 기본키 전체에 종속 | 부분 종속 속성 분리 |
| 3NF | 이행 종속 | 기본키 외 속성 간 종속 제거 | 중간 속성 분리 |
| BCNF | 후보키 아닌 결정자 | 모든 결정자는 후보키 | 결정자 기준 테이블 재조정 |
| 4NF | 다치 종속 | 다치 종속은 슈퍼키로만 결정 | 다치 종속 테이블 분리 |
| 5NF | 조인 종속 | 조인은 후보키 기반으로만 복원 가능해야 함 | 불필요한 조합 제거 |

---

## 제1정규형 (1NF): 원자값으로 분해

| 학생ID | 학생명 | 연락처 | 수강과목 | 교수명 |
| --- | --- | --- | --- | --- |
| 1001 | 철수 | 010-1111 | DB | 김영희 |
| 1001 | 철수 | 010-1111 | 알고리즘 | 이철수 |
| 1002 | 영희 | 010-2222 | DB | 김영희 |
- **변화 요점**: 반복 속성 제거, 하나의 셀에 하나의 값만
- **한계**: 중복 여전, 일부 속성은 **부분 함수 종속** 존재

---

## 제2정규형 (2NF): 부분 종속 제거 (서브 테이블 분리)

1. **학생(Student)**

| 학생ID | 학생명 | 연락처 |
| --- | --- | --- |
| 1001 | 철수 | 010-1111 |
| 1002 | 영희 | 010-2222 |
1. **수강(Student_Subject)**

| 학생ID | 수강과목 | 교수명 |
| --- | --- | --- |
| 1001 | DB | 김영희 |
| 1001 | 알고리즘 | 이철수 |
| 1002 | DB | 김영희 |
- **변화 요점**: 기본키(학생ID + 수강과목)에 종속되지 않는 속성(이름, 연락처)을 분리
- **한계**: **이행 종속** 존재 가능

---

## 제3정규형 (3NF): 이행함수 종속제거

### 🎯 추가 분해 테이블

1. **과목(Subject)**

| 과목명 | 교수명 |
| --- | --- |
| DB | 김영희 |
| 알고리즘 | 이철수 |
1. **수강(Student_Subject)**

| 학생ID | 과목명 |
| --- | --- |
| 1001 | DB |
| 1001 | 알고리즘 |
| 1002 | DB |
- **변화 요점**: 교수명은 과목명에만 종속 → 이행 종속 제거
- **이점**: 교수명 변경 시 1개 테이블만 수정

---

## 정리

| 항목 | 내용 |
| --- | --- |
| **정의** | 모든 결정자가 후보키여야 한다 |
| **목표** | 제3정규형보다 더 강력한 중복 제거 |
| **위반 예** | 후보키가 아닌 속성(예: 교수)이 결정자가 되는 경우 |
| **해결 방법** | 문제 되는 결정자를 기준으로 테이블 분해 |
| **3NF와 차이** | 3NF는 결정자가 꼭 후보키일 필요는 없음, BCNF는 반드시 후보키여야 함 |

### 언제 BCNF를 꼭 써야 할까?

- 정규화가 잘 돼 있다고 생각했는데도 **중복이 사라지지 않을 때**
- 제3정규형까지 했지만 **후보키 아닌 속성이 결정자 역할을 할 때**

---

### 역정규화

- 정의
    - 정규화된 데이터 모델에서 **조회 성능을 높이고 복잡한 JOIN을 줄이기 위해** 중복을 감수하고 테이블을 병합하거나 컬럼을 추가하는 데이터베이스 설계 기법
- 정규화의 `문제점`
    - 정규화가 ‘항상 좋은 것’이 아니다.
    - 너무 많은 테이블이 분리되면 JOIN이 남발될 수 있음 → 성능 저하 → 쿼리 복잡도 증가 → 유지 보수 부담

| **상황** | **설명** | **예시** |
| --- | --- | --- |
| **조회 속도가 중요한 경우** | 실시간 대시보드, 검색 엔진 등 | 사용자 조회용 테이블에 주소, 등급 등 중복 포함 |
| **같은 JOIN 쿼리가 자주 반복될 경우** | 항상 A → B → C 테이블 JOIN하는 경우 | 주문 테이블에 상품명, 가격 등 복제 |
| **보고서/통계 집계용 테이블** | 계산된 결과를 자주 쓰는 경우 미리 저장 | 주간 매출 합계 테이블 생성 |
| **읽기 위주 시스템(OLAP)** | 분석 시스템, BI 도구 등 | 가공된 데이터로 구성된 VIEW 테이블 |
| **분산 DB 환경 (NoSQL 등)** | JOIN 불가능하거나 느림 | MongoDB에서 회원 정보 중복 저장 허용 |

### **정규화된 구조**

- user(id, name)
- order(id, user_id, product_id)
- product(id, name, price)

> → 주문 리스트 하나 보여주려면 항상 2~3개의 JOIN 필요
>

---

### **역정규화한 구조**

- order(id, user_id, user_name, product_name, product_price)

> → JOIN 없이도 주문 목록 한 번에 출력 가능
>