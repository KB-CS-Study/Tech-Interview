# 기본키/후보키/외래키

데이터베이스에서 **데이터의 식별과 관계 설정**을 위해 사용하는 중요한 개념

ex. 

| 학번 | 주민등록번호 | 이메일 | 이름 |
| --- | --- | --- | --- |
| 2023001 | 990101-1234567 | [hong@abc.com](mailto:hong@abc.com) | 홍길동 |
| 2023002 | 981212-2345678 | [kim@abc.com](mailto:kim@abc.com) | 김영희 |
| 2023003 | 000101-3456789 | [park@abc.com](mailto:park@abc.com) | 박준형 |
- 후보키
    - 학번
    - 주민등록번호
    - 이메일
- 기본키 : 위의 3개 중 하나를 지정

## 기본키

- 한 테이블에서 각 행을 유일하게 구별하는 키
- 한 테이블에 단 하나만 설정할 수 있음
- 자연스러운 기본 키를 찾을 수 없는 경우에는 인위적인 키 애트리뷰트를 릴레이션에 추가할 수 있음

➡️ 최소성 & 유일성 만족

## 후보키

- 한 테이블에서 각 행을 유일하게 구별하는 최소한의 애트리뷰트들의 모임
    - ex. (신용카드번호, 주소)는 신용카드 회사의 고객 릴레이션의 후보키가 아니지만 (신용카드번호)는 후보키
- 여러 개 존재할 수 있으며, 이 중 하나를 기본키로 선택
- 후보키가 두 개 이상의 애트리뷰트로 이루어진 경우 → 복합키
    - ex. (학번, 과목번호)가 후보키 → 각각 하나만으로 고유하게 식별이 안되기 때문에 두 개가 다 필요

➡️ 최소성 & 유일성 만족

## 외래키

- 다른 테이블의 기본키를 참조하는 키
- 관계 데이터베이스에서 릴레이션들 간의 관계를 나타내기 위해서 사용됨
- 외래 키 애트리뷰트는 참조되는 릴레이션의 기본 키와 동일한 도메인을 가져야 함

![Image](https://github.com/user-attachments/assets/45538037-a399-409f-b53d-69ad219d75ad)

# NoSQL과 RDB

## RDB란?

- 가장 많이 사용되고 있는 데이터베이스 중 하나
- 관계형 데이터베이스
- 테이블 형태로 데이터를 저장하며 테이블 간의 관계는 외래키를 사용해서 정의함
- 엄격한 스키마를 가짐 → 데이터 구조와 타입을 미리 정의해야 하며, 데이터의 변경이 필요한 경우 스키마 변경이 복잡할 수 있음.
- 데이터를 조작하기 위해 SQL을 사용함
- ACID(원자성, 일관성, 고립성, 지속성)을 준수해서 데이터의 일관성과 무결성을 보장함
- 수평적 확장이 어려워서 대부분 수직적 확장이 이루어짐
- 데이터 저장 예시

![Image](https://github.com/user-attachments/assets/fb25f4c2-1fc8-432f-a02e-f76b9e0f2eb7)

→ 두 테이블은 고객 id로 관계를 맺고 조인할 수 있음

## NoSQL이란?

- 다양한 형태의 데이터 모델을 사용
    - 키-값, 문서, 그래프 등
- 유연한 스키마를 가짐 → 필요한 속성을 동적으로 추가 가능, 스키마 변경이 간단, 다양한 형태의 데이터를 수용 가능
- SQL 대신 데이터베이스 마다 다양한 쿼리 언어를 사용함.
- 몇몇 NoSQL 데이터베이스는 ACID 원칙을 준수하지만 모든 NoSQL 데이터베이스가 이를 보장하지는 X
- 수평적 확장이 용이함
- 데이터 저장 예시

![Image](https://github.com/user-attachments/assets/700ba172-fb5e-4f45-a549-068ec9ec4fa8)

→ 주문 정보가 문서 안에 중첩되어 있으며, 조인 없이 한 번에 조회 가능

## NoSQL과 RDB의 구조 차이

| 항목 | RDB (관계형 데이터베이스) | NoSQL (비관계형 데이터베이스) |
| --- | --- | --- |
| 데이터 저장 구조 | 테이블(Table) 기반→ 행(Row), 열(Column) 구성 | 유형에 따라 다양: 문서형, 키-값, 컬럼형, 그래프형 |
| 스키마 | 고정된 스키마 (정형 데이터)→ 컬럼명과 데이터형 사전에 정의 | 스키마가 유연하거나 없음→ 데이터 구조가 자유로움 |
| 데이터 관계 | 테이블 간 외래키(FK)로 관계 설정 | 일반적으로 관계 없음→ 중첩 구조나 중복 데이터 사용 |
| 데이터 접근 방식 | SQL 사용 (표준화된 쿼리 언어) | 쿼리 방식은 데이터베이스별로 다름→ JSON 기반 질의 등 |
| 확장성 | 주로 수직 확장(서버 성능 업그레이드) | 기본적으로 수평 확장 지원(분산 처리에 적합) |
| 트랜잭션 처리 | ACID 지원 → 데이터 일관성 보장 | 대부분 BASE 모델 → 일관성보다는 가용성 중시 |

## NoSQL과 RDB의 선택 기준

### 언제 RDB를 선택할까?

- 데이터 구조가 명확하고 관계가 중요할 때
    
    예: 고객 ↔ 주문, 학생 ↔ 수강 과목
    
- 일관성이 매우 중요한 경우
    
    예: 금융 서비스, 병원, 회계 시스템
    
- 복잡한 쿼리/조인/트랜잭션이 자주 필요한 경우

### 언제 NoSQL을 선택할까?

- 데이터 구조가 자주 바뀌거나 유동적일 때
    
    예: JSON, 로그 데이터, 사용자 행동 분석
    
- 대량의 데이터를 빠르게 저장하고 조회해야 할 때
    
    예: SNS 피드, 채팅 앱, 실시간 게임 서버
    
- 수평 확장성과 분산 처리가 중요한 경우
    
    예: 클라우드 기반 마이크로서비스 아키텍처
    

# 스키마 3계층(외부/개념/내부)

🔍 데이터베이스 시스템에서 데이터 독립성을 보장하기 위해 제안된 개념

- ANSI-SPARC 모델이라고도 불림
- 데이터베이스를 외부 스키마, 개념 스키마, 내부 스키마의 세 계층으로 나눔

## 1. 외부 스키마

🔍 데이터베이스의 각 사용자가 보는 데이터의 뷰

- 특징:
    - 여러 부류의 사용자를 위해 동일한 개념 단계로부터 다수의 서로 가른 뷰가 제공될 수 있음
    - 일반적으로 최종 사용자는 데이터베이스의 일부분에만 관심을 가짐
- 예시: 사용자의 관점에서 본 주택의 뷰

## 2. 개념 스키마 (Conceptual Schema)

🔍 데이터베이스에 대한 사용자 공동체의 뷰

- 특징:
    - 물리적인 구현은 고려하지 않으면서 조직체 전체에 대한 스키마를 포함
    - 데이터베이스에 어떤 데이터가 저장되어 있으며, 어떤 관계가 존재하고, 어떤 무결성 제약 조건들이 명시되어 있는가를 기술함
    - 데이터베이스마다 오직 한 개의 개념 스키마가 존재함
- 예시: 집의 구조

## 3. 내부 스키마 (Internal Schema)

🔍 실제의 물리적인 데이터 구조에 대한 스키마

- 특징:
    - 데이터베이스에 어떤 데이터가 어떻게 저장되어 있는가를 기술함
    - 인덱스, 해싱 등과 같은 접근 경로, 데이터 압축 등을 기술함
- 예시: 전체 모든 단지의 뷰

## 계층 간 관계

- 외부 ↔ 개념: **논리적 데이터 독립성** → 개념 스키마 변경 시 외부 스키마 영향 없음
    - ex. 회사에서 기존 `고객` 테이블에 `고객 등급` 컬럼을 추가했을 때, 기존에 고객 이름과 연락처만 사용하던 부서나 프로그램은 아무 수정 없이 그대로 동작 가능.
- 개념 ↔ 내부: **물리적 데이터 독립성** → 내부 구조 변경 시 개념 스키마 영향 없음
    - ex. `고객` 테이블에 인덱스를 새로 추가하거나, 데이터를 SSD에서 분산 저장소로 이전하더라도 테이블 구조나 관계 정의는 그대로 유지

# B+Tree 인덱스 구조, 복합 인덱스, 인덱스 성능

## B+Tree 인덱스 구조

### 특징

- B-Tree를 확장한 구조
- 모든 데이터(레코드)는 리프 노드에만 저장됨
- 내부 노드는 오직 키와 포인터만 저장
- 리프 노드는 순차 접근을 위한 링크드 리스트로 연결됨

### 장점

- 범위 검색이 빠름 (리프 노드 간 연결 덕분)
- 내부 노드가 작고 균일해, 더 많은 키를 한 페이지에 저장 가능 → 디스크 I/O 감소
- 인덱스 스캔 시 구조가 더 단순하고 예측 가능

## B-Tree 인덱스 구조

### 특징

- 각 노드는 여러 개의 키와 자식 포인터를 가짐
- 노드 하나에 여러 데이터가 저장될 수 있음
- 모든 리프 노드는 같은 레벨(깊이)에 있음
- 삽입/삭제 시 자동으로 트리를 균형 있게 유지

### 장점

- 검색, 삽입, 삭제가 모두 **O(log n)** 시간 복잡도
- 중간 노드에도 데이터가 있으므로, 검색 시 리프 노드까지 가지 않아도 될 수 있음

## B-Tree vs B+Tree

| 항목 | B-Tree | B+Tree |
| --- | --- | --- |
| 데이터 저장 위치 | 내부 노드 + 리프 노드 | 리프 노드에만 저장 |
| 범위 검색 | 비효율적 | 효율적 (리프 노드 연결) |
| 디스크 I/O | 상대적으로 많음 | 적음 (내부 노드 작음) |
| 구조 복잡성 | 단순 | 약간 더 복잡 |
| 사용 예 | 파일 시스템, 옛 DB | 대부분의 관계형 DBMS |

## 복합 인덱스

🔍 데이터베이스에서 여러 개의 컬럼(열)들을 조합하여 인덱스를 생성하는 것

→ WHERE 절이나 ORDER BY 절에서 여러 컬럼을 동시에 조건으로 사용하는 경우에 유리

⚠️ 인덱스는 왼쪽 컬럼부터 작동한다.

### 예시
```sql
# 테이블
CREATE TABLE orders (
    id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    status VARCHAR(20)
);
```
`customer_id`와 `order_date`를 자주 같이 조회한다고 가정
```sql
CREATE INDEX idx_customer_order_date ON orders(customer_id, order_date);
```
→ 이렇게 복합 인덱스를 만들 수 있음

## 인덱스 성능

### 인덱스 사용 시 장점

| 항목 | 설명 |
| --- | --- |
| 검색 속도 향상 | WHERE 조건절의 검색이 수 초 → 수 밀리초로 빨라질 수 있음 |
| 정렬 속도 향상 | ORDER BY / GROUP BY 절에 있는 컬럼이 인덱스에 있으면 정렬 안 해도 됨 |
| 조인 최적화 | 조인할 때 키 컬럼에 인덱스가 있으면 빠르게 매칭 가능 |
| 카운트 최적화 | 인덱스만으로 카운트할 수 있으면 테이블 접근 생략 가능 |

### 인덱스 사용 시 단점

| 항목 | 설명 |
| --- | --- |
| 쓰기(INSERT/UPDATE/DELETE) 성능 저하 | 인덱스를 함께 갱신해야 해서 비용 증가 |
| 디스크 공간 사용 증가 | 인덱스는 별도 저장 구조이므로 공간 추가 사용 |
| 과도한 인덱스 → 오히려 느려짐 | 너무 많은 인덱스는 쿼리 계획 선택이 어려워지고 관리도 복잡해짐 |

➡️ 인덱스는 읽기 성능을 향상하는데는 좋지만 과도하게 사용하면 오히려 쿼리 성능이 느려질 수 있으므로 필요한 곳에 정확하게 쓰는 것이 중요하다!

# 정규화 1~3NF, 이상현상, 역정규화 판단

## 정규화

🔍 데이터를 중복 없이 구조화하여 데이터 무결성과 저장 효율을 높이는 과정

→ 부주의한 데이터베이스 설계는 제어할 수 없는 데이터 중복을 야기하여 여러 가지 갱신 이상을 유발하기 때문에 정규화가 필요함.

## 1정규형

- 모든 컬럼은 원자값만 갖는다
    
    → 컬럼에 값이 1개씩만 존재해야 함
    
- ex. `취미` 컬럼이 `“축구, 농구”` ❌
    
    → `“축구”` / `“농구”`로 나눠야 함.
    

## 2정규형

- 1NF 만족 + 부분 함수 종속 제거
    
    → 복합키가 있을 때, 키의 일부분에만 종속된 속성 제거
    
- 부분 함수 종속
    - 어떤 속성이 복합 기본키의 "일부"에만 의존할 때 발생하는 종속 관계
    - ex.

    - 기본키가 (`학번, 과목코드`)일 때 이 두개의 키를 모두 사용해서 각 속성을 식별해야 하는데
- `학번`만으로 `이름`을 구별할 수 있고 `과목코드`만으로 `과목명`을 구별할 수 있으므로 `이름`과 `과목명`은 기본키의 일부에만 종속된 부분 함수 종속 관계에 해당함.

## 3정규형

- 2NF 만족 + 이행적 함수 종속 제거
    
    → 기본키가 아닌 컬럼이 다른 기본키가 아닌 컬럼을 결정하면 분리
    
- 이행적 함수 종속
    - A → B, B → C이면, A → C도 성립하는 함수 종속 관계
    - ex.
        - `학번`(기본키)이 `학과이름`을 결정하고 `학과이름`이 `학과전화번호`를 결정할 때 `학번`이 `학과전화번호`를 결정하는 상환
            
            → `학과이름`은 기본키도 아닌데 `학과전화번호`를 결정해서 이행적 함수 종속이 발생하는 것이다.
            

## 이상 현상

🔍 정규화가 부족하거나 테이블 구조가 비효율적일 때 발생하는 데이터 이상 문제

| 종류 | 설명 |
| --- | --- |
| **삽입 이상** | 일부 정보만으로는 레코드를 삽입할 수 없음                                                                                                        **ex.** 학생이 아직 수강하지 않았지만, 학생 정보를 넣으려면 과목 정보도 필요함 |
| **삭제 이상** | 하나의 정보만 삭제하려 했는데, 원치 않는 다른 정보도 함께 삭제됨                                                             ex. 어떤 학생의 마지막 수강 과목을 삭제하면 학생 정보까지 사라짐 |
| **갱신 이상** | 중복된 정보가 여러 곳에 존재하여, 수정 시 일관성이 깨질 수 있음                                                                **ex.** 교수 전화번호를 바꾸려면 여러 행을 모두 수정해야 함        |

## 역정규화

🔍 정규화된 테이블을 다시 일부 통합하거나 중복을 허용하여 성능을 향상시키는 과정

### 역정규화를 하는 이유

정규화는 데이터의 무결성과 중복 제거에는 좋지만, JOIN이 많아져 성능 저하가 발생할 수 있음.

→ 성능상의 관점에서만 보면 높은 정규형을 만족하는 릴레이션이 꼭 최적인 것은 아님

그래서 다음과 같은 경우에는 역정규화를 고려함:

- 조회 속도가 중요할 때 (읽기 중심 시스템)
- 너무 많은 조인으로 인해 응답 시간이 느릴 때
- 테이블 수가 지나치게 많아 관리가 어려울 때