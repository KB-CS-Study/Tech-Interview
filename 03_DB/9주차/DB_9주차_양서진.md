# 기본키/후보키/외래키 차이

![image](https://github.com/user-attachments/assets/56a35850-8797-4997-be99-fd5e4c5de286)


- 유일성: 하나의 키값으로 튜플을 유일하게 식별할 수 있는 성질을 의미함. (중복X)
- 최소성: 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질.
    - 특정 학교 학생을 구별할 때, 세가지 구별자[`학생번호`, `이름`, `성별`]가있다면 이는 유일성은 만족하지만 최소성은 만족하지 않는다.
    - `이름`과 `성별`을 제외한 학생번호 만으로 학생을 구별할 수 있으며, `학생번호`는 최소성을 만족한다.

## Super key (수퍼키)

> 유일성 O, 최소성 X

유일성의 특성을 만족하는 속성들의 집합. 중복된 값이 존재하지 않는다. 서로 구분만 가능하면 수퍼키라 할 수 있다.

[학생번호]의 경우 중복되는 경우가 없기 때문에 유일성을 만족하므로 슈퍼키가 될 수 있다.

[이름,나이,성별]의 경우 이 세가지 모두가 일치하는 사람이 존재할 수 있으므로 유일성을 만족하지 못한다. 따라서 수퍼키로 사용할 수 없다.

[학생번호,나이,성별]의 경우 학생번호 한가지만으로 각 튜플(레코드,행)을 구별할 수 있기 때문에 유일성을 만족한다. 따라서 수퍼키로 사용할 수 있다.
> 

> [학생번호,나이,성별]같은 경우 유일성을 만족하는 학생번호를 포함하고 있으므로, [학생번호,나이,성별,학년,수업목록]등 학교 내부 범주에 있는 어떠한 속성을 추가해도 학생번호성질 하나덕분에 유일성을 만족한다. - 중요함.
> 

## Candidate key (후보키)

> 유일성 O, 최소성 O

수퍼키 중에서 최소성을 만족하는 키를 칭한다. 즉, 유일성과 최소성을 모두 만족하는 속성들의 집합이다.

아래와 같이 수퍼키가 있다고 할때,[학생번호,나이,성별]의 경우, 학생번호가 있다면 나이와 성별은 특정 학생을 구별할 때 필요없다. 없어도 전혀 문제가 안됨. 여기서 나이와 성별을 제거한 [학생번호]의 경우 최소성을 만족하며 후보키가 될 수 있다.
> 

## Primary key (기본키)

> 주 키, 프라이머리 키, PK 등으로 불리운다. 후보키들중 메인으로 선정되는 키로 후보키의 성질을 갖는다.

유일성과 최소성을 가지며(후보키), 해당 레코드를 식별할때 기준이 되는 반드시 필요한 키이다.

추가로 기본키는 다음과 같은 조건을 따른다.
값의 변동이 잦은 후보키는 기본키로 부적절하다.
NULL값을 가질수 있는 속성이 포함된 후보키는 부적절하다.
후보키중 단순한 키를 기본키로 선택한다.
하나의 테이블에는 반드시 하나의 기본키만 존재한다.
> 

<img width="592" alt="image2" src="https://github.com/user-attachments/assets/19927b63-b815-4c35-a27a-5a2c58ecefa3" />


## Foreign key (외래키)

![image3](https://github.com/user-attachments/assets/4132f324-58ce-4f3b-a6a9-6fe0b89683d3)


> 테이블간의 관계를 나타낼때 사용하며, 다른 테이블의 기본키를 참조해 외래키로 사용한다.

즉, 한 테이블의 외래키는 연결되어있는 다른 테이블의 기본키중 하나다.
위의 왼쪽 테이블에서 student_id는 기본키이며, 오른쪽 테이블에서는 외래키이다.
학생 목록을 나타내는 왼쪽 테이블에서 1~4의 학생이 있으며, 오른쪽 테이블에서 외래키로 사용되는 student_id는 그 외 값이 나타날 수 없다.
> 

> 사실 외래키 설정을 따로 하지 않아도 데이터 조회가 가능하지만, 굳이 하는 이유는 데이터 무결성 때문이다.무결성: 데이터가 항상 정확한 값을 유지하는 성질위 테이블중 왼쪽 테이블에서 student_id가 변경되었는데 오른쪽 테이블의 student_id가 변경되지 않았다면 문제가 생긴다. 이런 상황을 예방하기 위해 외래키가 존재한다.
> 

# NoSQL과 RDB의 선택 기준과 구조 차이

비관계형 데이터베이스(NoSQL)은 table 형식이 아닌 비정형 데이터를 저장할 수 있도록 지원한다. RDB는 엄격한 스키마로 인해 데이터 중복이 없기 때문에 데이터 업데이트가 많을 때 유리하다. NoSQL은 데이터 중복으로 인해 update 시 모든 컬렉션에서 수정이 필요하기 때문에 update가 적고 조회가 많을 때 유리하다.

## NoSQL

기존의 관계형 DB의 경우 단일 기업의 데이터를 다루는데 최적화 되어 있었다.

최신 데이터들은 꼭 관계형으로 처리할 필요가 없는 경우도 많고 다뤄야 하는 데이터의 양도 훨씬 많이 커졌다.

데이터라고 일컬어 지는 많은 양의 데이터들을 처리하기 위한 방법으로 다양한 해결책이 나왔고, 그 중 하나가

- 수직적 확장(Scale-up) va 수평적 확장(Scale-out)

데이터베이스와 비교하여NoSQL의 특징은 ACID, Transaction을 지원하지 않는다는 것이다. RDB는 ACID와 Transaction을 보장하기 위해 수평적 확장이 쉽지가 않다. 또한, RDB의 경우 multiple server로 수평적 확장을 하게 되면 join을 하기 위해 상당히 복잡한 과정이 필요하다.

RDB도 수평적 확장이 가능하지만 NoSQL에 비해 훨씬 복잡하다. RDB를 수평적 확장하기 위해선 샤딩(sharding)(데이터가 수평적으로 분할되고 기기의 모음 전반에 걸쳐 분산되는 경우)이 필요하다. ACID 준수를 유지하면서 RDB를 샤딩하는 것은 매우 까다로운 작업이다.

정리

Q. NoSQL은 언제 사용하면 좋을까?

- NoSQL은 정확한 데이터 구조가 정해지지 않은 경우, 데이터 update가 자주 이루어지지 않고,조회가 많은 경우, 또 scale-out이 가능하므로 데이터 양이 매우 많은 경우에 사용하면 좋다.

Q. RDB는 언제 사용하면 좋을까?

- RDB는 데이터 구조가 명확하여 변경될 여지가 없는 경우, 또 데이터 중복이 없으므로 데이터 update가 잦은 시스템에서 사용하면 좋다.

## **RDB vs. NoSQL**

그럼 이제 둘을 비교해보자.

- RDB는 관계형으로 데이터를 저장하지만, NoSQL은 그렇지 않다.
- RDB는 스키마가 정적이지만, NoSQL은 유연한 스키마 구조를 갖는다.
- RDB는 수직 확장이 용이하고, NoSQL은 수평 확장이 용이하다. (즉, RDB는 서버 용량을 늘리는 게 쉽고, NoSQL은 서버를 여러 대 늘리는 게 쉽다)
- 위와 관련해서, RDB는 확장 시 다운타임이 있을 수 있지만, NoSQL은 거의 없다.
- **RDB는 복잡한 쿼리와 Join 연산이 가능하다. NoSQL은 구조화된 쿼리 언어가 없는 경우도 많고, 일반적으로 Join이 없다.**
- **RDB는 OLTP에 적합하고, NoSQL은 OLAP에 적합하다. (즉, RDB는 트랜잭션 처리에 용이하고, NoSQL은 분석 처리에 용이하다)**

# 스키마 3계층 (외부/개념/내부)

**관계형 데이터베이스에서 기본 구조를 정의하는 것**이다.

- **데이터 개체(Entity)**, **속성(Attribute)**, **관계(Relationship)**, **제약조건(Constraint)** 등에 대해 정의하는 것.
- 이는 관점에 따라서 외부 스키마, 개념 스키마, 내부 스키마로 나뉠 수 있다.

### 3-Level Schema란

사용자, 설계자, 개발자가 **데이터베이스를 보는 관점에 따라 데이터베이스를 기술하고 관계를 정의한 것**이다. 이는, **데이터의 독립성을 확보하기 위한 방법**이다.

### 3-Level Schema의 장점

- **데이터 복잡도가 감소한다.**
- **데이터의 중복이 제거된다.**
- **사용자 요구사항 변경에 따른 대응력이 향상된다.**
- **관리 및 유지보수 비용이 절감된다.**

계층적으로 표현한 이유?

사용자 관점에서 봐야하는 부분, 설계자 관점에서 봐야하는 부분, 개발자 관점에서 봐야하는 부분을 분명하게 나누고, 수정이  필요하다면 해당 부분을 수정해서 위의 장점을 살리기 위해서이다.

![image4](https://github.com/user-attachments/assets/4e267faa-6dd4-4fce-83aa-a9cfd523ef2d)


![image5](https://github.com/user-attachments/assets/3d756198-7e66-4575-ace0-095356a41e99)


# B+Tree 인덱스 구조, 복합 인덱스, 인덱스 성능

 인덱스(Index)란?

MySQL에서 인덱스는 테이블의 데이터를 **빠르게 검색**할 수 있도록 도와주는 **자료 구조**입니다. 테이블의 특정 컬럼 값을 정렬된 형태로 별도의 공간에 저장하여 검색을 효율적으로 만들어줍니다. 

인덱스는 주로 **B-Tree** 구조를 사용합니다.

> 📖 비유: 인덱스는 책의 목차와 같습니다. 전체 내용을 다 훑지 않고 원하는 위치로 바로 이동할 수 있게 도와줍니다.
> 

## Binary Tree

![image6](https://github.com/user-attachments/assets/d06907bf-591a-4e33-b90b-c070e32100ff)


Binary 트리는 자식을 2개를 가질 수 있는 노드들로 구성되는 트리 형태의 자료구조이고, 아래와 같은 중요한 특징을 갖고 있다.

1. 각 노드의 왼쪽 서브 트리에는 자신보다 작은 값들이 배치된다.
2. 각 노드의 오른쪽 서브 트리에는 자신보다 큰 값들이 배치된다.

위와 같은 특징을 갖고 있다보니, 어떤 데이터를 풀스캐닝하는 것보다 상대적으로 빠른 속도로 찾을 수 있고, 데이터 탐색 속돈느 데이터의 양이 많을 수록 많이 나게 된다.

그래서 DB Index에서는 '이진 탐색 트리'를 업그레이드 한 B-Tree 또는 B+Tree 자료구조를 사용한다.

## B-Tree

---

![image7](https://github.com/user-attachments/assets/2c2a49ba-21d4-4a70-bb2a-f810f3c985b2)


B-Tree는 Binary search tree(이진 탐색 트리)를 업그레이드한 자료구조로, 관계형 DB의 Index에서 자주 사용되는 자료 구조이다. 모든 Leaf노드가 동일한 레벨에 존재하는 특징을 갖고 있으며, 이진 탐색 트리는 2개의 자식 노드만 가질 수 있었던 것과 달리 B-Tree는 2개 이상의 자녀 노드를 가질 수 있다.

![image8](https://github.com/user-attachments/assets/da83eee8-2fcc-4507-96ac-4477c525d9d7)


예를 들어서, 부모 노드에 55, 65라는 2개의 값이 저장되어 있다면, 자식 노드는 아래 3가지 케이스로 값을 구분해서 저장할 수 있는 것이다.

1. 55보다 작은 값
2. 55초과, 65 미만의 값
3. 65보다 큰 값

즉, 부모 노드에 저장된 값이 N개 라면 그 하위 노드는 최대 N+1개의 노드를 가질 수 있게 된다.

이러한 특징으로 인해서 검색 성능과 뿐만 아니라 Binary search tree 자료구조에 비해서 데이터 관리의 효율도 증가하게 되는 것이다.

추가적으로, 하나의 노드에 여러 값이 저장되어 있는 경우 값들은 오름차순으로 정렬이 된다는 특징도 갖고 있다.

## B+Tree

---

![](https://velog.velcdn.com/images/juhyeon1114/post/0f495637-0db1-4ee8-96be-ab4c3c2f8d14/image.jpg)

B-Tree에서 검색 성능을 한층 개선한 자료구조가 바로 B+Tree이다. 대표적으로 InnoDB엔진에서 Index를 관리할 때 B+Tree를 사용한다.

B-Tree보다 검색 연산이 빠르고, 범위 검색에 유용하다는 특징이 있다.

### B-Tree의 범위 검색

A이상 B이하의 범위를 찾아야하는 상황이라고 가정해보자. 이 범위를 찾기 위해서는 당연하게도 A값의 위치와 B값의 위치를 알아야한다. 그래야 그 사이의 값들이 검색의 결과에 해당하는 범위인 것을 알 수 있기 때문이다.

B-Tree 자료구조에서 이러한 범위 검색을 수행한다고 생각해보면, 먼저 최상위 노드 부터 시작해서 A를 검색하게 될 것이다. 그리고 B를 찾을때도 마찬가지로 최상위 노드부터 올라가서 B를 찾아야한다. 즉, 최상위 노드부터 검색하는 과정(선형 검색)을 2번 반복해야하는 것이다.

### B+Tree의 범위 검색

B+Tree는 B-Tree에서 Leaf 노드 간에 '연결성'이 추가된 자료구조이다. 즉, 하나의 A 또는 B중 하나만 선형 검색을 해서 위치를 알게 되면, Leaf 노드간의 연결성을 통해서 나머지 값을 탐색할 수 있는 것이다. 예를 들어서 A의 위치를 알게 되면 그 후부터는 현재 Leaf노드의 오른쪽 방향만 빠르게 탐색해서 B의 위치를 알 수 있는 것이다.

### B-Tree VS B+Tree

위 설명만으로는 B+Tree가 더 나은 자료구조로 생각될 수 있지만, 각각의 장단점이 존재한다. 몇가지 관점에서 B-Tree와 B+Tree를 비교해보자.

1. 메모리 효율 : B-Tree에서는 각 노드에 데이터의 주소값뿐만 아니라, 실제 데이터로 오름차순으로 정렬이 되어 있고, B+Tree에서는 Leaf노드에만 실제 데이터들이 저장되어 있다. 그래서 B-Tree보다 B+Tree가 메모리 효율 측면에서는 좀 더 좋다고 할 수 있다.
2. 생성 및 삭제의 효율 : B+Tree는 Leaf노드 간에 '연결'을 나타내는 데이터도 추가적으로 관리되어야한다. 그래서 데이터의 생성, 수정, 삭제가 일어날 때는 B-Tree가 B+Tree보다 좀 더 좋은 성능을 일반적으로 보인다.

## 복합 인덱스

> 복합 인덱스(Composite Index)는 데이터베이스에서 여러 개의 컬럼(열)들을 조합하여 인덱스를 생성하는 것을 말한다.
> 

단일 인덱스(Single Index)가 한 개의 컬럼에 대해 생성되는 것과는 달리, 복합 인덱스는 여러 개의 컬럼을 함께 사용하여 인덱스를 생성한다.

❓인트로에 설명하던 **결합인덱스(Joined Index)**는 무엇일까?

- 결합 인덱스(Joined Index)는 두 개 이상의 테이블을 조인할 때 사용하는 인덱스이다. 결합 인덱스는 두 개 이상의 테이블에서 조인 조건으로 사용되는 컬럼을 모두 포함하는 인덱스를 말한다.

복합 인덱스는 장점을 나열하면 다음과 같다.

- 검색 속도 개선
    
    여러 개의 컬럼을 동시에 검색할 수 있기 때문에 검색 속도가 개선할 수 있다.
    
- 데이터 정렬의 효율성
    
    인덱스를 생성할 때 여러 개의 컬럼을 함께 사용하면 정렬을 할 때 더 효율적으로 할 수 있다.
    
- 인덱스의 용량 절감
    
    인덱스를 생성할 때 여러 개의 컬럼을 함께 사용하면 인덱스의 용량이 줄어든다.
    
- 쿼리 최적화
    
    복합 인덱스는 여러 개의 컬럼을 함께 사용하기 때문에, 쿼리가 여러 개의 조건을 가지고 있을 때 최적화된 실행 계획을 수립할 수 있다.
    

## 복합인덱스 사용시 주의점

복합인덱스를 사용할 땐 아래와 같은 주의점을 요구하게 된다.

- ⛔복합 인덱스는 일반적으로 WHERE 절에 자주 사용되는 컬럼들로 구성되는데,
    
    인덱스를 생성하는 컬럼의 개수가 많아질수록 인덱스의 성능은 떨어질 수 있다.
    

- ⛔복합 인덱스를 생성할 때는 인덱스 생성 순서도 고려해야 한다.
    
    쿼리문 작성 시 복합 인덱스를 사용하고자 한다면 반드시 복합 인덱스의 컬럼 중 선행하는 컬럼부터 조건에 지정하여 사용하여야 한다. 주로 자주 이용되는 순서대로 복합 인덱스 컬럼의 순서 결정한다.
    

- ⭕인덱스 생성 순서는 WHERE 절에서 먼저 사용되는 컬럼을 앞쪽에 위치시키는 것이 좋다.
    
    이렇게 함으로써, 인덱스를 탐색할 때 필요한 레코드 수가 최소화시킬 수 있다.
    

## 인덱스가 많을 경우에 따른 Trade Off

기업의 면접에서 가장 많이 나오는 질문중 하나는 인덱스가 데이터베이스의 검색 성능을 향상시켜 준다면, 많은 인덱스를 설정하는 것이 좋은지 물어보는 경우가 있습니다.

→ 인덱스 설계시 **무분별한 인덱스 설계는 오히려 데이터베이스 시스템의 성능 저하 문제**로 이어질 수 있기 때문에 적절한 기준에 따른 인덱스 설계가 필요

# 정규화 1~3NF, 이상현상, 역정규화 판단

> 정규화
> 
> 
> : DB설계에서 테이블 분할하여 중복을 최소화하고 데이터의 무결성을 보장하기 위해 사용된다.
> 

### 제 1 정규화

- 각 컬럼은 원자값을 가지도록 한다. (다중 값 X)
- 하나의 컬럼은 같은 종류나 타입을 가져야 한다.
- 기본키를 가지고 고유하게 식별이 가능해야 한다
- 

ex) 정규화 하기 전 (수강 과목에 다중 값을 가진다)

| 학번 | 이름 | 수강 과목 |
| --- | --- | --- |
| 2021111945 | A | 운영체제, 데이터베이스 시스템 |
| 2019222034 | B | 컴퓨터구조 |
| 2021123445 | C | 운영체제 |

제 1 정규화 적용 후 : 원자성 만족

| 학번 | 이름 | 수강 과목 |
| --- | --- | --- |
| 2021111945 | A | 운영체제 |
| 2021111945 | A | 데이터베이스 시스템 |
| 2019222034 | B | 컴퓨터구조 |
| 2021123445 | C | 운영체제 |

### 제 2정규화

- 제 1정규형을 만족해야한다.
- 기본키가 아닌 속성이 기본키에 대한 부분적 종속이 없어야한다. (=완전 함수 종속)
- 기본키의 일부가 아닌 다른 속성이 기본키에 종속되어서는 안 된다.

제 2 정규화 적용 전 :

기본키 [ 이름 , 수강 과목 ] 일 때 `나이`와 `학번`은 `이름` 이라는 특정 컬럼에만 종속되어 있다.

(부분 종속)

| 학번 | 이름 | 수강 과목 | 나이 |
| --- | --- | --- | --- |
| 2021111945 | A | 운영체제 | 21 |
| 2021111945 | A | 데이터베이스 시스템 | 21 |
| 2019222034 | B | 컴퓨터구조 | 23 |
| 2021123445 | C | 운영체제 | 22 |

제 2 정규화 적용 후 : 완전 함수 종속

| 학번 | 이름 | 나이 |
| --- | --- | --- |
| 2021111945 | A | 21 |
| 2019222034 | B | 23 |
| 2021123445 | C | 22 |

| 이름 | 수강 과목 |
| --- | --- |
| A | 운영체제 |
| A | 데이터베이스 시스템 |
| B | 컴퓨터구조 |
| C | 운영체제 |

### 제 3정규화

- 제 2정규형을 만족해야한다.
- 이행 함수 종속을 제거한다. (X->Y, Y->Z 일 때 X->Z)
- 

제 3 정규화 적용 전 : 학번을 알면 학과를 알 수 있고 학과를 알면 학과 위치를 알 수 있다.(이행 함수 종속)

| 학번 | 학과 | 학과 위치 |
| --- | --- | --- |
| 2021111945 | 컴퓨터공학과 | 2층 |
| 2019222034 | 수학과 | 3층 |
| 2021123445 | 영어과 | 4층 |

제 3 정규화 적용 후 : 이행 함수 종속 제거

| 학번 | 학과 |
| --- | --- |
| 2021111945 | 컴퓨터공학과 |
| 2019222034 | 수학과 |
| 2021123445 | 영어과 |

| 학과 | 학과 위치 |
| --- | --- |
| 컴퓨터공학과 | 2층 |
| 수학과 | 3층 |
| 영어과 | 4층 |

## 이상현상

### 1. 삽입 이상(Insertion Anomaly)

- 데이터 삽입 시 **의도와 다른 값들도 삽입**되는 현상이다.

소비자가 어떤 물건을 샀는지를 나타내는 데이터베이스가 있다고 가정하자.

그 DB의 기본키가 {`user_id` , `product_id`} 인 경우, 소비자가 물건을 사지 않았다면 product_id가 없는 현상이 발생한다. 그러나 product_id는 기본키이기 때문에 무조건적으로 데이터를 채워야 하나 기본키는 Null이 될 수 없으므로 물건을 사지 않은 소비자의 데이터는 테이블에 추가될 수 없다.

테이블에 추가하기 위해서는 '구입하지 않음'이라는 상품을 만들어야 한다.

> 불필요한 데이터를 추가해야 테이블에 삽입할 수 있는 현상을 삽입 이상이라 한다.
> 

### 2. 갱신 이상(Update Anomaly)

- 속성값 갱신 시 **일부 튜플만 갱신**되어 모순이 발생하는 현상이다.

학생 이름과 전화번호, 전공을 저장하는 테이블이 있다고 가정하자.

전공 중 '소프트웨어공학부'가 '컴퓨터공학과', '사이버보안학과'로 나뉘게 된다면 소프트웨어공학부에 속해있던 모든 학생들의 전공을 바꾸어야 한다.

일부를 깜빡하고 바꾸지 못하는 경우엔 존재하지 않는 전공에 속한 학생이 생기게 된다.

> 일부만 변경하여 데이터가 불일치하는 모순이 발생하는 현상을 갱신 이상이라 한다.
> 

### 3. 삭제 이상(Delete Anomaly)

- 데이터 삭제 시 의도와 다른 값들도 함께 삭제되는 현상이다.

학생의 이름과 전공, 수강 과목을 저장하는 테이블이 있다고 가정하자.

어떤 학생이 A 과목 수강을 철회하는 경우, 그 학생의 이름과 전공 데이터까지 삭제된다.

> 튜플 삭제로 인해 다른 데이터까지 함께 삭제되는 현상을 삭제 이상이라 한다.
> 

### 역정규화 (Denormalization)

> 역정규화는 성능을 향상시키기 위해 정규화된 DB 를 다시 중복을 포함하는 형태로 변경하는 프로세스이다.
> 

테이블을 너무 많이 잘게 쪼개면 여러 테이블들이 모두 동시에 조인을 하게 되기 때문에 성능이 느려지는 이슈가 발생할 수 있고, 관리하기 어려워질 수 있다.

- 일반적으로 쿼리의 성능을 향상시키기 위해 사용되며, 특히 읽기 작업이 많은 시스템에서 유용하다.
- 데이터의 일부를 중복 저장하거나 중복 인덱스를 생성함으로써 데이터에 대한 읽기 액세스를 최적화한다.
- 하지만 데이터 일관성을 유지하기 위해 조심스럽게 사용되어야 한다.
