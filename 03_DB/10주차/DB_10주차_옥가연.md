# 트랜잭션과 격리 수준 (ACID + Isolation Level)

## 트랜잭션의 정의와 트랜잭션의 특징

- 트랜잭션 : 여러 작업들을 한 작업 단위로 묶어서 처리하는 것
- ACID 특징
  - 원자성 (Atomicity) : 한 트랜잭션은 하나의 작업으로 간주한다. 작업은 모두 성공하거나, 모두 실패해야한다. (all or nothing)
  - 일관성 (Consistency) : 트랜잭션은 작업이 완료된 뒤에 데이터베이스의 일관성 있는 상태를 유지할 수 있어야한다.
  - 독립성 (Isolation) : 병렬적으로 실행되는 트랜잭션은 서로 영향을 받거나 주지 않아야 한다.
  - 지속성 (Durability) : 트랜잭션이 성공적으로 완료되면, 그 결과는 지속되어야 한다.

## 트랜잭션 사용시 문제점

- 트랜잭션을 병렬적으로 사용 중일 때 나타나며, 트랜잭션의 특징 중 특히 독립성을 완전히 만족시키지 못했을 때, 문제가 생긴다.

1) 갱신 분실(Lost Update) : 각 트랜잭션들이 동일 데이터를 동시에 업데이트할 경우 발생한다. 이전 트랜잭션이 데이터를 업데이트한 후 트랜잭션을 종료하기전에 나중 트랜잭션이 업데이트한 값을 덮어쓰는 경우 발생
2) 모순성(Inconsistency) : 두 트랙잭션이 동시에 실행할 때, 하나의 트랜잭션의 값은 필연적으로 DB가 일관성이 없는 상태로 남는 문제. 트랜잭션 끼리 공유한 값이 변경되는 순간에 서로 맞물리게 되어 값에 영향을 주게 되어 나타나는 현상
3) 연쇄 (순차적) 복귀(Cascading Rollback) : 각 트랜잭션들이 데이터 공유하고 있다면, 그 중 하나의 트랜잭션이 작동 중 오류가 나서 처리를 롤백할 경우, 다른 트랜잭션들은 오류가 난 트랜잭션과 공유한 값에 대해 처리한 부분을 연쇄적으로 롤백을 해야한다. 하지만, 다른 트랜잭션들은 자신들은 오류가 나지 않았기 때문에 롤백이 일어나지 않는 상황
4) 현황파악 오류 (Dirty Read) : 트랜잭션의 중간 수행결과를 다른 트랜잭션이 참조함으로써 기존의 값이 아닌 변경된 값을 참조하게 되는 상황

- 이러한 문제들이 일어 날 수 있기 때문에 각 트랜잭션의 독립성을 지켜주고, 순차적으로 실행될 수 있도록 해야한다.

## 트랜잭션 격리 수준(Isolation level)

- 트랜잭션 격리 수준 :  동시에 여러 트랜잭션이 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것

![](https://velog.velcdn.com/images/yujiniii/post/3ed62e2b-f96e-4df9-898b-a5351d2174cc/image.png)

### 0 : READ UNCOMMITTED (커밋되지 않은 읽기)

- 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있다.
- 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장한다.
- DIRTY READ 발생
  - 트랜잭션이 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상

### 1 : READ COMMITTED (커밋된 읽기)

- COMMIT 이 된 데이터만 읽는다.
- RDB에서 대부분 기본적으로 사용되고 있는 격리 수준
- Dirty Read와 같은 현상은 발생하지 않지만 NON-REPEATABLE READ 발생
  - 하나의 트랜잭션 내에서 동일한 SELECT 쿼리를 실행했을 때 항상 같은 결과를 보장해야 한다는 REPEATABLE READ 정합성에 어긋나는 것
- 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다.
  - UNDO 영역:
    간단하게 데이터를 저장하는 버퍼 기능을 한다고 보면 되고, 트랜잭션에서 연산(커밋 롤백)이 이루어지지 않아도 질의문에 의해 수정이 생기면 수정되기 이전 값이 저장되는 영역

### 2 : REPEATABLE READ (반복 가능한 읽기)

- 자신의 트랜잭션이 생성되기 이전의 트랜잭션에서 COMMIT 이 된 데이터만 읽는다.
- MySQL과 MariaDB 가 기본으로 사용하는 격리 수준
- MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.

### 3 : SERIALIZABLE (직렬화 가능)

- 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준
- 데이터를 접근할 때, 항상 Lock을 걸고 데이터를 조회
- SERIALIZABLE에서는 PHANTOM READ가 발생하지 않는다.
- 성능 문제로 데이터베이스에서 거의 사용되지 않는다.

## InnoDB

### 디스크 구조(On-Disk Structures)

- InnoDB는 데이터를 디스크에 저장할 때, 논리적 구조와 물리적 구조로 나누어 저장 구조를 설계한다.
- 논리적 구조: 데이터베이스 입장에서 보이는 구조 (테이블, 인덱스 등)
- 물리적 구조: 실제 디스크 파일과 저장 단위 (tablespace, 로그 등)

![](https://velog.velcdn.com/images/yjl8628/post/1088caec-5ce1-478d-9d5e-47d65509d6e2/image.png)

#### Redo Log (물리적 구조)

- 트랜잭션의 변경 이력(무엇을 변경했는지)을 기록하는 로그 파일
- Log Buffer에 먼저 저장되고,
  → 커밋 또는 주기적으로 Redo Log 파일(ib_logfile0, 등) 에 기록됨
- 시스템 크래시 시 → 이 로그를 재실행하여 복구
- WAL(Write-Ahead Logging)의 핵심 요소
- 데이터의 영속성과 복구 가능성 확보

#### Undo Log (물리적 구조, 논리적 개념 포함)
- 트랜잭션의 이전 값을 저장하는 로그
  → 롤백, 그리고 MVCC(다중 버전 동시성 제어) 구현의 핵심
- DELETE나 UPDATE 전에 이전 값을 Undo Log에 저장
- 트랜잭션 롤백 시 → Undo Log를 통해 데이터 원상복구 가능
- 트랜잭션 격리 수준(REPEATABLE READ)에서도 → Undo Log를 기반으로 과거 스냅샷 제공
- 트랜잭션의 정합성, MVCC의 기반이 되는 구조

## 읽기에도 트랜잭션이 필요한 경우

- 조회 및 읽기 작업은 데이터의 변경을 동반하지 않기 때문에 일반적으로는 트랜잭션을 걸 필요가 없다. 
- 그러나 특정 상황에서 조회 작업에도 트랜잭션을 적용하는 이유가 있을 수 있다.

1) 일관성(Consistency)을 유지하기 위해
   - 다른 트랜잭션에서 데이터를 수정 중일 때 조회 작업이 동시에 실행되면 수정이 완료되기 전의 데이터를 읽을 수 있다. 
   - 이를 방지하기 위해 조회 작업에도 트랜잭션을 적용하여 일관성을 유지할 수 있다.
2) 로드 밸런싱을 위해
   - 특정 작업이 많은 시간이 걸리는 경우, 다수의 조회 작업이 해당 작업을 참조하는 경우가 발생할 수 있다. 
   - 이때 트랜잭션을 걸어 작업이 완료될 때까지 조회 작업을 블록하여 일관된 데이터를 제공할 수 있다.
3) 프레임워크나 라이브러리에서 메서드 단위의 트랜잭션을 제공할 때 클래스 레벨의 트랜잭션 설정에 따라 조회 메서드에도 트랜잭션이 적용될 수 있다. 
   - 이 경우 의도하지 않은 트랜잭션이 적용되기 때문에 성능 등의 이슈가 발생할 수 있다. 
   - 이 경우 트랜잭션을 제외하거나 따로 설정을 변경하여 해결할 수 있다.