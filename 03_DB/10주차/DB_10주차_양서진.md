# 트랜잭션 이란, 특징, 문제점

<aside>
💡

더이상 분할이 불가능한 업무처리의 단위

</aside>

하나의 작업을 위해 더이상 분할될 수 없는 명령들의 모음.

한꺼번에 수행되어야 할 일련의 연산 모음

```sql
START TRANSACTION
    -- 이 블록안의 명령어들은 마치 하나의 명령어 처럼 처리됨
    -- 성공하던지, 다 실패하던지 둘중 하나가 됨.
    A의 계좌로부터 인출;
    B의 계좌로 입금;
COMMIT
```

데이터베이스와 어플리케이션의 데이터 거래(Transaction)에 있어서 안전성을 확보하기 위한 방법이 트랜잭션인 것이다.

따라서 데이터베이스에서 테이블의 데이터를 읽어 온 후 다른 테이블에 데이터를 입력하거나 갱신, 삭제하는 도중에 오류가 발생하면, 결과를 재반영 하는 것이 아니라 모든 작업을 원상태로 복구하고, 처리 과정이 모두 성공하였을때 만 그 결과를 반영한다.

## MYSQL 트랜잭션

MYSQL에서 트랜잭션은 데이터베이스를 상태를 바꾸는 일종의 작업 단위이다.

INSERT, DELETE, UPDATE 등의 SQL 명령문을 통해 데이터를 상태를 바꿀 때 마다 내부적으로 자동적으로 Commit 을 실행하여 변경된 내역을 데이터베이스에 반영

<img width="820" alt="image" src="https://github.com/user-attachments/assets/e3121e63-f3bd-45ae-a0bb-d1dc276d00fa" />


작업의 단위는 질의어 한 문장이 아니다.

작업단위란 많은 질의어 명령문들을 사람이 정하는 기준에 따라 정하는 것을 의미한다.

Info게시판을 예로 들어보자.  

1) 게시판 사용자는 게시글을 작성하고, 올리기 버튼을 누른다.  

2) 그러면 글 올리기가 처리되고 자동으로 다시 게시판에 돌아오게 된다.  

3) 게시판에서 자신의 글이 포함된 업데이트된 게시글들을 볼 수 있다.

이러한 상황을 데이터베이스 작업으로 옮기면, 사용자가 올리기 버튼을 눌렀을 시,Insert 문을 사용하여 사용자가 입력한 게시글의 데이터를 넣는다. 그 후에, 게시판을 구성할 데이터를 다시 Select 하여 최신 정보로 유지한다.

여기서 작업의 단위는 insert문과 select문 둘다 를 합친것이다.

이러한 작업단위를 하나의 트랜잭션이라 한다.

관리자나 개발자가 하나의 트랜잭션 설계를 잘하는 것이 데이터를 다루는 것에 많은 이점이 있다.

## 트랜잭션 상태

<img width="819" alt="image2" src="https://github.com/user-attachments/assets/3439362b-b296-46a2-ae0f-be72aa67e4a1" />


1. 활성(Active) : 트랜잭션이 정상적으로 실행중인 상태를 의미한다.트랜잭션이 시작되면, 해당 트랜잭션의 상태는 활동(Active)상태가 된다.

해당 상태는 설계자가 설계한 대로 연산들이 정상적으로 실행중인 상태를 의미한다.

- 작업 성공시,

2-1. 부분 완료(Partially Committed) : 트랜잭션의 마지막까지 실행되었지만, Commit 연산이 실행되기 직전의 상태

2-2. 완료(Committed) : 트랜잭션이 성공이 종료되어 Commit 연산을 실행한 후의 상태 설계된 트랜잭션대로 명령을 성공적으로 수행하면 그 다음 상태는 부분적 완료(Partially Committed)상태가 된다.

설계된 작업대로 작업이 성공하였다고 하여 무조건 반영하는 것이 아니라, 설계자의 최종 승인(Commit)이 있을 때 까지 실제 데이터베이스에 작업 내용을 반영하지 않고 기다리고 있는 상태이다.설계자가 작업 결과에 대하여 반영을 승인(Commit)한다면 트랜잭션이 성공적으로 종료된다(Committed)

- 작업 실패시,

2-1. 실패(Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태.

2-2. 철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태.

트랜잭션을 수행하는 중간에 모종의 원인으로 인하여 오류가 발생하여 실행이 중단된 상태를 실패(Failed)상태라고 한다.

이때 트랜잭션이 비정상적으로 종료되었으니, 설계되어있는 트랜잭션 내부의 작업을 다시 수행 이전의 상태로 돌리는 (ROLLBACK) 연산을 수행하면 그 상태를 철회(Aborted)라고 한다.

## 트랜잭션 원칙 (ACID)

<img width="834" alt="image3" src="https://github.com/user-attachments/assets/375179e8-7da3-4274-8a86-441321327f43" />


## 트랜잭션 격리 수준

![image4](https://github.com/user-attachments/assets/5f6ce3c4-da57-476a-ac44-ed4855156653)


## `0 : READ UNCOMMITTED` (커밋되지 않은 읽기)

- 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있습니다.
- 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장합니다.
- DIRTY READ 발생
    
    > DIRTY READ
    > 
    > 
    > 트랜잭션이 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상
    > 
    > **💡 예시**
    > 
    > `트랜잭션 A` 가 실행되고 update 됐을 때 그 사이에 `트랜잭션 B`가 실행된다.
    > 
    > 그러면 `트랜잭션 A`에서 커밋이 되지 않았음에도 불구하고, `트랜잭션 B`에서 `트랜잭션 A`가 update한 내용을 확인할 수 있게 된다.
    > 

## `1 : READ COMMITTED` (커밋된 읽기)

- COMMIT 이 된 데이터만 읽습니다.
- RDB에서 대부분 기본적으로 사용되고 있는 격리 수준
- Dirty Read와 같은 현상은 발생하지 않지만 NON-REPEATABLE READ 발생
    
    > NON-REPEATABLE READ
    > 
    > 
    > 하나의 트랜잭션 내에서 동일한 SELECT 쿼리를 실행했을 때 항상 같은 결과를 보장해야 한다는 REPEATABLE READ 정합성에 어긋나는 것
    > 
    > **💡 예시**
    > 
    > `트랜잭션 A`에서 update 된 내용이 타 트랜잭션에서 바로 보여지지는 않는다. 근데 `트랜잭션 A`에서 커밋이 완료되었는데 `트랜잭션 B`에는 아직 완료되지 않은 경우, `트랜잭션 B`에서 다시 한번 조회를 하게 된다면 update 된 상태가 조회가 된다
    > 
    > **같은 조회(셀렉트)문인데도 결과가 다르기 때문에 정합성에 어긋난다.**
    > 
- 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다.
    
    > UNDO 영역:
    > 
    > 
    > 간단하게 데이터를 저장하는 버퍼 기능을 한다고 보면 되고, 트랜잭션에서 연산(커밋 롤백)이 이루어지지 않아도 질의문에 의해 수정이 생기면 수정되기 이전 값이 저장되는 영역
    > 

## `2 : REPEATABLE READ` (반복 가능한 읽기)

- 자신의 트랜잭션이 생성되기 이전의 트랜잭션에서 COMMIT 이 된 데이터만 읽습니다.
- MySQL과 MariaDB 가 기본으로 사용하는 격리 수준
- MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.
    
    > PHANTOM READ
    > 
    > 
    > 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상
    > 
    > **💡 예시**
    > 
    > 같은 테이블에 접근하는 여러개의 트랜잭션을 처리하고 있습니다. 그중 한 트랜잭션이 `SELETE ~~ FOR UPDATE` 을 사용하여 쓰기 잠금을 걸고 싶다고 가정합니다. 쿼리문에 따라, SELECT하려는 레코드에 쓰기 잠금을 걸어야 하는데, Undo 레코드에는 잠금을 걸 수 없습니다. 따라서 위와 같은 쿼리는 Undo 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져오게 됩니다! 따라서 레코드가 보였다 안보였다 한다고 해서 **🎭 PHANTOM** 이라고 합니다.
    > 

> REPEATABLE READ 추가 설명
> 
> 
> 모든 트랜젝션은 번호를 갖고, undo영역에서는 트랜잭션 번호를 함께 보관합니다.
> 
> 아까와 같이 `트랜잭션 A`와 `트랜잭션 B`가 있습니다. `트랜잭션 A`의 번호는 13번이고 `트랜잭션 B`의 번호는 10번입니다.
> 
> `트랜잭션 B`가 시작했습니다.
> 
> ➡ `트랜잭션 A`에서는 일부 값을 업데이트 하고 커밋하였습니다.
> 
> ➡ `트랜잭션 B` 안에서 실행되는 모든 SELECT 쿼리는 자신의 트랜잭션인 10번 보다 작은 트랜잭션 번호에서 변경한 것만 보게 됩니다. 즉, 번호가 13인 `트랜잭션 A`에서 변경한 내용은 10번인 `트랜잭션 B`에 영향을 주지 않습니다. 이는 Undo 영역에 트랜잭션 번호가 저장되어있기 때문에 가능한 것입니다.
> 

## `3 : SERIALIZABLE` (직렬화 가능)

- 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준
- 데이터를 접근할 때, 항상 Lock을 걸고 데이터를 조회
- SERIALIZABLE에서는 PHANTOM READ가 발생하지 않는다.
- 성능 문제로 데이터베이스에서 거의 사용되지 않는다.

---

## 트랜잭션 문제들 한눈에 정리

![](https://velog.velcdn.com/images/yujiniii/post/d4a63a9f-b11c-41ed-9eba-df56281dcd27/image.png)

> (+) 트랜잭션 격리 수준에 따른 동시성과 일관성 변화
> 
> 
> ![](https://velog.velcdn.com/images/yujiniii/post/b193da4d-d0db-4b3e-b0c0-6967629a74cc/image.png)
> 
> [사진 출처](https://techvu.dev/115)
> 
> 격리 수준이 높아지면서 데이터의 일관성이 유지될 수 있지만, 동시에 처리가능한 트랜잭션의 양은 떨어집니다. 격리수준이 낮아지면 일관성은 유지되기 어렵지만, 동시에 처리할 수 있는 트랜잭션의 양은 늘어나게 됩니다.
> 
> - **동시성** : 동시에 수행하는 트랜잭션 양
> - **일관성** : 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것
