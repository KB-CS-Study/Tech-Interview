# 트랜잭션이란?

🔍 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위입니다.

즉, SQL을 이용해서 데이터베이스에 접근한다고 할 때 SQL 한 문장이 아니라 여러 개의 SQL 문장들이 하나의 묶음으로 실행되어 전부 성공하거나 실패해야 하는 작업입니다.

예를 들어, 계좌 이체는 단일 작업처럼 보이지만, 실제로는 다음과 같은 여러 SQL 문장이 실행됩니다:

1. A 계좌에서 잔액 차감
2. B 계좌에 잔액 추가
3. 거래 내역 기록

만약 트랜잭션이 없을 경우, 위 작업 중 하나라도 실패했을 때 나머지 작업은 그대로 데이터베이스에 반영되어 데이터 불일치가 발생할 수 있습니다.

예를 들어, A 계좌에서는 돈이 빠져나갔는데 B 계좌에는 입금되지 않거나, 거래 내역이 기록되지 않는 상황이 발생할 수 있습니다.

이처럼 트랜잭션은 하나의 거래를 안전하게 처리하도록 보장해줍니다.

## 트랜잭션의 commit & rollback

트랜잭션의 `COMMIT`과 `ROLLBACK`은 트랜잭션의 실행 결과를 **확정하거나 취소**하는 핵심 제어 구문입니다. 

모든 작업이 성공해야만 **커밋**되어 실제로 반영되며, 중간에 오류가 발생하면 **롤백**되어 모든 작업이 원래대로 되돌아갑니다.

# 트랜잭션 원칙(ACID)

트랜잭션의 원칙(ACID)은 데이터베이스에서 트랜잭션이 정확하고 안정적으로 수행되기 위해 반드시 지켜야 할 4가지 원칙입니다.

## A - Atomicity (원자성)

한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않는다. (all or nothing)

→ 작업 중 하나라도 실패하면 전체가 취소(Rollback)되어야 한다.

## C - Consistency(일관성)

트랜잭션이 완료되면 데이터는 **항상 일관된 상태**를 유지해야 한다.

→ 트랜잭션 전과 후에 데이터 무결성이 유지되어야 한다.

※ 하지만 트랜잭션이 수행되는 도중에는 데이터베이스가 일시적으로 일관된 상태를 갖지 않을 수도 있다.

## I - Isolation(격리성)

한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 해야한다.

→ 다수의 트랜잭션들이 동시에 수행되더라도 그 결과는 트랜잭션들을 하나씩 차례대로 수행한 결과와 같아야 한다.

이를 유지하기 위해 DBMS는 다양한 격리 수준을 제공한다.

## D - Durability(지속성)

일단 한 트랜잭션이 완료되면 이 트랜잭션이 갱신한 것은 그 후에 시스템에 고장이 발생하더라도 손실되지 않아야 한다.

## 예시

A 계좌 → B 계좌로 10만 원을 보내는 트랜잭션

- 원자성: A 계좌에서 차감, B 계좌에 입금할 때 둘 중 하나라도 실패하면 모두 취소
- 일관성: 이체 전/후에도 A 계좌, B 계좌의 전체 잔액 총합은 변하지 않아야 한다.
- 격리성: 동시에 다른 이체 작업이 실행되더라도 중간값을 볼 수 없어야 한다.
- 지속성: COMMIT 이후 정전이 나더라도 이체는 완료된 상태여야 한다.

➡️ 따라서 트랜잭션 ACID 원칙이 제대로 지켜지지 않으면, **데이터 손상, 중복 처리, 손실, 충돌**과 같은 문제가 발생할 수 있습니다.

# 트랜잭션 격리 수준

🔍 트랜잭션 격리 수준은 **동시에 실행되는 트랜잭션들이 서로에게 어떤 영향을 미칠 수 있는지**를 정의한 것입니다.

트랜잭션의 원칙 **ACID** 중 격리성(Isolation)은 트랜잭션 간의 영향을 차단하여 **데이터 정합성을 보장**해야 한다는 의미입니다. 하지만 격리성을 완전히 보장하려면,

모든 트랜잭션을 **순차적으로** 처리해야 하고, 이는 곧 **성능 저하**로 이어집니다.

따라서 실무에서는 격리성을 어느 정도 타**협**하면서 적적한 격리 수준을 선택해 성능과 정합성 사이의 균형을 맞춥니다.

### 1. **Read Uncommitted (커밋되지 않은 읽기)**

- 다른 트랜잭션이 아직 커밋하지 않은 데이터를 읽을 수 있습니다.
- `Dirty Read` 발생 가능
- 정합성에 문제가 많은 격리 수준이기 때문에 거의 사용하지 않습니다.

### 2. **Read Committed (커밋된 읽기)**

- 오직 커밋된 데이터만 읽을 수 있습니다.
- `Dirty Read`는 방지하지만, `Non-Repeatable Read`나 `Phantom Read`는 발생 가능합니다.
- RDB에서 대부분 기본적으로 사용되고 있는 격리 수준

### 3. **Repeatable Read (반복 가능한 읽기)**

- 동일한 SELECT 쿼리를 여러 번 실행했을 때 항상 동일한 결과를 보장해 주는 수준
- 자신의 트랜잭션이 생성되기 이전의 트랜잭션에서 COMMIT이 된 데이터만 읽습니다.
    - MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.
- `Dirty Read`, `Non-Repeatable Read`는 방지
- MySQL과 MariaDB 가 기본으로 사용하는 격리 수준

### 4. **Serializable (직렬화)**

- 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준
- 데이터를 접근할 때, 항상 Lock을 걸고 데이터를 조회
- 모든 문제(`Dirty`, `Non-Repeatable`, `Phantom`) 방지
- 성능은 가장 떨어지며, 동시성 낮음
- 주로 보고서, 통계, 강력한 정합성 필요한 곳에서 사용

## 이상 현상

- Dirty Read : 다른 트랜잭션에서 아직 커밋되지 않은(확정되지 않은) 데이터를 읽는 현상
    - 예시 :
        
        
        | 시점 | 트랜잭션 A | 트랜잭션 B |
        | --- | --- | --- |
        | 1 | `UPDATE account SET balance = balance - 100 WHERE id=1;` (커밋 전) | `SELECT balance FROM account WHERE id=1;` → 변경된 값 읽음 (커밋 안 된 데이터) |
        | 2 | `ROLLBACK;` (원래 값으로 되돌림) | (읽었던 데이터는 사실 존재하지 않는 값) |
- Non-Repeatable Read : 같은 트랜잭션 내에서 같은 데이터를 두 번 읽었는데, 중간에 다른 트랜잭션이 그 데이터를 변경해 결과가 달라지는 현상
    
    즉, 데이터가 "읽는 도중"에 바뀌는 것
    
    - 예시 :
        
        
        | 시점 | 트랜잭션 A | 트랜잭션 B |
        | --- | --- | --- |
        | 1 | `SELECT stock FROM product WHERE id=1001;` (값: 10) |  |
        | 2 |  | `UPDATE product SET stock = 8 WHERE id=1001; COMMIT;` |
        | 3 | `SELECT stock FROM product WHERE id=1001;` (값: 8) |  |
- Phantom Read : 트랜잭션이 같은 조건으로 여러 번 SELECT할 때, 중간에 다른 트랜잭션이 새로운 행(row)을 삽입하거나 삭제해서 결과 집합이 달라지는 현상
    
    즉, 동일한 WHERE 조건의 SELECT 결과에 "팬텀(새로운 행)"이 나타나거나 사라지는 것
    
    | 시점 | 트랜잭션 A | 트랜잭션 B |
    | --- | --- | --- |
    | 1 | `SELECT * FROM orders WHERE status='배송중';` (결과: 5행) |  |
    | 2 |  | `INSERT INTO orders VALUES (..., status='배송중'); COMMIT;` |
    | 3 | `SELECT * FROM orders WHERE status='배송중';` (결과: 6행) |  |

# 격리 수준별 실무 적용 시점

| 격리 수준 | 방지 현상 | 실무 적용 시점 | 특징 및 사용 예시 |
| --- | --- | --- | --- |
| **Read Uncommitted** | 없음 | 거의 사용하지 않음 | 테스트/로컬 환경에서의 임시 조회 |
| **Read Committed** | Dirty Read | 일반적인 읽기/쓰기 작업 | 조회 위주의 애플리케이션, 성능 우선 시스템 (예: 게시판, 상품 목록) |
| **Repeatable Read** | Dirty, Non-Repeatable Read | 정합성이 중요한 다중 조회 | 재고 계산, 금융 시스템, 주문 처리 등 **중간에 값이 바뀌면 안 되는 경우** |
| **Serializable** | Dirty, Non-Repeatable, Phantom Read | 강력한 정합성이 필요한 시점에만 제한적으로 | 회계 마감, 월별 통계, 데이터 백업 전 검증 등 |
- 정합성보다 **성능이 중요한 서비스** → `Read Committed`
- 중간 결과가 바뀌면 **심각한 오류 발생 가능성 있는 비즈니스 로직** → `Repeatable Read`
- **정산/회계/보고서/데이터 검증**처럼 **한 치의 오차도 허용되지 않는 경우** → `Serializable`
- **실시간 경향만 빠르게 보기 위한 통계 또는 테스트 환경** → `Read Uncommitted`

# InnoDB의 Undo/Redo 구조

InnoDB 엔진은 MySQL 데이터베이스에서 기본적으로 사용하는 스토리지 엔진입니다.

그리고 InnoDB 엔진은 동시성 제어 방식으로 MVCC를 사용합니다.

## MVCC란?

🔍 데이터베이스 시스템에서 동시성 제어를 관리하는 방법 중 하나입니다. 

즉, 여러 사용자가 동시에 데이터에 접근하거나 수정할 때 충돌 없이 안전하게 처리할 수 있도록 하는 기법입니다.

### MVCC의 핵심 아이디어

MVCC는 트랜잭션마다 자신만의 데이터 ‘버전’을 읽게 해 줌으로써, 읽기 작업과 쓰기 작업이 충돌하지 않도록 한다.

예시: 

- 트랜잭션 A가 `user` 테이블을 읽고 있음
- 동시에 트랜잭션 B가 `user` 테이블의 데이터를 수정하고 커밋함
- 트랜잭션 A는 B의 변경 사항을 보지 않음
- A가 처음 시작할 때의 데이터 스냅샷을 계속 참조함

## Undo 로그란?

🔍 UPDATE 문장이나 DELETE 문장으로 데이터를 변경했을 때 변경되기 전의 데이터(이전 데이터)를 기록하는 로그

UNDO 로그는 두 가지 용도로 사용됩니다. 

1.  MVCC를 구현할 때 과거 버전의 데이터를 제공하기 위해
    - 트랜잭션이 데이터를 수정할 때, InnoDB는 기존 데이터를 Undo 로그에 저장합니다.
    - 다른 트랜잭션이 "예전 시점"의 데이터를 필요로 할 때, Undo 로그를 기반으로 복원하여 보여줍니다.
    - 즉, ****MVCC는 Undo 로그 없이는 동작할 수 없습니다.
2. 트랜잭션이 롤백될 경우, Undo 로그에 저장된 값을 이용하여 변경 이전 상태로 복구할 때
    
    예를 들어 아래의 sql 문이 실행되면
    
    ```sql
    UPDATE member SET name='철수' WHERE member_id = '1';
    ```
    
    트랜잭션을 커밋하지 않아도 실제 데이터 파일 내용은 `철수`로 변경됩니다. 그리고 변경 되기 이전의 값이 `영희`였다면 undo 로그에는 `영희`라는 값이 저장되는 것입니다. 이 상태에서 사용자가 커밋하게 되면 현재 상태가 그대로 유지되고, 롤백하게 되면 undo 로그의 백업된 데이터를 다시 데이터 파일로 복구합니다.
    

## Redo 로그란?

🔍 트랜잭션이 데이터를 변경한 결과(변경 후 값)를 기록하는 로그입니다.

**→** 데이터의 영속성 보장과 관련된 요소로 데이터가 커밋된 후에도 장애가 발생했을 때 복구할 수 있도록 도와줍니다.

## InnoDB가 트랜잭션을 처리하는 흐름

```
트랜잭션이 데이터 수정 시작
    └─> Undo 로그 생성 (이전 버전 저장) ←─ MVCC가 읽을 때 사용
    └─> 데이터 변경
    └─> Redo 로그 생성 (변경 내용 기록)
    └─> 커밋
        └─> Redo 로그로 변경 내용 영구 반영
```

## 장애 발생 시 복구 과정

- 커밋된 트랜잭션은 → Redo 로그로 재실행
    - 트랜잭션이 COMMIT까지 완료된 상태였다면,
    - 디스크에는 아직 완전히 반영되지 않았을 수 있음
    - 이때 Redo 로그에 있는 내용을 다시 실행해서 디스크에 최종 반영함
    
    ➡️ 정상적으로 끝났던 작업을 되살리는 과정
    
- 커밋되지 않은 트랜잭션은 → Undo 로그로 롤백
    - 아직 COMMIT을 안 한 상태였다면,
    - 그 트랜잭션의 변경 내용은 취소해야 함
    - 이때 Undo 로그를 이용해서, 이전 상태로 복원함
    
    ➡️ "없던 일"로 만드는 과정
    

# 읽기에도 트랜잭션이 필요한 경우

1. MVCC 기반으로 과거 시점의 데이터를 조회할 때
    
    **→** MVCC는 “트랜잭션이 시작된 시점의 데이터”를 보여주기 때문에 일관된 결과를 원한다면 SELECT 조차도 트랜잭션 안에서 실행되어야 한다.
    
    예를 들어 아래의 sql 문이 실행되는 경우
    
    ```sql
    START TRANSACTION;
    
    SELECT * FROM orders WHERE status = '배송중'; -- 1번째 실행
    
    -- 누군가 status를 변경함
    
    SELECT * FROM orders WHERE status = '배송중'; -- 2번째 실행
    ```
    
    중간에 다른 사용자가 데이터를 바꿨기 때문에 1번째와 2번째 SELECT의 결과가 달라질 수 있다.
    
    ➡️ ‘일관된 읽기'를 위헤 필요
    
2. 읽고 곧바로 수정해야 할 경우
    
    예: 재고 조회 후 즉시 출고 처리를 해야 할 경우
    
    ```sql
    START TRANSACTION;
    SELECT stock FROM product WHERE id = 1001;
    -- 바로 이어서 재고 감소 처리
    UPDATE product SET stock = stock - 1 WHERE id = 1001;
    COMMIT;
    ```
    
    SELECT로 읽은 후 UPDATE할 때까지 데이터가 바뀌지 않아야 안정적인 처리가 가능하다. 
    
    → 트랜잭션으로 묶지 않으면 위와 같이 중간에 다른 사람이 재고를 변경해버려서 UPDATE 할 때 실제 재고가 달라질 수 있다.
    
    ➡️ '읽고 쓰기 사이의 정합성 보호'를 위해