## 1. 트랜잭션이란?

- 데이터베이스에서 하나의 **논리적 작업 단위**로 모두 성공하거나 모두 실패해야 함 (All or Nothing)
- **정합성 유지와 무결성 보장을 위한 핵심 기능**
- 예: 계좌 이체 시 `A 계좌 -1000원 차감`, `B 계좌 +1000원 추가`는 하나의 트랜잭션으로 묶여야 함

## 2. 트랜잭션의 4대 원칙: **ACID**

**A - 원자성 (Atomicity)**

- 전부 수행되거나, 전혀 수행되지 않아야 함
    
    ex) 계좌 이체 중 오류 시 전체 취소
    

**C - 일관성 (Consistency)**

- 트랜잭션 전후의 상태는 데이터 무결성을 유지해야 함
    
    ex) 이체 후 총금액이 이전과 같아야 함
    

**I - 고립성 (Isolation)**

- 동시에 실행되는 트랜잭션 간 간섭이 없어야 함
    
    ex) 두 사용자의 이체가 서로 영향을 주지 않음
    

**D - 지속성 (Durability)**

- 트랜잭션 완료 후 데이터는 영구 반영되어야 함
    
    ex) DB 서버가 꺼져도 완료된 작업은 유지
    

## 3. 트랜잭션 문제점

### 🍏 **동시성 제어의 복잡성**

- 여러 사용자가 동시에 데이터에 접근하면 충돌 가능성 존재
- 락(Lock)을 걸거나 **MVCC**를 사용하지만, 이는 **복잡한 구현과 성능 저하**를 유발할 수 있음
    
    ex) 둘 이상의 트랜잭션이 같은 데이터를 동시에 수정하면 **데드락**
    

**MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)란?**

동시에 여러 트랜잭션이 같은 데이터를 읽거나 쓰더라도 충돌 없이 처리할 수 있도록 하기 위해 데이터의 여러 버전을 유지하는 방식

**MVCC는 어떤 격리 수준에서 어떤 역할을 하는가?**

- Read Committed vs Repeatable Read에서 MVCC의 동작 차이
- 실제로 **팬텀 리드 방지를 위해 Serializable 수준에서 어떤 방식이 추가되는지** (예: 락 기반 제어)

### 🍏 **데드락(Deadlock)**

- 두 개 이상의 트랜잭션이 서로 상대방이 가진 자원을 기다리면서 **무한 대기** 상태가 됨
- RDBMS는 보통 **트랜잭션 중 하나를 강제로 롤백**시켜 해결
    
    ex)
    
    트랜잭션 A: 테이블 1 → 테이블 2
    
    트랜잭션 B: 테이블 2 → 테이블 1
    
    → 교차 락 걸려 데드락 발생
    

### 🍏 **낙관적/비관적 락 성능 이슈**

- **비관적 락**: 충돌을 방지하려 락을 걸어둠 → **병렬성 저하**
- **낙관적 락**: 충돌 시 롤백 → **재시도 비용 증가**

트래픽이 많거나 동시 수정이 자주 발생하면 트랜잭션 실패율 증가 가능성 있음

### 

### 🍏 **장기 트랜잭션 문제**

- 하나의 트랜잭션이 너무 오래 지속되면 **락이 장시간 유지**되고 **Undo/Redo 로그가 커짐**
- → 다른 트랜잭션이 블로킹되거나 DB 성능이 저하됨
    
    ex) 트랜잭션 시작 후 1분 넘게 커밋하지 않으면 InnoDB 내부적으로 **Undo 공간 압박**
    

### 

### 🍏 **트랜잭션 격리 수준의 딜레마**

- 높은 격리 수준 → **일관성 보장되지만 성능 저하**
- 낮은 격리 수준 → **성능 좋지만 Dirty Read, Phantom Read 등 데이터 이상 발생 위험**

### 🍏 **트랜잭션 관리 코드의 복잡성**

- 애플리케이션에서 트랜잭션을 명확하게 시작/종료하지 않으면 **중간에 일관성 깨질 위험**
- 특히 try-catch 블록에서 예외 발생 시 ROLLBACK 누락 등의 실수 가능

## 4. 트랜잭션 격리 수준 (Isolation Level)

4가지!

## 🍏 **Read Uncommitted (읽기 미확정)**

**특징**

가장 낮은 격리 수준으로 **커밋되지 않은 다른 트랜잭션의 변경사항도 읽을 수 있음**

이 말은 즉, 다른 트랜잭션이 ROLLBACK할 수도 있는 **임시 데이터까지 읽어버릴 수 있다는 것**이기 때문에 데이터 정합성이 깨질 수 있음

**허용되는 이상 현상**

- Dirty Read (더러운 읽기): 아직 커밋되지 않은 데이터를 읽음
- Non-Repeatable Read, Phantom Read 모두 발생 가능
    
    ex) 트랜잭션 A가 계좌에서 잔액을 1000 → 500으로 변경했지만 아직 커밋하지 않음
    
    이때 트랜잭션 B가 이 변경된 500원을 읽어간다면 나중에 A가 ROLLBACK하면 B가 엉뚱한 데이터를 사용한 것이 됨
    

## 🍏 **Read Committed (읽기 확정)**

**특징**

조금 더 안전한 수준 / **커밋된 데이터만 읽을 수 있음** 

**→** Dirty Read는 막을 수 있음 

하지만 **같은 쿼리를 두 번 날리면 결과가 바뀔 수 있음**

**허용되는 이상 현상**

- Non-Repeatable Read (반복 불가능 읽기): 트랜잭션 도중에 다른 트랜잭션이 값을 바꾸면 내가 읽는 값이 달라짐
- Phantom Read (팬텀 읽기): 범위 조건 쿼리에서 중간에 새로운 행이 삽입될 수 있음
    
    ex) A가 한 사용자의 잔액을 읽었고 B가 그 값을 바꿔서 커밋한 뒤 A가 같은 잔액을 다시 읽으면 값이 달라짐
    

## 🍏 **Repeatable Read (반복 가능 읽기)**

**특징**

**같은 쿼리는 언제 실행하든 결과가 항상 동일**하도록 보장함

이 정도면 대부분의 애플리케이션에서 충분히 안정적인 동작을 함

InnoDB에서는 MVCC를 통해 구현함

**허용되는 이상 현상**

- Phantom Read 가능 (다른 트랜잭션이 새로운 행을 추가하면 범위 쿼리 결과는 달라질 수 있음)
    
    ex) A가 SELECT * FROM 상품 WHERE 가격 > 10000 을 실행하고 있는 동안 B가 가격 20000짜리 상품을 INSERT한다면 A가 다시 쿼리하면 그 상품이 보일 수도 있음
    
    하지만 A가 **같은 상품을 두 번 읽는 경우** 값은 항상 같게 보장됨
    

## 🍏 **Serializable (직렬화)**

**특징**

가장 높은 격리 수준으로 **트랜잭션을 마치 순서대로 한 줄로 실행하는 것처럼 처리**함

성능은 가장 떨어지지만 **모든 이상 현상을 방지**할 수 있음

대신, 락을 걸기 때문에 트랜잭션 대기나 병목이 심해질 수 있음

**허용되는 이상 현상**

없음

Dirty Read, Non-Repeatable Read, Phantom Read 모두 방지

ex) 트랜잭션 A가 SELECT * FROM 주문 WHERE 상태 = '배송중'을 실행하는 동안 트랜잭션 B는 이 범위에 영향을 줄 수 있는 INSERT, UPDATE, DELETE를 못하게 됨 (락이 걸림)

## **추가 용어 설명**

- **Dirty Read**: 커밋되지 않은 데이터를 읽는 것
- **Non-Repeatable Read**: 같은 SELECT 문을 두 번 날렸는데 값이 다르게 나오는 것
- **Phantom Read**: SELECT 결과로 나온 행 수가 중간에 삽입/삭제돼서 바뀌는 것

각 수준은 **일관성 vs 성능**의 균형을 다르게 설정한 것이라 실무에선 데이터의 중요성과 시스템 성능을 고려해서 격리 수준을 선택함

가장 자주 쓰이는 수준은 Read Committed (Oracle) 또는 Repeatable Read (MySQL InnoDB 기본값)

### **✅ Oracle**

### **Read Committed (기본)**

- **Dirty Read는 막고**, 성능은 최대한 확보하려는 전략
- Oracle은 MVCC를 활용해서 **커밋된 데이터만 읽도록 보장**하되 **동일 쿼리 반복 시 결과가 바뀌는 건 허용**
- 대부분의 업무에서 “조회 시점에 커밋된 데이터”만 보이면 충분하다는 가정
- → **트랜잭션 격리 수준은 낮추고 성능을 높이는 방향**

### **장점:**

- 병행 처리 성능이 좋음 (락 충돌 적음)
- 애플리케이션이 동시 요청을 많이 처리할 수 있음

---

### **✅ MySQL InnoDB:**

### **Repeatable Read (기본)**

- **읽을 때마다 같은 결과가 나와야 한다**는 신뢰성을 중시
- InnoDB는 **MVCC로 Non-Repeatable Read를 방지**하며 **Phantom Read는 Gap Lock으로 추가 제어**
- MySQL 사용자 층이 주로 웹 서비스 기반이라 **일관된 읽기 결과**가 중요한 경우가 많음
- → 트랜잭션 내부에서 쿼리를 여러 번 실행해도 항상 동일한 결과가 보장되도록 설계

### **장점:**

- SELECT 쿼리 결과가 안정적 → 로직 단순화 가능
- 예측 가능한 결과 → **정합성 유지에 유리**

## 5. InnoDB에서의 트랜잭션 구현: Undo / Redo

### 🍏 Undo Log (롤백용)

- 트랜잭션 중 변경된 **이전 값**을 저장하는 로그
- 롤백 시 이전 상태로 복구
- **MVCC** 기반 Read 작업 시 과거 데이터로 접근 가능
- **InnoDB 테이블스페이스에 저장**

### 🍏 Redo Log (재실행용)

- 디스크에 쓰기 전 **변경 내용을 기록**
- 서버가 비정상 종료되더라도 복구 가능
- **커밋이 완료되면 Redo Log를 디스크에 플러시(반영)**
- **ib_logfile0, ib_logfile1** 같은 **InnoDB 로그 파일에 저장**

### 🍏 트랜잭션 실행 흐름 요약

1. SQL 실행 → **Undo Log** 생성 (과거 값 저장)
2. 메모리에서 변경
3. **Redo Log** 작성 (변경 내용 기록)
4. `COMMIT` 실행 → **Redo Log를 디스크에 저장**
5. 영구 저장소에 실제 반영

## 6. 읽기에도 트랜잭션이 필요한 이유

### 🍏 왜 SELECT만 하는데 트랜잭션을 써야 하나?

- 단순 조회도 **트랜잭션 범위 안에서 일관성 있게 읽기 위해서**임
- 특히 MVCC 환경에서는 과거 시점의 데이터를 조회할 수 있도록 하기 위해 **READ 트랜잭션을 명시**함
    
    ex) **사용자 A가 주문 내역을 분석하는 SELECT를 여러 번 실행하는 동안** 사용자 B가 주문 추가/삭제하는 상황
    
    ```sql
    // 트랜잭션 시작
    START TRANSACTION;
    
    // 잔고 확인
    SELECT balance FROM accounts WHERE user_id = 1;
    
    // 다른 트랜잭션에서 잔고를 수정
    // 내가 읽은 balance가 바뀌지 않게 보장하려면 READ 트랜잭션이 필요함
    
    // 트랜잭션 종료
    COMMIT;
    ```
    
    만약 READ COMMITTED 이하에서는 중간에 값이 바뀌어 SELECT할 때마다 다른 결과가 나올 수 있음