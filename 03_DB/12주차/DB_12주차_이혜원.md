# DB 분산 구조 + 보안(SQL Injection)

### 샤딩 vs 레플리케이션 비교

### **🧩 샤딩 (Sharding)**

> 데이터 자체를 나눠서 서로 다른 DB에 저장
>

### **✅ 목적**

- **쓰기/읽기 둘 다 성능 향상**
- **수평적 확장 (Horizontal Scalability)**

### **✅ 구조**

- 하나의 테이블을 **Row 단위로 분산**
    - 예: User 11000 → DB1, User 10012000 → DB2
- 각 DB는 **전체 데이터의 일부만** 가지고 있음

**샤딩 방식**

| **방식** | **설명** | **특징** |
| --- | --- | --- |
| **Hash Sharding** | 해시 함수를 사용해 분배 | 간단하지만 서버 추가 시 전체 해시 재배치 필요 → **확장성 떨어짐** |
| **Dynamic Sharding (Locator Service)** | 샤드 위치를 테이블로 관리 | 확장 쉬움, Locator 장애 시 전체 시스템 영향 (SPOF) |
| **Entity Group Sharding** | 연관된 데이터를 같은 샤드에 저장 | 관계형 DB에 적합 (예: user, post, comment 한 곳에) |

---

### **🔁 레플리케이션 (Replication)**

> 같은 데이터를 여러 DB 서버에 복제해서 저장
>

### **✅ 목적**

- **고가용성 (High Availability)**
- **장애 복구 (Disaster Recovery)**
- **읽기 성능 향상 (Read Scale-out)**

### **✅ 구조**

- **Master - Slave 구조**
    - Master DB: 쓰기 전용
    - Slave DB: 읽기 전용 (복제된 데이터 활용)

### **✅ 장점**

- Master 장애 시 → Slave로 빠른 전환 가능
- 읽기 요청을 여러 Slave로 분산 → 성능 향상
- 지역 이중화 가능 → 재해 복구

### **✅ 단점**

- 쓰기 성능은 개선 ❌
- 데이터 일관성 문제 발생 가능 (Replication 딜레이 등)

| **구분** | **레플리케이션** | **샤딩** |
| --- | --- | --- |
| 목적 | **가용성, 읽기 성능 향상** | **성능, 수평적 확장** |
| 구조 | **같은 데이터를 여러 DB에 복제** | **데이터를 나눠서 저장** |
| 쓰기 성능 | ❌ 개선 안 됨 | ✅ 개선됨 |
| 읽기 성능 | ✅ Slave를 통해 향상 | ✅ 샤드별로 병렬 처리 |
| 장애 대응 | ✅ Master 장애 시 전환 가능 | ⚠️ 일부 샤드 장애 시 데이터 접근 제한 |
| 사용 사례 | 읽기 많은 서비스 (뉴스, 블로그 등) | 대용량 서비스 (쇼핑몰, SNS 등 |

> 레플리케이션 → *데이터 중복 + 고가용성*
>

> 샤딩 → *데이터 분산 + 성능 최적화*
>

---

### 마스터-슬레이브 동기화와 정합성 유지 방법

### **💡 DB 다중화란?**

> 단일 DB가 장애나 과부하로 인해
>
>
> **서비스 중단**
>

> 복수의 DB 인스턴스를 운영
>

### **✅ 목적**

- 장애 시 빠른 복구 (Failover)
- 읽기 부하 분산
- 데이터 유실 최소화

**⚙️ Master - Slave 아키텍처**

| **역할** | **설명** |
| --- | --- |
| **Master** | 모든 **쓰기(Write)** 작업 처리 |
| **Slave** | **읽기(Read)** 전용, Master의 데이터를 **복제**받아 동기화 유지 |

일반적으로 **읽기 연산 비중이 더 크기** 때문에, 이 구조를 통해 읽기 부하 분산 가능하다

### **복제 방식**

### **1) Semi-Sync Replication**

> MySQL 5.5부터 도입된 **반동기식 복제**
>

### **✅ 동작 방식**

- Master는 **트랜잭션 커밋 전에** 최소 **1대 Slave가 릴레이 로그를 받았는지 확인**
- 그 1대만 로그를 받으면 커밋 완료
- 모든 Slave를 기다리지 않기 때문에 **성능 저하 최소화**

### **✅ 장점**

- 완전한 동기화보다 성능 유리
- 비동기 복제보다 정합성 보장
- **데이터 유실 최소화** 가능

### **장애 복구 방식**

### **MHA (Master High Availability)**

> Master 장애 발생 시, 자동으로 Slave를 Master로 승격해주는 **오픈소스 HA 솔루션**
>

### **✅ 구성 요소**

- **Manager**: 상태 모니터링, 장애 감지 및 전환 수행
- **Slave**: 자동 승격 대상

### **✅ 작동 방식**

- Master 장애 감지 → 최신 Slave를 Master로 **자동 승격 (Failover)**
- **데이터 손실 최소화**를 위해 Relay Log 복구도 자동 수행

---

### **결합 전략**

### **Semi-Sync Replication + MHA**

> 가장 실무에서 많이 사용되는 안정적인 구성
>

### **💪 장점 요약**

- **최소 1대에 동기화 완료 보장 (Semi-Sync)**
- **장애 발생 시 빠른 자동 전환 (MHA)**
- **데이터 유실 가능성 최소화**

---

### **⚠️ 다중화 유의점**

- DB는 **Persistence Layer (영속성 계층)** → 단순 병렬화처럼 다루면 안 됨
- 동기화 지연, 정합성 유지, 트랜잭션 일관성 등에 대한 **정교한 전략 필요**
- 마스터/슬레이브 간의 **레이턴시(지연)** 고려해야 함

---

## **✅ 한 줄 요약**

> 단일 장애 지점을 막기 위한
>
>
> **DB 다중화**
>

> Semi-Sync 복제
>

> MHA로 빠른 장애 복구(Failover)를 실현할 수 있다.
>

### 트랜잭션의 분산 환경 처리– SQL Injection 원리

- SQL Injection이란

  > 해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법
  >
    - 웹 사이트의 보안상 허점을 이용해 특정 SQL 쿼리 문을 전송하여 공격자가 원하는 데이터베이스의 중요한 정보를 가져오는 해킹 기법.
    - 클라이언트가 입력한 데이터를 제대로 필터링 하지 못하는 경우 발생.
    - 공격 난이도가 쉬운데 비해 피해 규모가 큼.


**SQL Injection의 진행의 예**

- 각 클라이언트가 자격증 번호를 조회할 수 있는 시스템.
- SQL 진행은 anjinma 클라이언트가 '자격증 번호 조회'를 클릭하여 anjinma 라는 이름이 웹서버에 전송되고 DB에 입력한 값과 일치하면 자격증 DB를 출력해준다.
- blackhat 클라이언트는 anjinma 클라이언트의 자격증 번호를 조회하기 위해서 SQL문을 수정하지만 권한이 없어서 자격증 정보를 가져올 수 없다.
- ex) http://license12345.com/mysearch?=anjinma url을 전송할때 anjinma가 로그인 되어있으면 정상적으로 자격증 번호를 조회할 수 있지만 blackhat이 로그인 되어있으면 자격증 번호를 조회할 수 없다.
- 공격자인 blackhat은 url뒤에 ' or '1'='1'을 넣어줘서 항상 참이 되게 만들어서 자격증 번호를 조회해 온다.

**공격 방법**

**1) 인증 우회**

보통 로그인을 할 때, 아이디와 비밀번호를 input 창에 입력하게 된다. 쉽게 이해하기 위해 가벼운 예를 들어보자. 아이디가 abc, 비밀번호가 만약 1234일 때 쿼리는 아래와 같은 방식으로 전송될 것이다.

```
SELECT * FROM USER WHERE ID = "abc" AND PASSWORD = "1234";

```

SQL Injection으로 공격할 때, input 창에 비밀번호를 입력함과 동시에 다른 쿼리문을 함께 입력하는 것이다.

```
1234; DELETE * USER FROM ID = "1";

```

보안이 완벽하지 않은 경우, 이처럼 비밀번호가 아이디와 일치해서 True가 되고 뒤에 작성한 DELETE 문도 데이터베이스에 영향을 줄 수도 있게 되는 치명적인 상황이다.

이 밖에도 기본 쿼리문의 WHERE 절에 OR문을 추가하여 `'1' = '1'`과 같은 true문을 작성하여 무조건 적용되도록 수정한 뒤 DB를 마음대로 조작할 수도 있다.

**2) 데이터 노출**

시스템에서 발생하는 에러 메시지를 이용해 공격하는 방법이다. 보통 에러는 개발자가 버그를 수정하는 면에서 도움을 받을 수 있는 존재다. 해커들은 이를 역이용해 악의적인 구문을 삽입하여 에러를 유발시킨다.

즉 예를 들면, 해커는 **GET 방식으로 동작하는 URL 쿼리 스트링을 추가하여 에러를 발생**시킨다. 이에 해당하는 오류가 발생하면, 이를 통해 해당 웹앱의 데이터베이스 구조를 유추할 수 있고 해킹에 활용한다.

**방어 방법**

**1) input 값을 받을 때, 특수문자 여부 검사하기**

> 로그인 전, 검증 로직을 추가하여 미리 설정한 특수문자들이 들어왔을 때 요청을 막아낸다.
>

**2) SQL 서버 오류 발생 시, 해당하는 에러 메시지 감추기**

> view를 활용하여 원본 데이터베이스 테이블에는 접근 권한을 높인다. 일반 사용자는 view로만 접근하여 에러를 볼 수 없도록 만든다.
>

**3) preparestatement 사용하기**

> preparestatement를 사용하면, 특수문자를 자동으로 escaping 해준다. (statement와는 다르게 쿼리문에서 전달인자 값을 ?로 받는 것) 이를 활용해 서버 측에서 필터링 과정을 통해서 공격을 방어한다.
>

| **항목** | **설명** |
| --- | --- |
| **정의** | 입력값을 SQL 쿼리에 직접 삽입해 DB 조작하는 기법 |
| **위험성** | 인증 우회, 데이터 유출/파괴, 시스템 침해 등 |
| **방어 방법** | ① 입력값 검증② 에러 메시지 숨김③ PreparedStatement 사용 |

---

### PreparedStatement, ORM 보호 방법

### **1. PreparedStatement (준비된 문)이란**

> SQL 구문과 사용자 입력값을 분리하며, 입력값을 문자열이 아닌**“데이터”로만 해석**
>

| **항목** | **설명** |
| --- | --- |
| 구조 분리 | SQL 구조(문장)와 입력값을 명확히 분리 |
| 자동 이스케이프 | 입력값에 포함된 특수문자(', ", ;, --)를 자동으로 무해화 |
| 성능 최적화 | 동일 SQL 반복 실행 시 컴파일 생략으로 속도 향상 (DB 캐싱 활용) |
| 유지보수 용이 | SQL 코드가 가독성 높고, 에러 추적이 쉬움 |

```java
String sql = "SELECT * FROM users WHERE id = ? AND password = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1, userId);       // 사용자 입력값
pstmt.setString(2, userPw);       // 사용자 입력값

ResultSet rs = pstmt.executeQuery();  // 안전하게 실행
```

### **주의사항**

- SQL 구조 자체를 동적으로 바꾸는 경우 (e.g., 컬럼명 직접 넣기)는 여전히 취약할 수 있음

  → 이 경우는 화이트리스트 방식으로 컬럼명 제한 필요


### **2. ORM (Object-Relational Mapping)**

> 객체 지향 언어의 객체와 RDB의 테이블을 자동 매핑한다.
SQL 쿼리를 직접 작성하지 않고, **객체를 조작하여 DB에 접근한다**
>

- 보안 효과

| **항목** | **설명** |
| --- | --- |
| 직접 SQL 작성 ❌ | 대부분 쿼리를 ORM 프레임워크가 내부적으로 생성 |
| PreparedStatement 기반 | 내부적으로 PreparedStatement를 사용하여 **자동 이스케이프** |
| 파라미터 바인딩 | 개발자가 값을 전달할 때 ORM이 자동으로 처리하여 SQL 구조 훼손 방지 |

- **ORM도 주의가 필요한 경우**

| **위험 상황** | **설명** |
| --- | --- |
| **JPQL/쿼리 직접작성** | 문자열 연결(+) 방식으로 쿼리를 작성하면 **SQL Injection 위험 존재** |
| **Native Query 사용** | DB에 종속적인 SQL을 직접 작성해야 할 경우, PreparedStatement처럼 파라미터 바인딩을 철저히 해야 함 |
| **동적 쿼리 조합** | WHERE 절에 조건을 동적으로 추가할 때는 안전한 빌더(QueryDSL, CriteriaBuilder) 사용 권장 |
- 안전한 동적 쿼리 조합 방식(ex. QueryDSL)

```java
//  SQL Injection 걱정 없이 안전하게 파라미터 바인딩 처리
QUser user = QUser.user;
JPAQuery<?> query = new JPAQuery<>(entityManager);

List<User> results = query
    .select(user)
    .from(user)
    .where(user.email.eq(email))
    .fetch();
```

| **항목** | **PreparedStatement** | **ORM** |
| --- | --- | --- |
| 역할 | SQL 쿼리 구조와 입력값 분리 | SQL을 직접 쓰지 않고 객체로 DB 조작 |
| 보안 효과 | 특수문자 자동 escape 처리 | 내부적으로 PreparedStatement 기반 |
| 주의점 | 쿼리 구조를 문자열로 만들면 위험 | Native Query, JPQL 문자열 조합은 주의 |
| 추천 사용 | 직접 쿼리 작성이 필요한 경우 | 서비스 규모 커질수록 유지보수에 유리 |

> PreparedStatement는 SQL 구조와 값을 분리하여 직접적인 SQL Injection을 막고,
>

> ORM은 개발자가 SQL을 직접 다루지 않아도 안전한 DB 접근을 가능하게 해주는 추상화 계층이다
>