# DB 분산 구조 + 보안(SQL Injection)


## 💖 샤딩 VS 레플리케이션 비교

**등장 이유**

<aside>
🍀

데이터베이스가 작을 때는 1개의 db에 읽고 쓰기 요청 모두 가능

하지만, 사용자가 많아지고, 데이터가 커지고, 동시 접속이 많아지면

1개의 db만으로는 성능 부족 ⇒ 데이터를 여러 db에 나눠 저장하는 기술 등장

=⇒ 레플리케이션과 샤딩

</aside>

<br>


### 🍞 샤딩-(데이터 분할)

- 한 개의 테이블 데이터를 너무 많이 쌓지 않고, **특정 기준으로 나눠서** 여러 DB(혹은 테이블)에 나눠 저장하는 것(ex, userId를 기준으로 나눠 저장)

<br>

**필요 이유**

- 테이블 하나에 너무 많은 데이터가 들어가면 읽기, 쓰기 모두 느려짐
    - ⇒ 데이터를 쪼개서 여러 db에 분산
- 각 db는 서로 다른 데이터 저장 ⇒ 저장 용량과 성능 모두 향상

<br>

**장점**

- 데이터 분산 저장 → 저장 용량, 처리 성능 향상
- 쓰기 병목 현상 감소

<br>

**단점**

- 데이터를 나누는 기준(샤딩 키) 설계가 중요
- 여러 샤드에서 JOIN 불가능 or 복잡함
- 트랜잭션 처리 어려움

<br>
<br>

### 🍞 레플리케이션-(데이터 복제)

- 하나의 DB(Master)에 저장된 데이터를 다른 DB(Replica)로 복사해서 똑같이 유지하는 것(복제본 생성)

<br>

**필요 이유**

- 데이터 읽기 요청이 너무 많을 때 DB 하나로는 부족
    - 읽기는 Master, 쓰기는 Replica로 분리
- 하나에서 장애 발생 시 예비 DB로 사용

<br>

**장점**

- 읽기 부하를 여러 Replica에 분산
- 장애 시 복제본을 예비 DB로 사용 가능
- 설정이 비교적 간단

<br>

**단점**

- Master에만 쓰기 가능 → 쓰기 병목 가능
- 데이터 복제는 시간 차가 있어서 **복제 지연(latency)** 발생 가능

<br>
<br>

### 🥨 마스터- 슬레이브 동기화와 정합성 유지 방법

마스터-슬레이브 구조의 핵심 과제 : **동기화**, **정합성**

![image](https://github.com/user-attachments/assets/5876fda1-e641-4a05-9e28-998ba70c8f3c)


- 마스터 DB: **쓰기 전용**
- 슬레이브 DB: **읽기 전용**
- 마스터에서 일어난 INSERT/UPDATE/DELETE를 **슬레이브로 전달해주는 구조**

<br>

**동기화 - 비동기 복제(기본 방식)**

- 마스터에서 쓰기가 끝나면 바로 클라이언트 응답
- 슬레이브에는 나중에 마스터의 변경사항을 읽어 반영
- 장점 : 빠른 쓰기 속도
- 단점 : 복제 지연 발생 가능

<br>

**동기화 - 반동기 복제**

- 마스터가 슬레이브 최소 1개가 데이터를 수신했다는 응답을 받을때까지 기다림
- 이후 클라이언트 응답
- 장점 : 완전한 비동기 복제 방식보다는 정합성이 높음
- 단점 : 슬레이브가 지연되면 마스터도 지연 발생 가능

<br>

**동기화 - 동기 복제**

- 마스터가 모든 슬레이브에게 데이터를 전달하고 응답을 받을 때까지 쓰기를 완료하지 않음
- 장점 : 완벽한 정합성 유지 가능
- 단점 : 슬레이브 중 하나라도 느리면 전체 쓰기 성능에 영향, 실무에서는 거의 사용하지 않음

<br>

**정합성 유지를 위한 조건**

1. **지연 감지와 처리**
    - 슬레이브의 **복제 지연 시간(`Seconds_Behind_Master`)**을 모니터링
    - 일정 시간 이상 지연되면 **읽기 요청을 마스터로 보내도록 우회**
2. **쓰기 후 읽기 정합성**
    - 클라이언트가 마스터에 **쓰기 요청**한 직후 → **슬레이브에서 읽으면 반영이 안 되어 있을 수 있음**
    - 따라서 쓰기 직후에는 마스터에서 바로 읽도록 강제 설정
3. **GTID(Global Transaction ID)**
    - 트랜잭션마다 고유 ID 부여
    - 슬레이브가 복제한 트랜잭션을 정확히 추적 가능
    - 충돌 없이 마스터 변경(=Failover) 가능

<br>

**정합성이 깨지는 주요 원인들**

| 원인 | 설명 |
| --- | --- |
| 복제 지연 | 슬레이브가 binlog를 아직 다 처리 못함 |
| 네트워크 문제 | 마스터와 슬레이브 간 동기화 끊김 |
| 슬레이브 장애 | 특정 슬레이브가 동기화 멈춤 (중단되었거나 늦음) |
| 복제 오류 | 충돌이나 권한 문제로 슬레이브에서 복제 실패 |

<br>

### 🍞 샤딩 VS 레플리케이션

![image](https://github.com/user-attachments/assets/4ec0f427-c963-4f44-8861-1d54da3568b1)

<br>

### 🍞 실무에서는?

보통 레플리카와 샤딩을 함께 씀

- Shard마다 Replica를 둬서 **읽기/쓰기 + 장애 대응 가능**
- 즉, **"샤딩된 Master" + "샤딩된 Replica"** 구조가 실무에 많음

<br>
<br>

## 💖 트랜잭션의 분산 환경 처리

![image](https://github.com/user-attachments/assets/87fead8c-585c-46c6-b00c-7710a69721b9)

<br>

**분산 트랜잭션 : 하나의 트랜잭션이 여러 데이터베이스(DB)** 또는 **여러 서비스**에 걸쳐 있는 것

ex) 

- A 서비스에서 사용자 정보를 저장하면서
- B 서비스의 결제 DB에도 동시에 기록해야 할 때

<br>

**문제점**

- 단일 DB에서는 트랜잭션이 간단히 commit/rollback으로 끝나지만,
- **여러 시스템에 걸치면 한쪽은 성공, 한쪽은 실패하는 문제가 생김**

<br>

**해결 방법**

**(1) 2PC (Two-Phase Commit)**

- **분산 트랜잭션을 동기적으로 처리**하는 전통적 방식
- coordinator가 모든 DB에 준비 여부를(prepare) 물은 후,
- 모두 OK면 → commit / 누군가 실패 → rollback
- **단점**: 동기 방식이라 **느리고, 실패 시 교착 상태 위험**

<br>

**(2) SAGA 패턴**

- **비동기 분산 트랜잭션 처리 방식**
- 각 단계가 완료되면 **다음 단계로 넘어가고**, 실패 시에는 **보상(Compensation) 트랜잭션** 수행
- **장점** : 마이크로서비스에서 자주 쓰임
- **단점** : 보상 트랜잭션을 직접 설계해야 해서 복잡

<br>

### SQL Injection 원리

: 사용자 입력값을 통해 의도하지 않은 SQL을 삽입(inject)해서 DB를 조작하는 공격

```java
String id = request.getParameter("id"); // 사용자 입력값: ' OR 1=1 --
String sql = "SELECT * FROM users WHERE id = '" + id + "'";

→ 실제 실행:
SELECT * FROM users WHERE id = '' OR 1=1 --';
→ 모든 유저 정보 노출됨!
```
<br>

### PreparedStatement, ORM 보호 방법

(1) PreparedStatement

**SQL 쿼리와 파라미터를 분리**해서 처리함으로써, 입력값을 단순한 문자열이 아닌 **값**으로 처리

 (2) ORM (예: JPA, Hibernate, MyBatis 등)

- 대부분 내부적으로 PreparedStatement를 사용
- 파라미터 바인딩을 통해 SQL Injection을 **자동으로 방지**
