블로그 정리
- [DB 분산 구조](https://0woy.tistory.com/entry/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EB%B6%84%EC%82%B0-%ED%99%98%EA%B2%BD-%EC%B2%98%EB%A6%AC)
- [트랜잭션 분산 환경 처리](https://0woy.tistory.com/entry/DB-%EB%B6%84%EC%82%B0-%EA%B5%AC%EC%A1%B0)
- [SQL Injection](https://0woy.tistory.com/entry/SQL-Injection)

---


## DB 분산 구조

DB 분산 구조는 말 그대로 **DB를** **여러 개의 서버에 나누어 저장하고 관리하는 시스템**을 의미함

단일 DB 시스템이 가질 수 있는 한계 (성능, 용량, 가용성 등)을 극복하고, 더욱 확장성 있고 안정적인 서비스를 제공하기 위해 도입된 개념

### DB 분산 구조를 사용하는 이유

단일 데이터 베이스는 아래와 같은 한계를 가짐

1.  **성능 한계**
    -   모든 R/W 요청이 하나의 서버로 집중되면, 서버의 CPU, 메모리, I/O 자원이 고갈되어 처리 속도가 급격히 느려짐
    -   데이터 양이 방대해지면 **인덱스를 사용해도 쿼리 속도가 저하**됨
2.  **용량 한계**
    -   하나의 서버에 저장할 수 있는 데이터 양에는 물리적 한계 존재
    -   데이터가 계속 증가하면, 언젠가는 공간 부족
3.  **가용성 문제**
    -   단일 서버에 장애가 발생하면 전체 서비스가 중단될 수 있음

DB 분산 구조는 위와 같은 문제들을 해결하기 위해 데이터와 작업을 여러 서버에 분산하여 효율적으로 관리함

---

### DB 분산 구조의 핵심 목표

| **목표** | **설명** |
| --- | --- |
| 확장성 | 데이터 양이나 사용자 수가 증가해도, 시스템의 **성능을 유연하게 확장** |
| 고가용성 | 시스템 일부에 장애가 발생해도 **서비스 중단 없이 제공** |
| 성능 향상 | 데이터와 요청을 분산해 처리 **속도를 높이고 응답 시간 단축** |
| 신뢰성 | 데이터 손실 위험을 줄이고 장**애 발생 시 복구 용이** |

> **📌 수직 확장 / 수평 확장**  
> \- **수직 확장**: 더 좋은 하드웨어를 추가하여 성능을 높이는 방식  
> \- **수평 확장**: 서버의 대수를 늘려 성능을 높이는 방식 (DB 분산 구조는 주로 수평 확장을 목표로 함)

---

#### DB 분산 구조의 주요 기법

1.  레플리카 (Replication - 복제)
2.  샤딩 (Shading - 분할)
3.  파티셔닝 (Partitioning)
4.  etc...

---

## 레플리카 (Replication)

레플리카 (= 복제) 는 DB의 복사본을 여러 개 만드는 것을 의미

주로 **\`Master-Slave\`** (또는 Primary-Secondary) 구조로 구성

-   **Master 서버** : 모든 **쓰기 (Insert, Update, Delete) 작업** 처리
-   **Slave 서버:** Master 서버로부터 데이터를 복제하여 **읽기(Select) 요청 처리**

![1](https://github.com/user-attachments/assets/2bb78110-a430-4432-a406-4f60240cb2d3)


#### 장점

| **장점** | 설명 |
| --- | --- |
| **읽기 성능 향상** | 여러 Slave 서버로 **읽기 트래픽을 분산**하여 전체적인 읽기 성능 향상 |
| **고가용성 확보**  | Master 서버에 장애가 발생하더라도 **Slave 서버 中 하나를 Master로 승격**시켜 서비스 중단 최소화 |
| **데이터 백업/ 복구** | 복제본을 활용하여 데이터 백업 및 재해 복구에 활용 |

#### 단점

| **단점** | 설명 |
| --- | --- |
| **쓰기 성능의 한계** | 모든 쓰기 작업은 Master에서만 이루어지므로, **쓰기 트래픽이 많아지면 Master 서버 병목** |
| **데이터 일관성 문제** | 대부분의 복제는 비동기 방식, Master와 Slave 간 데이터 동기화 지연 발생 가능   \= 일시적 데이터 불일치 발생 |
| **운영 복잡성** | Master-Slave 구조 관리, 장애 발생 시 Failover 처리 등 운영 측면의 복잡성 존재 |

---

### 예시: 온라인 쇼핑몰 웹사이트

온라인 쇼핑몰에 매우 많은 고객들이 접속하여 상품 정보를 조회하고 주문하려는 상황

1.  **초기 상태:**
    -   DB 서버 1대 존재 (Master)
    -   모든 고객의 상품 조회 (읽기) & 주문 (쓰기) 요청이 해당 서버에 몰림
2.  **문제 발생**:
    -   특정 시간대에 동시 접속자가 폭주하면 서버에 과부하가 걸려 웹사이트가 느려지거나 먹통도미
    -   만일 해당 서버가 고장 나면, 쇼핑몰 서비는 완전히 중단됨
3.  **레플리카 적용**:
    -   DB 서버를 2대 더 추가하여 총 3대 운용 (Master:1대, Slave:2대)
    -   \`**Master 서버**\`: 모든 주문(쓰기) 요청을 처리하고, 최신 데이터를 가짐
    -   \`**Slave 서버\`**: Master 서버의 데이터를 실시간 복제하여 가짐  
        모든 상품 조회 요청은 해당 두 서버로 분산
    -   만일 Master 서버가 고장 나면, Slave 서버 중 하나를 새로운 Master로 승격하여 서비스 중단 최소화
4.  **결과**:
    -   상품 조회 속도 상승, 더 많은 고객들이 접속해도 원활히 서비스 이용 가능
    -   서버 한 대가 고장 나도 서비스가 중단되지 않고 운영됨

> 📌 레플리카는 데이터를 **여러 대의 서버에 복사해서 저장하고, 주로 읽기 성능 향상과 고가용성 확보**에 사용

---

### ❓Master - Slave간 실시간 동기화는 어떻게 이루어지는가

실시간 동기화: Master에서 발생하는 모든 쓰기 작업을 Slave로 전파하는 과정

주로 다음과 같은 메커니즘을 통해 이루어짐

#### **로깅 (Logging):** WAL (Write-Ahead-Logging) / 바이너리 로그 (Binary Log/ Binlog)

대부분의 RDB는 **트랜잭션이 커밋되기 전**에 **모든 변경 사항을 선행 기록 로그(WAL) 라는 특별한 파일에 기록**함

이 로그는 데이터 파일 자체에 변경 사항이 적용되기 전에 모든 트랜잭션의 기록을 남김

> PostgreSQL: WAL 파일 사용 / MySQL: 바이너리 로그 사용

#### 로그 전송 (Log Shipping)

-   Master 서버의 데이터 변경 사항이 기록된 로그 파일(또는 로그 스트림)을 Slave에 전달
-   Slave 서버는 이 로그를 받아 자신이 가지고 있는 데이터에 동일한 변경 사항을 순서대로 적용

---

#### 동기화 방식

동기화 방식에 따라 **실시간의 정도**와 **데이터 정합성의 강도**가 달라짐

#### **1\. 비동기 복제 (Asynchronous Replication)**

가장 흔하게 사용되는 방식으로, **마스터(Master) 서버의 쓰기 성능을 최우선**

-   **동작 방식:**
    1.  마스터는 트랜잭션을 커밋하고 사용자에게 즉시 성공을 알림
    2.  이후 백그라운드에서 변경된 로그를 슬레이브(Slave) 서버로 전송
    3.  슬레이브는 로그를 받아 자신의 데이터에 변경 사항을 적용.
-   **실시간성 및 정합성:**
    -   슬레이브가 마스터보다 약간 뒤처질 수 있음. 이 지연을 \`**복제 지연(Replication Lag)\`** 이라 칭함
    -   이로 인해 마스터에서는 최신 데이터를 볼 수 있지만, 슬레이브에서는 일시적으로 이전 데이터를 읽게 되는  
        **\`데이터 불일치\`**가 발생할 가능성 有
    -   결국은 모든 데이터가 일치하는 \`**결과적 일관성(Eventual Consistency)\`**을 가짐
-   **장점:** 마스터의 쓰기 성능에 거의 영향을 주지 않아 높은 처리량을 유지
-   **단점:** 마스터 장애 발생 시, 아직 슬레이브로 전파되지 않은 최신 데이터는 유실될 수 있음

> 📌 가장 널리 사용되나, 정합성 문제를 완화하기 위한 추가적 고려 必

---

#### **2\. 동기 복제 (Synchronous Replication)**

**데이터 정합성을 최우선**으로 하는 방식

-   **동작 방식:  
    **마스터는 트랜잭션을 커밋하기 전에, 해당 변경 로그가 **모든 슬레이브에 성공적으로 수신되고 응답까지 받아야**  
    커밋을 완료하고 사용자에게 성공을 알림
-   **실시간성 및 정합성:**
    -   마스터와 슬레이브 간의 데이터가 거의 완벽하게 일치합니다.  
        "실시간 동기화"에 가장 가깝고, 항상 최신 데이터를 읽을 수 있는 \`**강한 일관성(Strong Consistency)**\`을 보장
-   **장점:** 마스터 장애 시에도 데이터 유실이 전혀 없습니다.
-   **단점:**
    -   슬레이브의 응답을 기다려야 하므로 **마스터의 쓰기 성능이 저하**
    -   네트워크 지연이나 슬레이브 서버의 성능 문제에 매우 민감
    -   모든 슬레이브가 동시에 다운되면 마스터도 쓰기 작업을 할 수 없게 되어 서비스가 블록될 수 있음

> 📌 복제 시스템 자체가 강한 일관성을 보장하도록 설계되어 있으므로, 별도의 애플리케이션 레벨의 정합성 보장 로직이 거의 필요 없음  
> 👉 쓰기가 성공했으면, "_**모든 복제본에서 즉시 읽을 수 있다**_"는 강력한 보장 제공

---

#### **3\. 준동기 복제 (Semi-Synchronous Replication)**

동기 복제와 비동기 복제의 절충안으로, **데이터 유실 위험을 줄이면서 성능 저하를 완화**

-   **동작 방식:  
    **마스터는 트랜잭션을 커밋하기 전에, 모든 슬레이브가 아닌 **최소한 하나 이상의 슬레이브가 변경 로그를 수신했음을 확인하면** 커밋을 완료하고 사용자에게 성공을 알림
-   **실시간성 및 정합성:**비동기 복제보다는 정합성이 높고, 동기 복제보다는 성능 저하가 덜함
-   **장점:** 데이터 유실 위험을 줄이면서도 동기 복제보다 마스터의 성능 저하가 적음
-   **단점:**
    -   여전히 성능 오버헤드 존재
    -   설정된 최소 슬레이브 수가 특정 시점에 응답하지 못하면 마스터의 쓰기 작업이 블록될 수 있음

> 📌 동기 복제와 유사하게, 어느 정도의 정합성을 시스템 자체적으로 보장

---

### ❓ 비동기 방식에서 데이터 정합성 유지는 어떻게 하는가

Master-Slave 복제는 기본적으로 마스터에만 쓰기작업이 발생하고, 슬레이브는 읽기 작업을 처리함

이 구조에서 정합성을 유지한다는 것은 주로 "_**Slave에서 읽는 데이터가 얼마나 최신 상태인가**_" 그리고 "_**장애 발생 시 데이터 유실을 어떻게 최소화하는가"**_에 초점이 맞춰짐

#### 복제 지연 모니터링 및 관리

비동기 복제의 가장 큰 문제인 **복제 지연을 관리**하는 것이 정합성 유지의 핵심

-   **지속적인 복제 지연 모니터링:** \`Seconds\_Behind\_Master\` (MySQL) 또는 \`pg\_stat\_replication\` (PostgreSQL) 같은 지표를 사용하여 **슬레이브가 마스터로부터 얼마나 뒤처져 있는지** 지속적으로 모니터링
-   **알림 및 경고:** 복제 지연이 임계값을 초과하면 즉시 운영팀에 알림
-   **자동화된 조치:** 심각한 지연 발생 시 **해당 슬레이브로의 읽기 요청을 일시적으로 중단**하거나, **아예 복제에서 제외**시키는 자동화된 스크립트를 구현 (예: 헬스체크 실패 시 로드밸런서에서 제외)
-   **워크로드 분리 및 최적화:** 마스터와 슬레이브의 네트워크 대역폭, I/O 성능 등을 최적화하여 복제 지연 자체를 최소화

---

#### 2\. 읽기 요청의 라우팅 전략 (Read Routing Policies)

**어떤 상황에서 어느 서버로부터 읽기 요청을 처리**할 것인지 명확히 정의하여 정합성 문제를 완화

-   **Master 읽기 (Read-Your-Writes Consistency):**
    -   사용자가 데이터를 쓰자마자(Master) 바로 이어서 자신의 데이터를 읽는 상황(예: 게시물 작성 후 바로 목록에서 확인)에서, **슬레이브의 복제 지연으로 인해 이전 데이터를 읽는 문제 방지**
    -   **방법:** 특정 시간(예: 5초) 동안 **해당 사용자의 모든 읽기 요청을 마스터로 라우팅**하거나,  
        **세션 정보에 최근 쓰기 작업 여부를 저장**하여 마스터로 직접 읽도록 강제
    -   **단점:** 마스터에 읽기 부하가 가중
-   **일관성 요구 수준에 따른 라우팅:**
    1.  **높은 정합성 요구 (예: 결제 확인, 중요한 사용자 정보 조회):  
        ** 항상 마스터에서 읽도록 강제
    2.  **느슨한 정합성 허용 (예: 인기 게시물 목록, 캐시 데이터):**  
        슬레이브에서 읽도록 하여 읽기 부하를 분산
    3.  **N초 이내의 데이터만 허용:  
        **N초 이내의 복제 지연을 가진 슬레이브로만 라우팅하고, 그렇지 않은 슬레이브는 잠시 격리

---

#### 4\. 데이터 손실 방지 및 복구 전략 (Durability & Recovery)

정합성 유지는 단순히 데이터가 "최신"인가뿐만 아니라, "**유실되지 않는가**"와도 관련

-   **WAL(Write-Ahead Log) / 바이너리 로그 (Binary Log)의 안정적인 관리:**
    -   마스터에서 발생하는 모든 변경 사항은 이 로그 파일에 기록되므로,  
        이 로그 파일 자체가 손상되거나 유실되지 않도록 안정적인 스토리지(RAID, 네트워크 스토리지 등)에 저장
    -   로그 파일의 백업 및 보존 정책을 수립
-   **정기적인 백업:  
    **데이터베이스 전체의 정기적인 백업(풀 백업, 증분 백업)은 최악의 상황(모든 복제본 손상)에 대비한 최종적인 정합성 유지 및 복구 수단
-   **복구 프로세스 수립:**
    -   마스터 장애 시 슬레이브를 새로운 마스터로 승격시키는 \`**페일오버(Failover)\`** 절차를 명확히 하고, 자동화된 도구를 사용할 경우 해당 도구의 신뢰성을 확보  
        이때, **복제 지연이 적은 슬레이브**를 우선적으로 선택하여 **데이터 유실을 최소화**
    -   슬레이브 장애 시 새로운 슬레이브를 신속하게 프로비저닝하고 마스터로부터 복제를 시작하도록 하는 절차를 마련

---

#### 5\. 애플리케이션 레벨에서의 고려

데이터베이스 레벨의 정합성 유지 노력 외에, 애플리케이션에서도 정합성 문제를 인지하고 대응

-   **멱등성(Idempotency) 설계:**  
    동일한 작업을 여러 번 수행하더라도 결과가 항상 동일하도록 트랜잭션을 설계하여,  
    네트워크 오류나 복제 지연으로 인해 재시도가 발생했을 때 데이터 불일치가 심화되는 것을 방지
-   **낙관적/비관적 잠금:**  
    특정 데이터를 수정할 때 동시성 제어를 통해 정합성을 유지 (분산 환경에서는 복잡도가 높아지지만, 단일 마스터 내에서는 유효한 방법)
-   **사용자에게 정합성 모델 고지:**  
    서비스의 특성에 따라 "게시글이 바로 보이지 않을 수 있습니다"와 같은 문구를 통해 사용자에게 결과적 일관성 모델을 인지

---

## 샤딩 (Shading)

**하나의 DB 테이블**을 여러 개의 작은 조각 (Shard)로 나누어 여**러 서버에 분산 저장**하는 기술

👉 Scale-Out 달성

-   샤드 (Shard): 분할된 DB의 각 조각을 의미, 각각 별도 서버에 저장 가능
-   샤딩 키(Sharding Key): 데이터를 어떤 샤드에 저장할지 결정하는 기준이 되는 컬럼

---

#### 샤딩 방법

1.  **범위 기반 샤딩 (Range-Based Sharding):**  
    특정 컬럼의 값 범위를 기준으로 데이터 나눔 (예: ID 1~100 = ShardA, ID 101 ~ 200 = ShardB)
2.  **해시 기반 샤딩 (Hash-Based Sharding):**  
    샤딩 키에서 해시 함수를 적용해 나온 값으로 샤드 결정, 데이터를 비교적 균등 분산 가능
3.  **디렉토리 기반 샤딩 (Directory-Based Sharding):**  
    별도의 조회 테이블을 두어 어떤 샤드에 어떤 데이터가 있는지 매핑 정보 관리

| **장점** | 설명 |
| --- | --- |
| **뛰어난 확장성** | DB의 크기와 처리량을 거의 무한하게 확장 |
| **성능 향상** | 샤드가 처리하는 데이터 양이 줄어들어 쿼리 성능 향상 및 병렬 처리 가능 |
| **장애 격리** | 특정 샤드에 문제가 발생해도 다른 샤드들은 영향을 받지 않아 전체 서비스 중단 위험 줄임 |

| **단점** | 설명 |
| --- | --- |
| **구현 복잡성** | 데이터 모델, 애플리케이션 로직, 운영 전반에 걸쳐 큰 변화 요구 & 구현 매우 복잡 |
| **조인 및 트랜잭션 어려움** | 여러 샤드에 걸쳐 있는 데이터에 대하 조인이나 트랜잭션 처리가 어려워지거나   성능 저하 초래 |
| **데이터 재분배 (Resharding) 어려움** | 데이터 양이 늘어나거나 샤딩 키 변경 등으로   샤드 재분배 시 매우 복잡하고 多 시간 소요 |

---

## 레플리카 vs 샤딩

#### 레플리카

-   **동일한 데이터**를 여러 곳에 복제하여 읽기 성능을 높이고 가용성을 확보하는 데 중점
-   데이터는 여전히 논리적으로 하나의 단위를 이룸 (수직 확장 또는 읽기 부하 분산)

![2](https://github.com/user-attachments/assets/a872ac9a-5df4-4722-8490-5fd6b2f6d88e)


#### 샤딩

-   **서로 다른 데이터를 여러 곳에 분산**하여 저장함으로써 전체 데이터베이스의 크기 한계를 극복
-   쓰기/읽기 처리량을 높이는 데 중점 (수평 확장 또는 데이터 분할)

![3](https://github.com/user-attachments/assets/25827257-18b8-4a3c-8560-15f5b5dede01)


---

## 트랜잭션 분산 환경 처리

단일 DB 환경에서의 트**랜잭션 개념(ACID 속성)을 여러 개의 독립적인 DB나 서버에 걸쳐 확장**하는 것을 의미함

단일 DB에서는 ACID 속성을 DBMS가 보장해 주지만, 분산 환경에서는 이 보장이 훨씬 복잡해지거나 불가능할 수 있음

> **❓ ACID 속성  
> **\- **Atomatic** (원자성): 트랜잭션 내의 모든 연산이 완전히 성공하거나, 아니면 완전히 실패  
> \- **Consistency** (일관성): 트랜잭션이 성공적으로 완료되면, DB는 항상 일관된 상태 유지  
> \- **Isolation** (고립성): 여러 트랜잭션 동시 실행 시, 각 트랜잭션은 독립적으로 실행  
> \- **Durability** (지속성): 트랜잭션이 성공적으로 커밋되면, 변경된 모든 데이터는 영구적으로 DB에 반영

---

### 단일 트랜잭션 / 분산 트랜잭션

#### 단일 트랜잭션

-   하나의 DB 시스템 내에서 여러 작업이 원자적으로 처리되는 것을 의미
-   ACID 속성을 DBMS가 완벽히 보장

#### 분산 트랜잭션

-   두 개 이상의 독립적인 DB 시스템에 걸쳐 하나의 논리적인 작업 단위가 원자적으로 처리되는 것을 의미
-   예시: 은행 간의 계좌 이체처럼 한 은행에서는 출금하고, 다른 은행에서는 입금하는 작업이 모두 성공 또는 실패

---

### 분산 트랜잭션의 CAP 이론

분산 환경에서 **ACID 속성을 모두 완벽하게 보장**하는 것은 매우 어려움

이는 분산 시스템의 **근본적인 제약 사항인 CAP 이론과 관련이** 있음

#### **CAP 이론**

분산 시스템은 다음 세 가지 속성 중 **최대 두 가지만 동시에 만족**할 수 있음

1.  **일관성 (Consistency)**: 모든 노드가 동시에 동일한 데이터를 보거나, 최신 업데이트를 받음
2.  **가용성 (Availability)**: 시스템의 모든 요청에 대해 응답이 가능함
3.  **분할 허용성 (Partition Tolerance)**: 네트워크 분할 (일부 노드 통신 단절)이 발생해도 시스템은 계속 동작

---

실제 분산 시스템에서는 _**'네트워크 분할이 항상 발생할 수 있다'**_고 가정함

일반적으로 분할 허용성(P)은 필수적으로 선택됨  
**∴ 일관성(C)과 가용성(A) 중 하나를 희생하야 하는 트레이드오프** 발생

#### CP 시스템

-   일관성과 분할 허용성을 우선시 함
-   네트워크 분할 시 가용성을 희생해 **트랜잭션 처리를 중단하거나 오류 반환**
-   예시: MongoDB - Replica Set, Redis Sentinel/Cluster의 일부 경우

#### AP 시스템

-   가용성과 분할 허용성을 우선시 함
-   네트워크 분할 시 일관성을 희생해 **서비스는 계속 제공하나, 일시적인 데이터 불일치 발생** 가능
-   예시: Cassandra, DynamoDB 등 NoSQL DB 대부분

---

## 분산 트랜잭션 처리 방식

### 1\. 2단계 커밋 (Two-Phase Commit, 2PC)

**가장 고전적이고 널리 알려진** 분산 트랜잭션 프로토콜

**ACID 속성, 특히 원자성을 보장**하여 모든 참여자가 커밋하거나 롤백하도록 함

강력한 원자성을 보장하고, 상대적으로 이해하기 쉬움

#### 참여자

-   **\`코디네이터\`** (Coordinator): 트랜잭션을 총괄하는 역할 (애플리케이션 서버 || 별도의 트랜잭션 매니저)
-   **\`참여자\`** (Participants / Resource Managers):  실제 DB 노드

---

#### 작동방식

1.  코디네이터가 **모든 참여자에게 트랜잭션을 준비하라는 요청** 보냄
2.  각 참여자는 자신의 로컬 트랜잭션 수행하고, 커밋 준비가 되면 관련 로그 기록 후  
    코디에게 YES 또는 NO응답 보냄 (성공/실패)
3.  **\`모든 참여자가 YES\`** : 코디가 **모든 참여자에게 커밋 요청**을 보냄, 각 참여자는 로컬 트랜잭션 커밋 후 완료 응답
4.  **\`하나라도 NO & 타임아웃\`**: 코디가 **모든 참여자에게 롤백 요청**, 각 참여자는 로컬 트랜잭션 롤백 후 완료 응답

---

#### 단점

| **성능 병목** | 모든 참여자가 응답할 때까지 코디 대기, 참여자들도 준비 단계에서 Lock 유지 → 성능 저하 |
| --- | --- |
| **단일 실패 지점** | 코디가 다운되면 트랜잭션이 중단되거나, 참여자들이 Lock 상태로 무한 대기 |
| **높은 복잡성** | 분산 환경에서 네트워크 오류, 노드 다운 등 예외 상황 처리 복잡 |
| **낮은 확장성** | 참여자 수 ∝ 성능 저하 |

---

### 2\. Saga 패턴

MSA와 같은 현대 분산 시스템에서 2PC의 단점을 극복하기 위해 多 사용 방식

분산 트랜잭션의 원자성을 보장하지 않고, 대신 각 **서비스의 로컬 트랜잭션을 실행** 후  
**\`보상 트랜잭션\`**을 통해 전체 일관성 유지 👉 결과적 일관성 모델을 따름

#### 기본 개념

-   하나의 분산 트랜잭션을 여러 개의 로컬 트랜잭션 시퀀스로 나눔
-   각 로컬 트랜잭션은 하나의 서비스에서 실행되며, 자신의 로컬 데이터에 대해 ACID 보장
-   만일 **로컬 트랜잭션 中 하나라도 실패** 시, 이전에 **성공한 로컬 트랜잭션들을 보상 트랜잭션을 통해 되돌림**

#### 장점

| 장점 | **단점** |
| --- | --- |
| 2PC에 비해 높은 확장성과 가용성 제공 | **결과적 일관성:**    트랜잭션 실행 중 일시적으로 데이터 불일치가 발생할 수 있음 |
| 서비스 간의 결합도를 낮춰 MSA에 적합 | **보상 트랜잭션의 복잡성:**   모든 실패 경로에 대한 보상 로직을 구현해야 하며,   보상 트랜잭션 자체도 실패할 수 있는 시나리오를 고려해야함 |
| 블로킹 문제 없음 | **모니터링 및 디버깅의 어려움:**   분산된 로컬 트랜잭션의 상태를 추적하기 어려움 |

---

#### 1\. 오케스트레이션 (Orchestration)

중앙의 **오케스트레이터**가 Saga의 흐름을 관리하고 각 서비스에 작업 지시

오케스트레이터는 각 서비스의 응답을 받아 다음 단계를 진행하거나 보상 트랜잭션 시작

| **장점** | **단점** |
| --- | --- |
| 중앙에서 흐름을 파악하기 용이 | 오케스트레이터가 **SPOF**가 될 수 있고 복잡한 로직 가짐 |

---

#### 2\. 코레오그래피 (Choreography)

**중앙 관리자 없이**, 각 서비스가 \`**이벤트\`를 발행 & 구독** 하여 Saga의 다음 단계 진행

한 서비스의 로컬 트랜잭션이 완료되면 이벤트를 발행하고, 다른 서비스가 이 이벤트를 구독하여 다음 작업 수행

| **장점** | **단점** |
| --- | --- |
| 분산돼 있어 SPOF 위험 少, 유연함 | 전체 흐름 파악 어렵고, 보상 트랜잭션 복잡성 증가 |

---

### 3\. TCC (Try-Confirm-Cancel) 패턴

Saga 패턴과 유사하게 결과전 일관성을 지향하나, 좀 더 엄격한 제어를 제공함

#### 작동 방식

1.  Try: 참여자들이 리소스를 예약하거나 잠금 & 트랜잭션을 수행할 수 있는지 확인
2.  Confirm: 모든 참여자가 Try 성공 시, 각 참여자가 실제 리소스 사용 확정 및 커밋
3.  Cancel: Try 단계에서 하나라도 실패 시, 예약된 리소스 취소 및 롤백

| **장점** | **단점** |
| --- | --- |
| Saga보다 더 강력한 일관성 제공 (Try 단계에서 리소스 예약) | Try 단계에서 리소스 예약으로 인한 블로킹 발생 가능 |
| 서비스 간 의존성을 줄일 수 있음 | 복잡한 구현 必 |

---

### ❓ 어떤 방식을 채택해야 하는가 

#### **2PC**

강력한 ACID 보장이 필수적이고, 참여하는 DB 시스템의 수가 적으며 성능 오버헤드가 허용되는 경우 적합

예시: 레거시 시스템, 소규모 분산 DB

#### **Saga / TCC**

MSA에서 높은 확장성과 가용성이 중요하고, 결과적 일관성을 허용할 수 있는 경우 적합

대부분의 최신 웹 서비스 및 대규모 시스템에서 선호

> 📌 **MSA (MicroServices Architecture)**  
> 소프트웨어 개발 방법론의 하나로, 하나의 거대한 애플리케이션을 **작고 독립적인 여러 서비스로 분할해 개발 및 배포** 방식  
> 각 서비스는 특정 비즈니스 기능 수행, 자체 DB를 가질 수 있고 독립적 배포 및 확장 가능

---

SQL Injection은 웹 애플리케이션 보안에서 가장 흔하고 치명적인 취약점 중 하나.
원리부터 PreparedStatement, ORM을 통한 보호 방법까지 설명하려 함

1. SQL Injection 원리
SQL Injection은 웹 애플리케이션의 `입력 폼`이나 `URL 파라미터 ` 등을 통해 악의적인 SQL 구문(Query)을 주입(Injection)하여, 데이터베이스를 비정상적으로 조작하거나 민감한 정보를 탈취하는 공격 기법

핵심 원리: 사용자 입력이 SQL 쿼리에 직접 결합
애플리케이션이 사용자로부터 입력받은 값을 아무런 검증이나 처리 없이 SQL 쿼리 문자열에 직접 삽입하여 실행할 때 발생

SELECT * FROM users WHERE username = '사용자_입력_ID' AND password = '사용자_입력_PW';
공격자는 `사용자_입력_ID` 부분에 SQL 예약어 `(OR, AND, ', -- , etc..)` 를 포함하여 주입

예시1: 인증 우회
공격자가 사용자 ID에 `' OR 1=1 --`를 입력한다고 가정 ( -- : 주석)
원래 쿼리: ` SELECT * FROM users WHERE username = '' OR 1=1 --' AND password = '사용자_입력_PW';`
이 쿼리는 `username=' '` 조건이 거짓이어도 `OR 1=1` 부분이 항상 참이 되므로, 비밀번호를 몰라도 로그인 성공
👉 `--` 뒤의 내용은 주석 처리되어 무시
예시2: 데이터 탈취
공격자가 검색 폼에 `' ; DROP TABLE users' --`와 같은 쿼리를 입력한다고 가정
원래 쿼리: `SELECT * FROM products WHERE name LIKE '%'; DROP TABLE users; --%';`
이러면 정상적인 쿼리 검색 후, users 테이블이 삭제되는 심각한 문제 발생
예시3: 정보 노출


공격자가  `' UNION SELECT password, username FROM users --` 와 같은 쿼리를 입력한다고 가정
원래 쿼리: `SELECT name FROM products WHERE category = '' UNION SELECT password, username FROM users --';`
UNION SELECT를 통해 products 테이블의 검색 결과와 함께 users 테이블의 사용자 이름과 비밀번호가 함께 반환
❓ 왜 작은 따옴표로 시작하는가
= 공격자는 먼저 애플리케이션이 원래 의도했던 문자열 리터럴을 주입된 작은따옴표로 강제로 닫아버림
PreparedStatement를 통한 보호 방법
PreparedStatement (또는 Parameterized Query, 바인딩 변수 방식)는 SQL Injection을 방어하는 가장 효과적이고 권장되는 방법

원리:
SQL 쿼리 구조와 사용자 입력 데이터를 완전히 분리하여 처리
SQL 쿼리는 미리 컴파일되거나  DB 전달 시 구조 고정
사용자 입력 데이터는 쿼리 내의 `?` 또는 `:이름`에 값으로 바인딩 됨
이 데이터는 SQL 구문이 아닌 순수한 데이터 값으로만 인식 됨
장점	설명
SQL Injection 방어	사용자 입력이 SQL 구문의 일부로 해석되지 않으므로, 악의적인 SQL 코드 주입 근본적으로 차단
성능 향상	쿼리 구조가 미리 정의 & 컴파일 되므로, 동일한 쿼리를 여러 번 실행할 때 오버헤드를 줄여 성능 향상
작동 방식
1. SQL 쿼리 정의 
String sql = "SELECT * FROM users WHERE username = ? AND password = ?;";
PreparedStatement pstmt = connection.prepareStatement(sql);


`?` 는 플레이스홀더로, 실제 값이 들어갈 위치를 나타냄

DB는 `SELECT * FROM users WHERE username = [값] AND password = [값];` 형태의 쿼리 구조를 인식

2. 데이터 바인딩
pstmt.setString(1, userInputId);     // 첫 번째 ? 에 사용자 입력 ID 바인딩
pstmt.setString(2, userInputPw);     // 두 번째 ? 에 사용자 입력 PW 바인딩


`setString()` 메소드는 userInputId와 userInputPw를 문자열 데이터 값으로 처리하여 쿼리에 삽입
이 값 안에 SQL 예약어(예: `OR 1=1 --`)가 포함되어 있더라도, 데이터베이스는 문자열로만 인식 (SQL 구문 X)
예시:  userInputId가 ' OR 1=1 -- 이더라도, 데이터베이스는 `username = ''' OR 1=1 --'`
(문자열 리터럴로 처리되어 단일 인용부호가 이스케이프 됨)으로 인식하여 공격을 무력화
ORM (Object- Relational Mapping) 을 통한 보호 방법
ORM은 객체 지향 프로그래밍 언어의 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 기술

대표적인 ORM: Java의 Hibernate/JPA, Python의 SQLAlchemy, Node.js의 Sequelize 

ORM의 SQL Injection 보호 원리:
대부분의 최신 ORM 프레임워크는 내부적으로 PreparedStatement와 같은 파라미터 바인딩 방식을 사용
직접 SQL 쿼리 문자열을 조작할 필요 없이, 객체 지향적인 방식으로 DB 작업을 수행하도록 추상화 계층을 제공
장점	
높은 생산성	SQL 쿼리 직접 작성X, 개발 생산성 향상
유지보수 용이	객체지향적 코드로 DB 작업을 수행하므로, 가독성 & 유지보수성 좋음
기본적인 SQL Injection 방어	기본적으로 파라미터 바인딩을 사용, 별도의 조치 없이도 SQL Injection 공격 방어
작동 방식
1. 객체 모델 정의
// Java (JPA/Hibernate 예시)
@Entity
public class User {
    @Id
    private Long id;
    private String username;
    private String password;
    // ... getters and setters
}
2. 데이터베이스 작업 수행 (ORM API 사용):
// 사용자 ID로 User 객체 조회
User user = entityManager.createQuery("SELECT u FROM User u WHERE u.username = :username", User.class)
                         .setParameter("username", userInputId) // ORM이 내부적으로 파라미터 바인딩
                         .getSingleResult();




개발자는 SQL 쿼리를 직접 작성하는 대신 JPQL이나 HQL과 같은 ORM 전용 쿼리 언어를 사용하거나
메서드 호출(예: userRepository.findByUsername(userInputId))만으로 DB 작업 수행
이 과정에서 ORM 프레임워크가 개발자를 대신하여 안전한 PreparedStatement 기반의 SQL 쿼리 생성 & 실행
주의 사항
원시 SQL(Native SQL) 사용 시: ORM을 사용하더라도 때로는 복잡한 쿼리나 성능 최적화를 위해 직접 SQL 쿼리(Native Query)를 작성하여 실행해야 할 때가 존재
이 경우 반드시 PreparedStatement의 원리를 적용하여 파라미터 바인딩을 수동으로 해주어야 함. 
∵ ORM의 보호를 벗어나기 때문
// ORM에서 Native Query 사용 시 주의 (JPA 예시)
Query nativeQuery = entityManager.createNativeQuery("SELECT * FROM users WHERE username = ?");
nativeQuery.setParameter(1, userInputId); // 반드시 파라미터 바인딩 사용!
동적 쿼리 생성 시: 개발자가 ORM의 API를 통해 동적으로 쿼리 조건을 생성할 때, 문자열 결합 방식으로 필터링 조건을 구성하면 SQL Injection 취약점이 발생할 수도 있음
항상 ORM이 제공하는 안전한 필터링/조건 추가 API를 사용
결론
SQL Injection은 사용자 입력 값을 SQL 쿼리에 직접 문자열 결합하는 방식에서 비롯됨.

이를 방어하는 가장 확실한 방법은 PreparedStatement(파라미터 바인딩)를 사용하여 쿼리 구조와 데이터 값을 분리

ORM은 이 PreparedStatement의 원리를 내부적으로 활용하여 개발자가 SQL Injection에 노출될 위험을 크게 줄여주는 훌륭한 도구지만, ORM을 사용하더라도 원시 SQL을 사용하거나 부적절하게 동적 쿼리를 생성할 때는 여전히 SQL Injection에 주의해야 함

