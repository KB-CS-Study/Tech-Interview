DB 분산 구조 + 보안(SQL Injection)

# 샤딩 vs 레플리케이션 비교

### **Replication**

여러 개의 DB를 **수직적인 구조(Primary-Secondary)** 로 구축하는 방식이다. DB 서버 뿐 아니라 DB storage 도 여러개 만드는 방식이다.

**Primary 는 쓰기 작업만을 처리, Secondary 는 Read 용도로만 사용해서 부하를 분산**시키기도 한다.

장점

- DB 요청의 대부분이 Read 이기 때문에 성능 상 이점이 있다.
- 비동기 방식으로 운영되어 지연 시간이 거의 없다.

단점

- 노드들 간의 데이터 동기화가 보장되지 않아 일관성 있는 데이터를 얻지 못할 수 있다는 것이다.
- Primary 노드가 다운되면 복구 및 대처가 까다롭다.

### **Sharding**

테이블에 데이터 자체가 엄청나게 많을 경우, 위 Replication 에서 구성한 Slave DB가 N대가 되더라도 원하는 데이터를 테이블로부터 찾는데 많은 시간이 소요될 수 있다. 그때 필요한 게 Sharding 이다. **데이터를 어떻게 잘 분산해서 저장할까**에 대한 개념이다.

샤딩은 수평 파티셔닝의 특수한 형태이다. **테이블을 Row 로 나눠서 Shard 로 분배**한 것이다.

샤딩은 여러 서버에 스키마가 복제된다. 데이터는 Shard Key 를 기준으로 여러 노드들에 나누어 저장된다.

Shard Key 알고리즘에 따라 여러 Sharding 이 있을 수 있다.

1. Hash Sharding

- 구현 자체가 간단하다.
- DB 서버가 추가 될 경우 해시 함수가 변경되어야 하므로 기존에 저장되던 데이터들의 정합성이 깨지게 됨 -> 확장성이 떨어짐
- 공간에 대한 효율성 고려가 안 됨

Dynamic Sharding

- 위 Hash Sharding 에서 확장성 해결하기 위해 나옴
- Locator Service 사용
(Location Service 는 테이블 형식의 데이터를 바탕으로 샤드를 결정해서 적절히 저장하는 방식을 말한다.)
- 해시 샤딩과 달리 단순 키만 추가해주면 되기 때문에 확장성이 쉽다.
- Locator Service 에 종속적이기 때문에 Locator Service 에 문제가 생기면 나머지 샤드 또한 문제가 발생한다.
(Single Point Of Failure)

Entity Group

- 1번과 2번 방식은 **nosql 에 좀 더 적합한 샤딩 방식**
- Entity Group 의 경우 Rdbms 에 적합
- 관계가 되어 있는 entity 끼리 **같은 샤드 내에 공유**하도록 만드는 방식
- user 가 작성한 post, comment 같은 샤드 내에 위치하도록 함
- 다른 샤드내에 데이터 조회할 경우 데이터 조회 성능이 떨어질 수 있음

**레플리케이션은** **높은 가용성 (high availability), 장애 복구 능력 (disaster recovery), 읽기 연산 성능 향상** 과 같은 특징을 갖고 있습니다. 주 데이터베이스가 다운되더라도 서브데이터 베이스를 활용하여 가용성을 확보할 수 있고, 극단적으로 어떤 한 지역에 자연재해가 발생하여 시스템 전체가 다운되더라도, 다른 지역에 있는 레플리케이션이 살아 있어 수월하게 장애를 복구할 수 있을 것입니다. 읽기 연산은 사본 데이터베이스를 활용한 트래픽 분산으로 설명될 수 있죠.

**샤딩은** 주로 large-scale 시스템에 적용됩니다. 단일 서버로 동작하는 전통적인 데이터베이스의 한계를 극복하고 데이터베이스를 수평적으로 확정하여 **병렬 처리를 통한 전체적인 성능 향상**을 기대할 수 있죠. 단일 데이터베이스에 몰리던 커넥션 수를 분산시켜 전체적인 처리량의 성능 향상을 기대할 수 있습니다. 레플리케이션과 달리, **쓰기 연산의 성능 향상** 또한 크게 증가하겠죠.

한 줄로 다시 정리하면, **데이터베이스 레플리케이션은 데이터 중복성 (data redundancy), 고가용성 (high availability) 및 워크로드 분산**에 초점을 맞추는 반면, 데**이터베이스 샤딩은 데이터를 분할하여 수평적 확장성과 성능 최적화에 초점**을 맞춘다고 볼 수 있습니다.

# 마스터 -슬레이브 동기화와 정합성 유지방법

*💡 DB 다중화?*

- 단일 데이터베이스 구조로 사용할 경우 단일 데이터베이스에 문제가 발생할 경우 계속해서 서비스가 제공되지 못하며,
    서버 데이터 분산을 통해 copy본을 만들어놓는 등의 작업을 위해 다중화를 사용한다.

💡 다중화시 유의점
- 간단히 병렬화해서 대수를 증가시키는 웹 서버나 애플리케이션 서버와 비교하면 다중화에 대해 고민해야할 부분이
  많은데 그 이유는 DB 서버가 데이터를 보존하는 영속(Persistence) 계층이기에 별도의 대처가 필요.

**Master Slave 아키텍처**

**쓰기(Write)** 작업은 마스터에서만 지원하고, **Slave**서버는 DB사본을 갱신하면서, 읽기만을 지원. (통상 애플리케이션은 읽기 연산 비중이 훨씬 크기 때문에 아래와 같은 구성으로 많이 사용)

**반동기 복제방식 (Semi-Sync Replication)**

- MySQL 5.5 부터 도입
- 최소 1대 이상의 복제에 필요한 릴레이 로그 동기화를 보장한다.
- AFTER_SYNC 모드 방식으로 마스터 엔진에 커밋되기 전에 Slave 릴레이로그 저장을 기다린다.
- 모든 Slave를 기다리는 것이 아닌 Slave 중 단 1대만이라도 릴레이로그를 수신했다면 Master는 트랜잭션을 완료한다.
- 최소한의 데이터 정합성을 확보하고 Slave DB의 지연이 트랜잭션 지연으로 이어지지 않게 된다.

**MHA ( Master High Availability )**

- Master DB의 고가용성을 위해 개발된 오픈소스
- Master 헬스 체크를 주기적으로 수행하던 Slave에서 자동으로 가장 최신 상태의 Slave DB를 Master로 승격시켜 Fail-Over 하는 것

**Semi-Sync Replication + MHA**

- 단 한대라도 릴레이 로그를 수신했고, 릴레이 로그 복구 과정을 통해 동기화하기 때문에 데이터 유실가능성을 낮출 수 있다.

# 트랜잭션의 분산 환경 처리

## 분산 트랜잭션 처리 방식: 2PC vs SAGA

---

### 🧩 1. 2 Phase Commit (2PC) Protocol

**개요**

- **2단계에 걸친 커밋**을 통해 분산 트랜잭션의 **원자성(Atomicity)** 보장
- **구성요소**:
    - **Coordinator**: 트랜잭션을 조율하는 중앙 조정자
    - **Participant**: 실제 DB 또는 트랜잭션 리소스 제공자

**동작 과정**

1. **Prepare Phase**
    - 클라이언트가 트랜잭션 커밋 요청
    - Coordinator → Participant 에게 `Prepare` 요청 전송
2. **Vote Phase**
    - 각 Participant → Commit 가능 여부 응답 (`YES` / `NO`)
3. **Commit or Rollback**
    - 하나라도 `NO` → Coordinator 가 **모두에게 Rollback**
    - 모두 `YES` → Coordinator 가 **모두에게 Commit** 요청

**장점**

- 구현이 비교적 간단
    - DBMS에서 Participant 역할 내장
    - Spring JTA 등에서 Coordinator 기능 지원

**단점**

- 느린 속도 (모든 과정이 네트워크 기반)
- 확장성 낮음 (NoSQL 미지원, DB 플랫폼 다양성 제한)
- **Commit 실패시** 직접 보상 트랜잭션 구현 필요
    - 모든 Participant 가 `Prepare` OK 응답 → 반드시 Commit 해야 하는 **강한 일관성 기반 구조**

---

### 🔁 2. SAGA 패턴

**개요**

- 분산 트랜잭션의 책임을 **DB → 어플리케이션 레벨로 전가**
- 각 서비스는 자신의 트랜잭션과 **보상 트랜잭션(Compensation Transaction)** 을 가짐
- 두 가지 방식 존재:
    1. **Choreography-Based**
    2. **Orchestration-Based**

---

### 🔸 Choreography-Based SAGA

**동작 방식**

1. 서비스 A가 처리 후 → 다음 서비스(B 등)에게 **이벤트 전달**
2. B가 처리 후 → 다음 서비스에게 또 이벤트 전달
3. 이 이벤트 체인을 따라 트랜잭션 흐름 진행

**장점**

- **느슨한 결합** 구조
- 서비스 간 독립성 확보
- 단순 이벤트 기반 처리

**단점**

- 트랜잭션 **흐름 파악 어려움**
- 서비스 간 이벤트 의존성 증가 → **순환 의존성 위험**
- 대규모 시스템에서 **복잡도 증가**

---

### 🔸 Orchestration-Based SAGA

**동작 방식**

1. 중앙의 **Orchestrator** 가 전체 트랜잭션 흐름 관리
2. 서비스들은 Orchestrator의 요청에 따라 단순 응답만 수행

**장점**

- 트랜잭션 흐름이 **중앙 집중적** → **가독성, 유지보수 용이**
- 서비스 간 **의존성 없음**
- 순환 참조 방지

**단점**

- 모든 비즈니스 로직이 Orchestrator에 몰릴 위험
    - 해결책: **Facade 패턴**을 활용해 로직 분리
    - Orchestrator는 "순서"만 관리하도록 설계
