# 샤딩이란?

동일한 스키마를 가지고 있는 데이터를 다수의 데이터베이스에 분산하여 저장하는 기법

→ 데이터베이스 차원의 수평 확장( scale-out )

![Image](https://github.com/user-attachments/assets/511c7d3c-c1e7-4a6a-af84-f4e07f678cac)

- 예시
    - 샤딩 전: 모든 사용자 정보를 한 DB 서버에 저장
        
        → 서버가 점점 느려지고, 장애 발생 위험 증가
        
    - 샤딩 후:
        - 1~500만 명 → DB1
        - 500만~1000만 명 → DB2
        
          → 두 DB가 동시에 분산해서 처리
        
- 특징
    - 샤딩은 데이터를 나누는 기준(=샤딩 키)이 중요
    - ex. 사용자 ID, 지역, 시간
- 장점
    - 성능 향상: 여러 DB가 동시에 동작 → 빠른 처리
    - 부하 분산: 특정 DB에만 부하가 몰리는 것 방지
    - 데이터 확장 쉬움: 데이터가 많아져도 새로운 DB 추가 가능
- 단점
    - JOIN이 어려움: 서로 다른 DB에 있으면 조인할 수 없음
    - 운영 복잡: 샤딩 로직과 샤딩 키 관리가 필요
    - 정합성 보장 어려움: 한 트랜잭션이 여러 DB를 걸칠 때 처리 복잡

# 레플리케이션이란?

한 DB의 데이터를 다른 DB로 복제해서 똑같이 유지하는 기술

→ 데이터베이스 시스템에서 발생한 데이터의 변경 사항을 여러 대의 서버에 동일하게 복제하여 데이터 손실을 방지하고, 읽기 작업의 성능을 높일 수 있음

![Image](https://github.com/user-attachments/assets/d0483d16-8898-498c-aee9-1dece621dfd4)

- 예시
    
    쇼핑몰 사이트에서:
    
    - 고객이 상품을 주문하면 → 마스터 DB에 저장
    - 고객이 상품을 조회하면 → 슬레이브 DB에서 읽음
- 특징
    - 원본의 서버는 Master / Primary / Leader 등으로 불리고 복제된 서버는 Slave / Secondary / Replica 등으로 불림
    - 복제된 서버는 한대 이상일 수 있음
- 장점
    - 데이터 백업: 마스터가 망가져도 슬레이브가 데이터 보관
    - 읽기 성능 향상: 슬레이브가 읽기 작업을 분산처리
- 단점
    - 복제 지연: 슬레이브에 대한 데이터 반영이 늦을 수 있음
    - 정합성 이슈: 슬레이브가 최신 상태가 아닐 수 있음

# 샤딩 vs 레플리케이션
| 항목 | 레플리케이션 | 샤딩 |
| --- | --- | --- |
| **목적** | 읽기 부하 분산, 장애 대비 | 데이터/쓰기 부하 분산 |
| **구조** | 마스터-슬레이브 (복제) | 수평 분할 (DB 여러 개) |
| **적용 시점** | 읽기 트래픽 급증 시 | 전체 트래픽 또는 데이터량 폭증 시 |
| **읽기 속도** | 향상됨 | 샤드별 분산 가능 (복잡할 수 있음) |
| **쓰기 처리** | 마스터에 집중됨 | 샤드별 분산 가능 |
| **운영 난이도** | 상대적으로 쉬움 | 복잡 (샤딩 키 관리, 분산 쿼리 처리 등) |

▶️ 읽기 요청이 많고 장애 복구가 중요하다 → 레플리케이션

▶️ 데이터가 너무 많거나 전체 부하가 감당 안 된다 → 샤딩

# 마스터-슬레이브 동기화와 정합성 유지 방법

## 마스터-슬레이브 구조

- 마스터: 모든 쓰기 작업(INSERT, UPDATE, DELETE)을 처리
- 슬레이브: 마스터의 데이터를 읽기 전용으로 복제하여 읽기 작업(SELECT)만 수행

## 동기화 방식

- 비동기 복제
    - 마스터가 먼저 데이터를 쓰고, 슬레이브가 나중에 그 내용을 복제
    - 속도는 빠르지만, 정합성 문제 발생 가능
- 동기 복제
    - 마스터가 슬레이브에게도 동시에 반영 완료될 때까지 기다림
    - 데이터 정합성은 좋지만, 쓰기 속도 느려짐
    - 중요한 금융 시스템 등에서 사용
- 반동기
    - 마스터는 슬레이브 중 하나만 복제되면 커밋
    - 비동기보단 안정적이고, 완전 동기보단 빠름
    - MySQL에서 자주 사용하는 방식

## 정합성 유지 방법

- 트랜잭션 로그 기반 복제
    - 마스터에서 실행된 트랜잭션의 **Binary Log (binlog)** 를 슬레이브가 읽어서 재실행
    - 이 방식은 대부분의 RDBMS(MySQL, PostgreSQL 등)에서 사용됨
- GTID (Global Transaction ID)
    - 각 트랜잭션에 고유한 ID를 부여해, 슬레이브가 정확히 어떤 트랜잭션까지 처리했는지 파악
    - 장애 복구 및 자동화에 유리
- Heartbeat + Delay 감지
    - 슬레이브가 마스터로부터 정기적인 신호(heartbeat) 를 받아 연결 상태 확인
    - 슬레이브의 Replication Delay(지연 시간) 을 모니터링해서 지연될 경우 조치
- Failover 시스템 (자동 전환)
    - 마스터가 장애 나면 슬레이브 중 하나를 자동으로 마스터로 승격
    - 대표 툴: MHA(MySQL High Availability)

# 트랜잭션의 분산 환경 처리

- 배경
    
    트랜잭션은 데이터베이스에서 원자성(ACID)을 보장하는 작업 단위
    
    그런데 분산 환경에서는 여러 개의 DB, 시스템, 서비스가 동시에 관여하므로 트랜잭션 유지가 어려워짐
    
- 해결 방식
    - 2단계 커밋(2PC, Two-Phase Commit)
        - 분산 트랜잭션을 위해 고전적으로 사용하는 방식
        - Coordinator가 모든 참여자에게 준비 요청 → 모두 OK 시 커밋 실행
        - 단점: 느림 + 장애 발생 시 락 발생/복구 어려움
    - 보상 트랜잭션(Saga Pattern)
        - 각 단계가 실패했을 때 되돌리는 보상 작업을 정의
        - 트랜잭션 간에 비동기 메시지 기반으로 처리

# SQL Injection

SQL 쿼리에 사용자 입력값이 직접 삽입되어, 원래 의도하지 않은 쿼리 실행이 가능해지는 공격

## 방어 방법

### 1) **PreparedStatement 사용 (파라미터 바인딩)**

SQL 쿼리와 값 분리 → 값이 코드로 실행되지 않음

```sql
String sql = "SELECT * FROM users WHERE username = ? AND password = ?";
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setString(1, username);
stmt.setString(2, password);

```

→ 사용자 입력은 값으로 처리되고, 명령어로 인식되지 않음

### 2) **ORM 사용**

JPA, Hibernate, MyBatis 등 ORM 프레임워크는 기본적으로

쿼리 파라미터 바인딩을 하므로 SQL Injection에 강함

```java
User user = userRepository.findByUsernameAndPassword(username, password);
```

→ 내부적으로 PreparedStatement 사용

단, Native Query나 JPQL에서 직접 문자열 조립 시 여전히 주의 필요