# DB 분산 구조 + 보안(SQL Injection)

## 샤딩 vs 리플리케이션 비교

### 샤딩

- 테이블을 특정 기준으로 나눠서 저장하고 검색하는 것을 의미한다. 
- 데이터를 어떻게 분산시킬 것인지, 어떻게 읽을 것인지 결정하는 것이 중요하다. 
- 분산시켜 저장하기 위한 기준이 Shard key이다.

1) hard sharding
   - 샤드의 수만큼 hash 함수를 사용해서 나온 결과에 따라 db 서버에 저장하는 방식이다.
   - db 서버가 추가될 경우 hash 함수가 변경되어야 하므로 기존에 저장되던 데이터의 정합성이 깨진다.
2) dynamic sharding
3) entity group
   - 연관성 있는 엔티티를 한 샤드에 두는 방식이다.
   - 같은 샤드에 있는 데이터를 조회할 때는 효과적이지만, 다른 샤드에 있는 데이터를 함께 조회할 때는 성능이 떨어진다.
4) moduler sharding
   - PK를 모듈러 연산한 결과로 DB를 특정하는 방식
   - 데이터량이 일정 수준에서 유지될 것으로 예상되는 데이터 성격을 가진 곳에 적용할 때 좋다.
   - DB를 추가 증설해야하는 상황에서 이미 적재된 데이터의 재정렬이 필요하다.
5) range sharding
   - PK의 범위를 기준으로 DB를 특정하는 방식이다.
   - 활성유저가 몰린 DB로 트래픽이나 데이터량이 몰릴 수 있다.

### 리플리케이션

- 여러 개의 DB를 master-slave 형태로 구축하고, master에 DML(Write-only)을 하고 slave에 복제(Read-only)하는 방식이다.
- 비동기 방식으로 노드들 간의 데이터를 동기화한다.
- 비동기 방식으로 데이터를 동기화하기 때문에 지연 시간이 거의 없다.
- 노드들 간의 데이터 동기화가 보장되지 않아 일관성 있는 데이터를 얻지 못할 수 있다.
- 데이터 양이 많을 경우 데이터를 찾는데 오랜 시간이 걸린다.
- 마스터 노드 장애 시 복구&대처가 까다롭다.

<hr />

## Master / Slave Data 동기화 전 까지 데이터 정합성을 지키는 방법

- 다중 스레드로 쓰기 작업을 수행하는 Master 와 단일 스레드로 쓰기 작업을 수행하는 Slave 간의 속도차에 의해 병목이 발생하게된다.
- 리플리케이션 과정 중 이러한 병목 현상을 복제 지연이라고 한다.

### 반동기 복제방식 (Semi-Sync Replication)

- MySQL 5.5 부터 도입
- 최소 1대 이상의 복제에 필요한 릴레이 로그 동기화를 보장한다.
- AFTER_SYNC 모드 방식으로 마스터 엔진에 커밋되기 전에 Slave 릴레이로그 저장을 기다린다.
- 모든 Slave를 기다리는 것이 아닌 Slave 중 단 1대만이라도 릴레이로그를 수신했다면 Master는 트랜잭션을 완료한다.
- 최소한의 데이터 정합성을 확보하고 Slave DB의 지연이 트랜잭션 지연으로 이어지지 않게 된다.

### MHA ( Master High Availability )

- Master DB의 고가용성을 위해 개발된 오픈소스
- Master 헬스 체크를 주기적으로 수행하던 Slave에서 자동으로 가장 최신 상태의 Slave DB를 Master로 승격시켜 Fail-Over 하는 것

### Semi-Sync Replication + MHA

- 단 한대라도 릴레이 로그를 수신했고, 릴레이 로그 복구 과정을 통해 동기화하기 때문에 데이터 유실가능성을 낮출 수 있다.

<hr />

## 분산 환경에서의 트랜잭션 처리

### 분산 트랜잭션을 구현하기 위해 사용되는 패턴

1. Two Phase Commit(2PC)
   1. 첫번째로 투표 단계를 거친다. Coordinator가 트랜잭션 참여자(데이터베이스들)에게 Commit 가능 여부를 질의 하고 각 트랜잭션 참여자들은 트랜잭션을 열고 commit 참여 여부를 반환한다.
   2. 두번째로  모든 트랜잭션 참여자들이 commit 가능이라고 응답한 경우 Coordinator가 commit 요청을 보내고 트랜잭션을 성공적으로 종료한다.
   3. 그러나 이때 하나의 참여자라도 commit 불가라고 응답한다면 Coordinator는 rollback요청을 통해 트랜잭션을 실패로 종료한다.
   - 즉, 2PC는 모든 참여자가 트랜잭션을 커밋하거나 롤백하도록 강제하여 트랜잭션의 일관성을 보장
   - 2PC의 단점
     - 2PC는 트랜잭션 참여자가 많을수록 확장성이 떨어진다.
     - 트랜잭션을 진행하는 동안 모든 참여자가 동기화되어야 하므로, 트랜잭션 참여자가 많아지면 처리 시간이 길어지고, 트래픽이 많을 경우 성능 저하가 발생할 수 있다.
     - 또한 모든 참여자가 결과를 결정하기 전까지 리소스를 잠그기 때문에, 트랜잭션이 길어지면 잠금 시간이 증가하고 시스템 자원이 낭비된다.
2. Saga Pattern
    ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FeLTgop%2FbtsMHpxK0TL%2FWTPeLKj8b5kt8f0dXOVwh1%2Fimg.png)
   - Choreography Saga
     - 중앙 제어자 없이 메시지 브로커를 통해 이벤트를 교환하며 진행하는 방식
     - 중앙 제어자가 없기 때문에 단일 장애점이 없고 느슨한 결합이 될 수 있다.
     - 그렇지만 현재 진행 중인 트랜잭션에 대해 상태 추적 및 디버깅은 힘들 수 있다.
   - Orchestration Saga
     - Orchestrator가 각 서비스들에게 트랜잭션과 보상 트랜잭션을 명령하며 진행하는 방식
     - Orchestrator가 단일 장애점이 된다.
     - 모든 서비스들이 결합된다.
     - 현재 진행 중인 트랜잭션을 추적하기 쉽다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpmZF3%2FbtsMFrKiv4X%2FBqB0LbCYd7xkxaTuxEX9gk%2Fimg.png)

<hr />

## SQL Injection과 PreparedStatement, ORM

### SQL Injection이란?

데이터베이스와 연동된 웹 애플리케이션에 공격자가 입력이 가능한 폼에 조작된 질의문 삽입하여 디비 정보 열람 및 정보를 조작하는 공격

### PreparedStatement란?

PreparedStatement는 미리 정의된 쿼리 구조에 사용자 입력값을 바인딩하여 실행하는 방식으로, 사용자 입력값이 쿼리 구조에 영향을 미치지 않도록 해준다.

### Prepared Statements가 SQL 인젝션을 막는 방법

1. 쿼리 구조 분리
   - 쿼리와 데이터가 분리되어 있어, 데이터베이스 엔진은 데이터를 단순한 값으로 처리하고 이를 명령어로 해석하지 않는다.
2. 자동 이스케이프
   - 사용자 입력 값은 자동으로 이스케이프 처리가 되어 위험한 요소는 제거가 된다.

### ORM이란?

객체의 속성과 데이터베이스의 테이블을 매핑함으로써, 개발자가 보다 객체 지향적인 방식으로 데이터베이스와 상호작용할 수 있게 도와주는 프로그래밍 기술

### ORM의 주요 장점

1. 생산성 향상: ORM을 사용하면 복잡한 SQL 쿼리 대신 객체 지향 코드를 사용하여 데이터베이스 작업을 수행할 수 있어 개발 시간이 단축된다.
2. 유지보수 용이성: 데이터베이스 구조 변경이 필요할 때, ORM을 사용하면 코드의 일부만 수정하여 간편하게 반영할 수 있다.
3. 보안 강화: SQL 인젝션과 같은 보안 위협으로부터 보호할 수 있는 자동화된 방법을 제공한다.

### ORM의 단점

1. 성능 문제: ORM은 때때로 필요 이상의 쿼리를 생성할 수 있으며, 이는 애플리케이션의 성능을 저하시킬 수 있다.
2. 복잡성 증가: 매우 복잡한 쿼리나 특수한 최적화가 필요한 경우, ORM 사용이 오히려 개발을 더 복잡하게 만들 수 있다.
