### [12주차] DB 분산 구조 + 보안(SQL Injection)

- 샤딩 vs 레플리케이션 비교
- 마스터-슬레이브 동기화와 정합성 유지 방법
- 트랜잭션의 분산 환경 처리
- SQL Injection 원리와 PreparedStatement, ORM 보호 방법

## 🔵 샤딩 vs 레플리케이션 비교

### 샤딩

**샤딩은 ‘데이터를 나눠서 저장하는 것’** 이다.
하나의 데이터베이스에 너무 많은 데이터가 쌓이거나 트래픽이 몰리면, 성능이 떨어지고, 이 문제를 해결하기 위해 데이터를 여러 DB 서버에 분산해서 저장한다.

샤딩은 수평 분할 방식으로 데이터를 나눈다.

예를 들어, 유저 데이터를 user_id 기준으로 나눈다고 하면

| Shard A 서버 | Shard B 서버   |
| ------------ | -------------- |
| id 1~1,000   | id 1,001~2,000 |

각 샤드는 독립된 DB로, 서로 다른 데이터를 저장한다.

#### 장점

- 데이터가 분산되므로 부하 감소
- 병렬로 요청 처리 가능 → 속도 향상

#### 단점

- 조인이나 트랜잭션이 여러 샤드에 걸치면 처리 어려움
- 운영 복잡성 증가 (어느 샤드에 데이터가 있는지 알아야 함)

### 레플리케이션

**레플리케이션은 ‘데이터를 복제해서 여러 서버에 유지하는 것’** 이다.
보통 하나의 마스터 DB가 있고, 그 내용을 슬레이브 DB(또는 리플리카)가 그대로 복제해 저장한다.

### 마스터-슬레이브 구조

- 마스터(Master): 쓰기 전용 (insert, update, delete 등)
- 슬레이브(Slave): 읽기 전용 (select)

#### 장점

- 읽기 부하 분산: 슬레이브가 많을수록 병렬 읽기 가능
- 장애 대응: 마스터가 죽으면 슬레이브를 승격 (failover)

#### 단점

- 쓰기 요청은 여전히 마스터 1대에 집중됨
- 복제 지연(lag) 발생 가능 (슬레이브가 최신 상태가 아닐 수 있음)

### 샤딩 vs 레플리케이션

| 항목      | 샤딩 (Sharding)                         | 레플리케이션 (Replication)           |
| --------- | --------------------------------------- | ------------------------------------ |
| 목적      | 데이터 분산 저장                        | 데이터 복제 및 고가용성 확보         |
| 방식      | 테이블 또는 레코드를 기준으로 수평 분할 | 마스터 DB의 데이터를 슬레이브에 복제 |
| 이점      | 저장 공간 분산, 읽기/쓰기 부하 분산     | 읽기 성능 향상, 장애 대비            |
| 단점      | 조인, 트랜잭션 어려움                   | 쓰기 부하는 마스터에 집중            |
| 사용 사례 | 대규모 사용자/데이터 처리               | 고가용성, 다수 읽기 트래픽           |

> 샤딩은 데이터 나누기,  
> 레플리케이션은 데이터 복제하기에 초점이 있음.

---

<br />

## 🔵 마스터-슬레이브 동기화와 정합성 유지 방법

### 마스터-슬레이브 구조

하나의 데이터베이스 시스템에서 쓰기 작업은 마스터 서버가, 읽기 작업은 복제된 슬레이브 서버들이 맡는 구조다. 이를 통해 읽기 성능을 향상시키고 고가용성을 확보할 수 있다.

**마스터(Master)**: 모든 변경 작업(insert, update, delete)을 처리

**슬레이브(Slave)**: 마스터에서 데이터를 주기적으로 복제하여 select 요청을 처리

### 동기화 방식

#### 1. 비동기 복제 (Asynchronous Replication)

- 마스터가 먼저 트랜잭션을 커밋한 후, 슬레이브에 복제됨

- 장점: 빠른 응답 속도

- 단점: 장애 발생 시 슬레이브에 최신 데이터가 없을 수 있음 (데이터 유실 가능성)

#### 2. 반동기 복제 (Semi-synchronous Replication)

- 슬레이브 중 최소 한 곳에 전달되면 마스터가 커밋

- 데이터 유실 가능성은 낮아지지만 여전히 완전하지 않음

#### 3. 동기 복제 (Synchronous Replication)

- 모든 슬레이브에 커밋이 완료된 후 마스터가 커밋

- 장점: 높은 정합성

- 단점: 속도 저하, 지연 발생 가능성 높음

### 정합성 유지 전략

- 읽기 요청은 슬레이브로 분산시키되, 쓰기 요청은 항상 마스터로 전달

- 슬레이브의 복제 지연(Replication Lag)을 지속적으로 모니터링

- ProxySQL, HAProxy 등을 이용해 장애 발생 시 자동 Failover 설정

- Heartbeat 시스템으로 마스터/슬레이브 상태 감시 및 역할 전환 자동화

---

<br />

## 🔵 트랜잭션의 분산 환경 처리

### 배경

분산 시스템에서는 단일 트랜잭션이 여러 데이터베이스 노드에 걸쳐 일어날 수 있다. 이로 인해 트랜잭션의 4가지 특성(ACID)을 보장하는 것이 어려워진다.

### 문제점

- **원자성(Atomicity)**: 일부만 커밋되거나 롤백되는 문제가 생길 수 있음

- **정합성(Consistency)**: 시스템 전반에 걸쳐 동일한 데이터 상태 유지가 어려움

- **격리성(Isolation), 지속성(Durability)**: 장애 발생 시 보장 어려움

### 해결 방안

#### 1. Two-Phase Commit (2PC)

트랜잭션을 두 단계로 나눠 각 노드에 먼저 준비(prepare)를 요청하고, 모두 OK일 때 최종 커밋

단점: 노드 중 하나라도 실패하면 전체 트랜잭션 롤백 → 성능 저하와 복잡성 증가

#### 2. Saga Pattern

각 로직을 독립된 트랜잭션으로 나눠 실행

실패 시 이전 트랜잭션에 대해 보상 작업(Compensating Transaction) 수행

주로 마이크로서비스 아키텍처에서 사용됨

#### 3. Eventual Consistency (최종적 일관성)

데이터가 즉시 정합성을 가지지 않아도 되고, 일정 시간이 지나면 일관된 상태가 됨

주로 SNS 피드, 캐시 시스템 등 완전한 정합성이 덜 중요한 서비스에 적용

---

<br />

## 🔵 SQL Injection 원리와 PreparedStatement, ORM 보호 방법

### SQL Injection이란?

SQL Injection은 클라이언트가 입력한 값이 서버의 SQL 쿼리에 직접 삽입되어 실행되는 보안 취약점이다. 악의적인 사용자가 조작된 입력값으로 DB 명령을 실행시킬 수 있게 만든다.

### 공격 원리

입력값을 문자열 결합으로 SQL에 포함시킬 경우, 사용자가 SQL 문법을 삽입해 서버의 동작을 바꿀 수 있음

예시:

```sql
SELECT * FROM users WHERE username = 'admin' AND password = '1234';
```

위와 같은 쿼리에 ' OR 1=1 -- 입력 시:

```sql
SELECT * FROM users WHERE username = '' OR 1=1 -- ' AND password = '';
```

모든 사용자 정보를 조회할 수 있음

### 방어 방법

#### 1. PreparedStatement 사용

- SQL 쿼리 구조를 먼저 정의한 뒤, 값은 별도로 바인딩

- 사용자 입력은 문자열로만 처리되어 쿼리 구조를 변경할 수 없음

예시:

```sql
String sql = "SELECT * FROM users WHERE username = ? AND password = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1, username);
pstmt.setString(2, password);
```

#### 2. ORM 사용

- TypeORM, Sequelize, Prisma 등은 내부적으로 Prepared Query를 사용

- 쿼리 생성을 자동화하고 바인딩 처리를 내부적으로 처리하여 보안 향상

#### 3. 기타 보안 조치

- 사용자 입력에 대한 화이트리스트 기반 유효성 검증

- DB 사용자 권한 최소화 (읽기 전용 계정, 트랜잭션 제한 등)

- 에러 메시지나 스택 트레이스 노출 금지 (공격자에게 힌트 제공 방지)
