### [11주차] Redis와 캐싱 전략 + Locking + Deadlock

- Redis란?
- Redis TTL
- 캐시 무효화 전략, LRU 등
- Optimistic vs Pessimistic Lock 실무 예시
- 비정상 종료 시 Lock 처리 방식

## 🔵 Redis란?

### 사용하는 시점

- **DB 부하 감소가 필요할 때**  
  (예: 인기 게시글, 자주 조회되는 상품정보 캐싱 등)
- **실시간 성능이 중요한 경우**  
  (예: 실시간 랭킹, 실시간 알림, 채팅방 등)
- **짧은 시간 유지되는 데이터 처리**  
  (예: 인증번호, 세션, 이메일 토큰)
- **분산 시스템에서 동기화 및 메시징이 필요할 때**  
  (예: Pub/Sub, 분산 Lock 등)

### 사용하는 이유

| 이유                | 설명                                        |
| ------------------- | ------------------------------------------- |
| **초고속 성능**     | 메모리 기반 구조로 DB보다 빠른 응답         |
| **다양한 자료구조** | String, Hash, List, Set, Sorted Set 등 지원 |
| **TTL 기능**        | 자동 만료 설정 가능, 캐시/세션에 유리       |
| **원자성 보장**     | 단일 스레드 처리로 race condition 방지      |
| **메시지 큐 기능**  | Pub/Sub으로 간단한 큐 시스템 구현 가능      |
| **분산 Lock 지원**  | SETNX + EXPIRE 조합으로 동시성 제어 가능    |

---

<br />

## 🔵 Redis TTL

### TTL (Time To Live)

> Redis 키에 유효 시간을 설정해 자동 만료되도록 하는 기능

### 주요 명령어

| 명령어                | 설명                          |
| --------------------- | ----------------------------- |
| `SET key value EX 60` | 60초 후 키 만료               |
| `EXPIRE key 120`      | 기존 key에 TTL 설정           |
| `TTL key`             | 남은 TTL 시간 확인            |
| `PERSIST key`         | TTL 제거 (영구 저장으로 전환) |

### 사용 예시

- 인증번호 3분 유효
- 이메일 토큰 10분 만료
- 실시간 이벤트 응모 상태 5분 유지 등

---

<br />

## 🔵 캐시 무효화 전략 + Eviction 정책

### 캐시 무효화 전략

| 전략                           | 설명                                         |
| ------------------------------ | -------------------------------------------- |
| **Cache Aside (Lazy Loading)** | 요청 시 캐시에 없으면 DB 조회 후 캐시에 저장 |
| **Write Through**              | 쓰기 시 DB와 캐시 동시 업데이트              |
| **Write Back**                 | 캐시에 먼저 쓰고 일정 시간 후 DB 반영        |
| **Read Through**               | 캐시 미스 시 DB에서 조회하여 자동 반영       |

### Eviction 정책

> 메모리 초과 시 어떤 데이터를 제거할지를 결정하는 정책

| 정책     | 설명                                     |
| -------- | ---------------------------------------- |
| **LRU**  | 가장 오래 사용되지 않은 키 제거 (기본값) |
| **LFU**  | 가장 사용 빈도가 낮은 키 제거            |
| **FIFO** | 가장 먼저 들어온 키부터 제거             |

---

<br />

## 🔵 Optimistic vs Pessimistic Lock 실무 예시

### Optimistic Lock (낙관적 락)

- **개념**: 충돌이 잘 일어나지 않을 것으로 가정하고, 데이터를 읽은 뒤 업데이트 시점에 충돌 검사를 수행함
- **주요 방식**: 버전 번호(`version`) 또는 타임스탬프를 기반으로 업데이트
- **장점**: 락을 점유하지 않으므로 성능에 유리, 병목 적음
- **단점**: 충돌 발생 시 재시도 필요 → 로직 복잡도 증가

#### 실무 예시

- 게시글 좋아요 수 증가
  - 사용자가 좋아요 버튼 클릭 시, DB에서 현재 수를 읽어오고 `version`과 함께 업데이트 시도
  - 누군가 먼저 수정하면 실패 → 재시도

### Pessimistic Lock (비관적 락)

- **개념**: 충돌이 발생할 것으로 가정하고, 데이터를 읽는 즉시 락을 걸어 다른 트랜잭션 접근 차단
- **주요 방식**: `SELECT ... FOR UPDATE` 쿼리 사용
- **장점**: 충돌을 사전에 방지 가능 → 재시도 필요 없음
- **단점**: 동시성 떨어짐, 데드락 주의

#### 실무 예시

- 재고 수량 감소
  - 상품 주문 시 수량을 반드시 정확히 차감해야 하므로 `FOR UPDATE`로 락을 건 후 차감 처리
  - 중복 결제를 막기 위해 특정 유저/상품 조합에 락 사용

---

<br />

## 🔵 비정상 종료 시 Lock 처리 방식

### 비정상 종료란?

- 클라이언트 또는 서버가 락을 잡은 상태에서 강제 종료된 경우
- 락이 해제되지 않아 다른 프로세스가 영원히 대기할 수 있음 (Deadlock)

---

### 해결 전략

#### 1. TTL을 활용한 자동 만료

- Redis의 `SET key value NX EX 10`을 이용해 락에 TTL 설정
- 클라이언트가 비정상 종료되더라도 일정 시간이 지나면 자동으로 락이 해제됨

#### 2. 락 소유자 식별

- 락 값으로 `고유 ID`를 저장 (예: UUID, 세션 ID 등)
- 락을 해제할 때 본인이 설정한 락인지 확인 후 삭제
  - `GET lockKey` → 내 ID면 → `DEL lockKey`

#### 3. 분산 락 라이브러리 사용

- Redisson, ShedLock 등 Redis 기반 락 구현체 활용
- 락 해제 실패, 네트워크 분리 상황까지 고려한 안정성 확보 가능

### Deadlock 원인과 회피/해결 방법

| 방법                      | 설명                                                                            |
| ------------------------- | ------------------------------------------------------------------------------- |
| **락 획득 순서 통일**     | 여러 자원에 락을 걸 경우, 락을 거는 순서를 시스템 전반에 걸쳐 동일하게 유지     |
| **타임아웃 설정**         | 일정 시간 이상 락을 점유하면 강제로 해제 → 무한 대기 방지                       |
| **재시도 및 백오프 전략** | 락 획득 실패 시 일정 시간 뒤 재시도, 점점 대기 시간 늘리는 백오프(backoff) 사용 |
| **모니터링 및 로그 분석** | Deadlock 발생 시점 기록 및 알림 설정으로 조기 발견 가능                         |
