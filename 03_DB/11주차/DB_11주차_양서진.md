# Redis란? 언제 사용하는 지, 왜 사용하는 지

## Redis(`RE`mote `DI`ctionary `S`erver)는 오픈 소스 기반의 고성능 키-값 저장소

메모리 내 데이터 구조 저장 및 검색을 위한 데이터베이스로 사용한다.

Redis는 NoSQL 데이터베이스 중 하나로, 주로 캐싱, 세션 관리, 메시지 브로커, 대기열 처리 등 다양한 용도로 활용된다.

Redis는

- 메모리 내 데이터 저장을 빠른 응답 속도를 제공
- 디스크에 데이터를 지속적으로 저장하여 데이터 손실을 방지
- 다양한 데이터 구조 지원
- 문자열, 리스트, 해시, 집합, 정렬 집합과 같은 데이터 타입을 다룰 수 있다.

### 특징 및 장점

1. **`인메모리 데이터베이스`**: Redis는 데이터를 메모리에 저장하므로 빠른 응답 속도를 제공해요.
2. **`다양한 데이터 타입`**: Redis는 문자열, 리스트, 해시, 집합, 정렬 집합과 같은 다양한 데이터 구조를 지원합니다. 이를 통해 다양한 데이터 처리 요구사항을 처리하기 수월해요.
3. **`영속성`**: Redis는 디스크에 데이터를 주기적으로 저장하여 데이터의 지속성을 제공해요. 이를 통해 시스템 장애 시에도 데이터 손실을 방지할 수 있어요.
4. **`Pub-Sub 메시징`**: Redis는 Publish-Subscribe 메커니즘을 지원하여 메시지 브로커로 사용할 수 있어요. 이를 통해 이벤트 기반 시스템을 구축하거나 메시지 전달에 활용할 수 있어요.
5. **`트랜잭션 / 싱글 스레드`**: Redis는 멀티 명령어를 원자적으로 실행하는 트랜잭션을 지원해요. 이를 통해 여러 작업을 원자적으로 처리할 수 있어요. 이러한 트랜잭션 유지가 가능한 이유는 ***Redis가 싱글 스레드 기반으로 동작하기 때문***이에요. 따라서 Redis를 잘 이해하고 사용할 경우 사이드 이펙트가 거의 없는 매우 안정적인 서비스를 구축할 수 있어요.
6. **`클러스터링`**: Redis는 데이터 샤딩과 레플리케이션을 통해 고가용성 및 확장성을 제공하는 클러스터를 구성할 수 있어요.
7. **`LRU 캐시 및 만료 시간`**: Redis는 데이터를 자동으로 관리하기 위해 LRU (Least Recently Used) 알고리즘과 만료 시간(Time-to-Live)을 지원해요.
8. **`트러블슈팅`**: 많은 사용자들이 존재하여 비슷한 문제 해결 사례가 많으며, 커뮤니티 도움 받기 수월해요.

# Redis TTL

- TTL이란 key가 언제까지 살아있을것인가 하는것이다
- 지정된 시간이 지나면 자동으로 키가 삭제된다.
- 만료 시간을 설정하지 않으면 사용자가 명시적으로 삭제하지 않는 한 영원히 저장된다.
- 현재 컴퓨터 시간을 기반으로 TTL이 동작하기 때문에 만료 시간을 1000초로 설정해 놓고 현재 컴퓨터 시간을 2000초로 바꾸면 즉시 만료된다. 현재 컴퓨터 시간을 기반으로 TTL이 동작하기에, 레디스 인스턴스가 켜져 있지 않더라도 시간이 카운팅 된다.

# 캐시 무효화 전략, LRU 등

캐시에 저장된 데이터가 더 이상 유효하지 않을 때 이를 갱신하거나 제거하는 전략으로

무효화 전략을 통해 데이터의 신뢰성과 일관성을 보장할 수 있다.

- TTL 기반
- 수동 무효화
- 삭제 후 재 로드
- 캐시 갱신
- Lazy Invalidation
- Cache-aside

### 수동 무효화(Manual Invalidation)

> 애플리케이션이 특정 이벤트(데이터 변경, 삭제 등)에 따라 캐시를 명시적으로 제거하거나 갱신하는 방식
> 

사용 사례: 데이터베이스에서 변경 또는 삭제 이벤트가 발생했을 때 해당 데이터와 연관된 캐시 항목을 무효화한다.

장점: 데이터가 변경된 시점에 즉각적으로 캐시를 갱신하므로 일관성을 보장할 수 있다.

단점: 구현이 복잡할 수 있고, 특정 상황에서 캐시 갱신을 놓칠 수 있는 버그가 발생할 위험이 있다.

### 삭제 후 재로드(Write-Through/Write-Behind)

Write-Through: 데이터를 DB와 캐시에 동시에 쓰는 방식으로 데이터가 변경될 때마다 캐시에 즉시 반영하므로 일관성이 높다.

Write-Behind: 데이터가 DB에 저장된 후 일정 시간 후에 캐시에 기록되는 방식으로, 지연 쓰기가 이루어진다.

장점: 데이터 일관성을 유지하고 캐시 히트율이 높아진다.

단점: Write-Behind는 DB와 캐시 간 데이터 불일치가 발생할 수 있다.

### 캐시 갱신(Cache Refresh)

> 주기적으로 캐시된 데이터를 백그라운드에서 갱신하는 방식으로, 이는 캐시의 유효성을 높이며, 데이터 변경을 예측할 수 없을 때 사용된다.
> 

장점: 캐시가 오래되지 않도록 주기적으로 갱신되며, 일관성도 높일 수 있다.

단점: 데이터가 실제로 변경되지 않았을 때도 불필요한 갱신이 발생할 수 있어 리소스 낭비가 발생할 수 있다.

### Lazy Invalidation

> 캐시에 저장된 데이터를 사용하려고 할 때 유효성을 확인하고, 만약 데이터가 오래되었다면 그때 무효화 및 갱신하는 방식
> 

장점: 실시간으로 변경된 데이터를 반영할 수 있고, 불필요한 캐시 갱신을 줄일 수 있다.

단점: 데이터를 조회하는 시점에 무효화가 일어나면 성능 저하가 발생할 수 있다.

### Cache-aside

> 데이터 요청 시점에만 캐시를 조회하는 방식으로, 캐시에 데이터가 없거나 오래된 경우 DB에서 데이터를 가져와 캐시에 저장합니다. 주로 Lazy Invalidation과 함께 사용된다.
> 

장점: 캐시에 저장된 데이터는 주로 최신 데이터가 된다.

단점: 최초 데이터 조회 시 캐시에 데이터가 없을 경우 DB 조회로 인한 성능 저하가 발생할 수 있다.

# Optimistic vs Pessimistic Lock 실무 예시

## Lock

DB에 접근해서 데이터를 수정할 때 동시에 수정이 일어나 충돌이 일어날 수 있다.

이러한 상황을 제어하기 위해서 트랜잭션의 격리 수준과 비즈니스 로직에 맞추어 잠금이 필요하다

# Optimistic Lock

### 특징

1. 낙관적인 : 기본적으로 데이터 갱신시 충돌이 발생하지 않을 것이라고 낙관적으로 보는 락
2. 비선점적인: 데이터 갱신시 충돌이 발생하지 않을 것이라고 예상하기 때문에, 우선적으로 락을 걸지 않는다.

### 설명

- DB가 제공하는 락 기능을 사용하지 않고, Application Level(JPA 등)에서 잡아주는 락입니다.
- version 등의 컬럼을 추가하여 여러 트랜잭션 내 하나의 데이터에 중복 업데이트를 확인합니다.
- DB 트랜잭션을 걸지 않기 때문에, 여러 트랜잭션이 동일 데이터에 업데이트를 시도할 수 있습니다.
- 데이터 베이스 수준의 Roll-back이 없기에, 충돌시 대처 방안을 구현해야 합니다.

# **Pessimistic Lock**

### 특징

1. 비관적인: 기본적으로 데이터 갱신시 충돌이 발생할 것이라고 비관적으로 보고 미리 잠금을 거는 락
2. 선점적인: 데이터 갱신시 충돌이 발생할 것이라고 예상하기 때문에, 우선적으로 락을 건다.

### 설명

- 트랜잭션이 시작될 때 Shared Lock 또는 Exclusive Lock을 걸고 시작하는 방법으로 DB가 제공하는 락 기능을 사용합니다.
- **DB Transaction을 이용**하여 충돌을 예방하는 것이 바로 비관적 락(Pessimistic Lock)입니다.
- 충돌이 발생하면 Transaction이 실패한 것이기 때문에 트랜잭션 전체에 자동으로 rollback이 일어난다.

### Exclusive Lock(배타적 잠금)

- 쓰기 잠금이라고도 불립니다.
- 어떤 트랜잭션에서 데이터를 변경하고자 할 때, 해당 트랜잭션이 완료될 때까지 해당 테이블 혹은 레코드를 다른 트랜잭션에서 읽거나 쓰지 못하게 하기 위해 Exclusive lock을 걸고 트랜잭션을 진행시키는 것입니다.
- 배타적 잠금(exclusive lock)에 걸리면 공유잠금(shared lock)을 걸 수 없습니다.
- 배타적 잠금(exclusive lock)에 걸린 테이블, 레코드 등의 자원에 다른 트랜잭션이 배타적 잠금(exclusive lock)을 걸 수 없습니다.Shared Lock(공유 잠금)
- 읽기 잠금이라고도 불립니다.
- shared lock이 하나라도 걸려 있으면 exclusive lock을 걸 수 없습니다.

### 2. 낙관적 락은 트랜잭션을 필요로 하지 않기 때문에 성능적으로도 비관적 락보다 좋습니다.

### 3. 낙관적 락은 성능상 유리하지만 충돌 발생시 롤백을 개발자가 직접 처리해야 하기 때문에 트랜잭션 롤백이 발생하는 비관적 락에 비해서 불리합니다.

# 비정상 종료 시 Lock 처리 방식– Deadlock 원인과 회피/해결 방법

### Lock Timeout

Lock을 걸 때, 타임아웃을 설정해 일정시간이 지나면 자동으로 Lock을 해제하도록 합니다.

### Deadlock Detection

교착상태가 발생하면 사후에 트랜잭션들 중 하나를 강제종료(`rollback`) 시키는 조치를 취하는 방식입니다.

### 일반적인 회복 방법

이외에도 Redo, Undo와 같은 회복 방법을 통해 트랜잭션으로 손상된 부분을 회복시킬 수 있습니다.

### Redo (Media Recovery)

비소멸장치(디스크, 테이프 등)의 내용 손상에 대한 회복 기법입니다.

가장 최근의 복제본(dump)을 적재시키고, 해당 복제본 이후의 변경을 log를 이용해 재실행하여 DB를 복원합니다.

### Undo

log를 이용해 모든 변경을 취소시키므로써 DB를 복원합니다.

### 소멸 장치의 정보 회복

### Log 이용 회복

트랜잭션이 Write 연산을 실행하거나, 트랜잭션의 시작/완료/철회와 같은 특별 활동시 기록되는 Log를 활용해 회복하는 방법입니다.

Log는 `On-line log(실행중인 트랜잭션에 대한 로그)`, `Archival log(누적되는 로그를 안정 저장장치에 저장한 것)`로 나뉩니다.

### 지연 갱신(Deferred Update)의 회복

트랜잭션이 부분 완료될 때 까지 DB 변경내역을 log에 전부 기록한 뒤, 부분 완료되면 보류시킨 Output 연산을 log를 사용해 처리합니다.

트랜잭션 **실행 중 장애가 발생**했다면 **처음부터 다시 실행**하고, **완료 후 장애가 발생**했다면 **Log을 사용해 트랜잭션을 Redo** 합니다.

### 즉시 갱신(Immediate Update)의 회복

트랜잭션이 실행되는 동안 발생한 변경 내용을 DB에 그대로 반영해 처리합니다.

트랜잭션 **실행 중 장애가 발생**했다면 해당 **트랜잭션에 대한 Undo**를 실행하고, **완료 후 장애가 발생**했다면 **트랜잭션을 Redo** 합니다.

### 검사시점(Check Point) 회복

*Log를 이용할 경우* Redo/Undo 대상 트랜잭션을 찾기위해 **log 전체를 조사**하거나,**불필요한 Redo를 반복**한다는 **문제를 해결**하기 위해 일정 간격으로 **CheckPoint를 설치**해 이를 사용하는 기법입니다.

Log를 차례로 검사하며 트랜잭션의 start를 만났다면 해당 트랜잭션을 Undo-list에, 트랜잭션의 commit을 만났다면 Undo-list에서 삭제하고 Redo-list에 추가합니다. 이후 Undo-list의 트랜잭션을 log에 기록된 역순으로 Undo를, Redo-list의 트랜잭션을 log에 기록된 순서로 Redo를 수행합니다.

### 그림자 페이징(Shadow Paging) 기법

트랜잭션을 실행하는 동안 2개의 page table을 유지하는 방법입니다.

current page table은 write 연산을 실행할 때 변경하며, shadow page table은 트랜잭션 실행 직전의 상태를 유지합니다.

트랜잭션 완료 전 장애가 발생한 경우 shadow page table을 복사해 실행 직전으로 복귀시킵니다.

운영체제에서 데드락(교착상태)이란 시스템 자원에 대한 요구가 뒤엉킨 상태로, 다음과 같은 조건이 동시에 충족될 때 발생합니다.

1. 상호 배제 (Mutual Exclusion): 자원은 동시에 여러 개의 작업이 사용할 수 없고, 한 번에 하나의 작업만 사용할 수 있습니다.
2. 점유 대기 (Hold and Wait): 작업은 이미 어떤 자원을 점유한 상태에서 다른 자원을 기다립니다.
3. 비선점 (No Preemption): 다른 작업이 점유한 자원을 강제로 뺏을 수 없습니다. 자원은 해당 작업이 자발적으로 반납할 때까지 점유됩니다.
4. 순환 대기 (Circular Wait): 작업 간에 자원을 기다리는 순환 형태의 사이클이 형성됩니다.

---

# 교착 상태 예방 (Deadlock Prevention)

---

교착 상태 예방 방법은 교착 상태가 되지 않도록 하는 방법입니다.

다음 네 가지 필수 조건 중 하나 이상을 부정하여 방지할 수 있습니다.

상호 배제(Mutual Exclusion) 부정

- 읽기 전용 파일과 같은 공유 자원을 사용합니다.

점유 및 대기(Hold and Wait) 부정

- 프로세스 대기를 없애기 위해서 프로세스가 실행되기 전에 필요한 모든 자원을 할당합니다. (자원 낭비 발생)
- 자원을 점유하지 않고 있을 때에만 다른 자원을 요청할 수 있도록 합니다. (기아상태가 될 수 있음)

비선점(No Preemption) 부정

- 모든 자원에 대한 선점을 허용합니다.
- 프로세스가 할당받을 수 없는 자원을 요청하는 경우, 기존에 가지고 있던 자원을 모두 반납하고 새 자원과 이전 자원을 얻기 위해 대기하도록 합니다. (자원 낭비 발생 )

순환 대기(Circular Wait) 부정

- 자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 합니다. (자원 낭비 발생)

# 교착 상태 회피 (Deadlock Avoidance)

---

교착 상태 회피는 교착 상태가 발생하기 전에 교착 상태를 예상하여 안전한 상태(safe state)에서만 자원 요청을 허용하는 방법입니다.

자원을 신중하게 할당하면 교착 상태를 회피할 수 있습니다.

교착상태 회피를 하기 위해서는 다음과 같은 가정이 필요합니다.

- 프로세스 수가 고정되어 있어야 한다.
- 자원의 종류와 수가 고정되어 있어야 한다.
- 프로세스가 요구하는 자원 및 최대 자원의 수를 알아야 한다.
- 프로세스는 반드시 자원을 사용 후 반납해야 한다.

교착상태 회피 방법은 이러한 가정들이 필요하기 때문에 현실성이 부족합니다.

또한 자원 요청이 있을 때마다 교착상태 회피 알고리즘을 사용한다 것은 상당한 오버헤드이다.
