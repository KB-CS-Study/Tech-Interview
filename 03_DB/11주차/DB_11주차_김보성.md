## **✅ 1. Redis란? 언제, 왜 사용하는가**

### **🔹 개념**
<img width="716" alt="스크린샷 2025-06-08 오후 4 46 49" src="https://github.com/user-attachments/assets/903f14f7-592f-406b-b8f1-70fd536337ff" />

**Redis (REmote DIctionary Server)** 는 **In-memory 기반의 Key-Value NoSQL 저장소**로 매우 빠른 속도와 다양한 자료구조 지원으로 유명함

- RAM 기반으로 작동 (디스크보다 빠름)
- 문자열, 리스트, 해시, 셋, 정렬셋 등 다양한 자료구조 지원
- RDB (Snapshot), AOF (Append Only File) 방식으로 영속성 보장 가능
    - RDB (Snapshot)
        - 특정 **시간 간격**으로 메모리의 데이터를 스냅샷(snapshot)처럼 저장함
            
            → “60초 동안 변경된 키가 100개 이상이면 저장” 처럼 빠른 복구용 백업에 적합
            
    - AOF (Append Only File)
        - Redis에 들어오는 **모든 write 명령어를 순차적으로 파일에 기록**함
        - 서버 재시작 시 이 파일을 재실행하여 메모리 상태를 복구함
            
            → **가장 최근 상태까지 복원 가능**
            
- 단일 스레드 기반으로 빠른 처리 보장

### **🔹 언제 사용하는가?**

- **캐시 시스템** : DB 부하 감소 + 응답 속도 향상
    
    ex) 상품 상세 정보, 마이페이지 데이터
    
- **세션 저장소** : 로그인 상태 관리
    
    ex) Spring Security 세션, JWT Refresh 토큰 저장
    
- **실시간 처리**: 빠른 처리 필요 시
    
    ex) 실시간 좋아요 수, 알림
    
- **분산 락 처리**
    - Redis 단일 인스턴스에만 의존할 경우 장애 시 락 해제 불가 → **Redlock 알고리즘**이 사용됨
    - Redlock은 다수의 Redis 인스턴스에 락을 동시에 획득하여 분산 환경에서도 안전한 락을 보장
    
    ex) 결제 중복 방지, 재고 처리
    
- **Queue / Pub-Sub 시스템**
    
    ex) 알림 메시지, 채팅 메시지 처리
    

### **🔹 왜 사용하는가?**

**DBMS로서의 장점**

또한 어플리케이션을 종료하면 휘발되어 사라져버리는 HashMap과 달리, Redis는 다양한 영속성(디스크에 백업) 옵션을 제공

영속성 외에도 범용 프로그래밍 언어인 Java에서 다루기 까다로운 여러 기능도 DBMS로써 갖추고 있음

TTL 설정 → 일정 시간이 지나면 데이터 삭제, 용량이 작은 메모리의 효율적 관리

분산 데이터 저장소 구성 → Redis Cluster 등 분산환경에서 안정적인 데이터 관리 가능

보안체계 → 악성 스크립트 공격으로 부터 안전 보장, TLS 지원

- **속도**: µs 단위 응답 속도 (메모리 기반)
- **확장성**: 클러스터링으로 수평 확장 가능
- **자료구조 다양성**: 유연한 데이터 처리
- **유지보수 쉬움**: 명령어 간단 + 시각화 도구 존재

### 사용 예시

유명가수의 티케팅을 웹에서 한다고 가정해보자. 티켓팅이 열리는 순간 엄청난 양의 데이터가 DB에 쓰기 위해 몰리게 된다. 이때 DB 에러가 발생하여 결제가 되지 않는다면 엄청난 손해를 발생할 수 있다. 이때 해결책으로 레디스의 캐시를 사용한다. 

**Look aside cache(조회 로직)**을 보면 클라이언트가 웹서버에 요청을 하면 웹서버는 먼저 Cache에서 데이터 존재 유무를 확인하다. 이때 Cache에 데이터가 있으면 바로 꺼내주고, 없다면 DB를 확인해서 Cache에 먼저 자장한 후에 클라이언트에게 데이터를 돌려준다.

**Write Back(저장 로직)**을 보면 클라이언트가 웹서버에 요청을 하면, 웹서버는 DB에 바로 저장을 하는 것이 아니라 Cache에 결과를 쓰고 바로 클라이언트에게 결과 값을 리턴해 준다. 그 후에 Cache 서버에 있는 데이터들을 Worker(워커) 서버들이 데이터를 가져와서 작업을 수행하고 DB에 작성한다. 이렇게 되면 DB는 순차적으로 Transaction을 처리할 수 있게 된다. 정리하면, 데이터를 캐시에 먼저 전부 저장해 둔 후에 특정 시점마다 캐시의 데이터를 DB에 insert 하는 방식이다. insert를 1개씩 500번 하는 것보다 500개를 한 번에 insert 하는 빠르고 성능이 좋다는 것을 알 수 있을 것이다.

## **✅ 2. Redis TTL (Time To Live)**

### **🔹 개념**

TTL은 **Key가 Redis에 저장된 후 얼마 동안 유효한지를 설정하는 만료 시간**을 의미함

→ 일정 시간이 지나면 해당 키는 자동으로 삭제됨

- TTL 단위: 초(seconds) 또는 밀리초(milliseconds)
- Redis는 TTL이 지난 키를 **비동기적으로 삭제**하거나 **액세스 시점에 제거**

### **🔹 명령어 정리**

| **명령어** | **설명** |
| --- | --- |
| EXPIRE key seconds | 해당 키를 X초 후에 만료되도록 설정 |
| PEXPIRE key ms | 해당 키를 X밀리초 후에 만료 설정 |
| TTL key | 남은 TTL (초)를 조회 (-1은 만료 없음, -2는 이미 삭제됨) |
| EXPIREAT key timestamp | 지정한 UNIX 시간에 만료되도록 설정 |

### **🔹 왜 사용하는가?**

1. **캐시 무효화 자동화**
    - 자주 변하는 데이터는 일정 시간만 보관 후 삭제
        
        → 오래된 정보 제공 방지
        
2. **세션 관리**
    - 로그인 세션, 인증 토큰 등에 TTL 적용하여 **자동 로그아웃** 가능
3. **리소스 절약**
    - 불필요한 키가 Redis에 **영구 저장되지 않게 함**
    

### **🔹 실무 예시**

- 로그인 토큰 TTL: 30분
- 이메일 인증 코드: 5분
- 비밀번호 재설정 링크: 10분
    
    → 5분 후 자동 삭제되어 **만료된 인증코드 방지**
    

### **🔹 주의할 점**

- 너무 짧은 TTL은 데이터 누락의 위험
    
    → 너무 짧게하면 데이터가 예상보다 빨리 삭제되어 누락이 발생한다고 함
    
- TTL 없는 키는 **수동 삭제 필요**
    
    → 이렇게 수동삭제해야하면 로직을 좀 더 복잡하게 해야함
    
- Redis가 과도한 TTL 키를 동시에 삭제하려 할 경우 **성능 저하 가능**

## **✅ 3. 캐시 무효화 전략 & LRU**

### **🔹 개념**

캐시는 **자주 접근되는 데이터**를 메모리에 저장하여 응답 속도를 높이는 기법이지만

**원본 데이터가 바뀌었을 때 캐시가 낡아지는(stale) 문제가 발생함**

→ 이를 해결하기 위한 것이 **캐시 무효화 전략**

### **🔹 주요 캐시 무효화 전략**

### **Time-based Expiration (TTL)**

- TTL을 설정하여 **일정 시간 후 자동 삭제**
- 자주 변하지 않는 데이터에 적합
    
    ex) 공지사항, 상품 가격 정보
    

### **Write-through**

- 데이터를 캐시에 먼저 쓰고, 그 즉시 DB에도 반영
- 데이터 일관성은 좋지만 쓰기 성능이 낮음

### **Write-around**

- 데이터를 캐시에 쓰지 않고 DB에만 저장
- 자주 조회되지 않는 데이터에 적합
    
    → 이후 조회 시 다시 캐시에 로딩됨
    

### **Write-back (Write-behind)**

- 먼저 캐시에만 쓰고, 나중에 비동기적으로 DB에 반영
- 쓰기 성능은 좋지만 장애 시 **데이터 손실 가능성** 있음

### **Cache Invalidation (수동 무효화)**

- DB 데이터 변경 시 명시적으로 캐시 제거

### **🔹 캐시 교체 알고리즘 (Eviction Policy)**

메모리 한도가 찼을 때 어떤 데이터를 제거할지 결정하는 전략

### **LRU (Least Recently Used)**

- 가장 오랫동안 사용되지 않은 데이터를 제거
- Redis의 기본 전략 중 하나 (maxmemory-policy allkeys-lru)

### **기타 정책**

- **LFU**: Least Frequently Used (사용 빈도 기준)
- **FIFO**: First-In First-Out (삽입 순서 기준)

### **🔹 실무 예시**

| **상황** | **전략** |
| --- | --- |
| 공지사항, 베스트상품 등 자주 조회 + 거의 안 바뀜 | TTL (Time-based) |
| 장바구니, 로그인 세션 | LRU + TTL |
| 실시간 인기 검색어 | LRU + 수시 업데이트 |
| 결제 정보 등 DB 동기화 필요 | Write-through or Write-back |

## **✅ 4. Optimistic Lock vs Pessimistic Lock**

### **🔹 개념**

동시에 여러 트랜잭션이 같은 데이터를 수정하려 할 때 발생할 수 있는 경쟁 조건(Race Condition)을 방지하는 **락(Lock) 전략**

### **🔹 Optimistic Lock (낙관적 락)**

- 데이터를 수정할 때는 락을 걸지 않고 **최종 커밋 시점에 충돌을 검사**
- 일반적으로 버전 번호나 **타임스탬프**를 비교하여 데이터의 변경 여부를 판단

### **특징**

- 락을 걸지 않기 때문에 **성능에 유리**
- 충돌이 자주 발생하지 않는 환경에 적합
- 충돌 시점에만 예외 발생 및 재시도 필요

### **실무 사례**

- **게시글 좋아요 수 증가**: 사용자마다 거의 충돌 없이 업데이트 가능
- **장바구니 담기**: 동시에 같은 상품 담는 일 거의 없음

### **🔹 Pessimistic Lock (비관적 락)**

- 데이터를 사용할 때 **즉시 락을 걸어 다른 트랜잭션의 접근을 차단**
- 충돌 가능성이 높은 경우에 사용

### **특징**

- 데이터 정합성 보장에 유리
- 하지만 락 경합 시 **대기 시간 증가**, **데드락 발생 가능성** 있음

### **실무 사례**

- **재고 처리, 결제 시스템**: 수량 감소는 중복되면 안 됨
- **은행 송금 처리**: 동시에 두 사용자가 송금하면 안 되는 경우

### **🔹 정리**

| **항목** | **Optimistic Lock** | **Pessimistic Lock** |
| --- | --- | --- |
| 방식 | 버전 비교로 충돌 감지 | 선점해서 락 획득 |
| 성능 | 충돌 적으면 빠름 | 충돌 많으면 오히려 유리 |
| 락 범위 | 없음 | 트랜잭션 동안 유지 |
| 데드락 위험 | 없음 | 있음 |
| 적용 환경 | 읽기 많은 환경 | 쓰기 충돌 많은 환경 |

## **✅ 5. 비정상 종료 시 Lock 처리 & Deadlock**

### **🔹 비정상 종료 시 Lock 처리**

**문제 상황**

- 트랜잭션 수행 중 서버 다운, 애플리케이션 종료, 예외 발생 시 **Lock**이 걸린 상태에서 해제되지 않는 문제 발생 가능

**DBMS의 처리 방식**

- 대부분의 DBMS는 **트랜잭션 단위로 Lock을 관리**
    
    → 트랜잭션이 강제로 종료되면 **자동으로 롤백**되며 락도 해제됨
    

**주의 사항**

- 수동으로 락을 구현하거나 분산 락(Redis 등)을 사용할 경우 **직접 Lock 해제를 신경 써야 함 → 자동 해제 기능이 없기 때문에 서버가 다운되면 락이 영구적으로 남을 수 있음**
- Redis 분산 락 사용 시 TTL 설정 또는 LUA 스크립트를 이용한 락 해제 필수
    - **TTL 설정**: 일정 시간이 지나면 락 자동 만료
    - **Lua 스크립트**: 락 소유자가 직접 락 해제할 때만 삭제되도록 보장
    - **Redlock 알고리즘**: 다중 Redis 노드에서 락을 검증해 안전성 확보

### **🔹 Deadlock (교착 상태)**

### **개념**

두 개 이상의 트랜잭션이 서로가 점유하고 있는 자원을 기다리며 **무한 대기 상태**에 빠지는 현상

### **발생 조건**

1. **상호 배제**: 하나의 자원을 둘 이상이 동시에 사용할 수 없음
2. **점유와 대기**: 자원을 점유한 상태에서 다른 자원을 기다림
3. **비선점**: 자원을 강제로 빼앗을 수 없음
4. **환형 대기**: 트랜잭션들이 원형으로 자원을 점유하고 기다림
    
    → 위 4가지 조건이 모두 충족될 때 Deadlock 발생 가능
    

### **🔹 해결 전략**

### **예방(Prevention)**

- **자원 요청 순서 통일** → 항상 A → B 순으로 락 요청
- **한 번에 모든 자원 확보** → 자원이 모두 확보되지 않으면 트랜잭션 시작 안 함
- **락 타임 제한** → 일정 시간 안에 자원 획득 못하면 실패 처리

### **회피(Avoidance)**

- **트랜잭션의 자원 접근 순서 통일**
    - 항상 A → B 순서로 락을 걸게 하면 B → A로 역순 접근이 차단되어 데드락 방지
- Redis에서 락 TTL 설정 + 해제 로직 명확히 해야함
    - 일정 시간 후 강제로 트랜잭션 종료 → 교착 상태에서 벗어남
    

### **검출(Detection)**

- DB가 **데드락을 탐지**하고 자동으로 트랜잭션 중 하나를 kill
- MySQL InnoDB는 내부적으로 데드락 탐지 알고리즘 동작

### **회복(Recovery)**

- 데드락 발생 시 실패한 트랜잭션을 **롤백 후 재시도 로직 구현**
- **Retry 로직을 코드에 반영** (ex. 재시도 횟수 제한, 대기 시간 적용)
