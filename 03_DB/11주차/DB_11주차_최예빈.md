# Redis란?

**🔍 Key, Value** 구조의 비정형 데이터를 저장하고 관리하기 위한 오픈 소스 기반의 비관계형 데이터 베이스 관리 시스템 (DBMS)

- 비동기 처리, 캐싱, 세션 저장, 메시지 큐, 분산 락 등 다양한 용도로 사용됨
- 주로 **RAM**에 데이터를 저장하므로, 읽기/쓰기 속도가 압도적으로 빠름

## 언제/왜 사용하나?

| 사용 상황 | 이유 |
| --- | --- |
| 자주 조회되는 데이터를 캐시할 때 | DB 부하 감소, 응답 속도 향상 |
| 세션 데이터 저장 | 빠른 읽기/쓰기 및 TTL 지원 |
| 분산 시스템에서 Lock 처리 | `SETNX`, `Redlock` 사용 |
| 메시지 큐 처리 | Pub/Sub 또는 Stream 기능 활용 |

# Redis TTL (Time To Live)

**키에 유효 기간을 설정**하는 기능

- 지정된 시간이 지나면 자동으로 키가 삭제된다.
- 만료 시간을 설정하지 않으면 사용자가 명시적으로 삭제하지 않는 한 영원히 저장된다.

# 캐시 무효화 전략

### **1. TTL 기반 만료**

- 데이터가 일정 시간 지나면 자동 삭제됨 (EXPIRE)

### 2. **LRU (Least Recently Used)**

- 가장 오래 사용되지 않은 데이터부터 제거

### 3. **LFU (Least Frequently Used)**

- 접근 횟수가 적은 키부터 제거

### 4. **수동 무효화**

- 데이터 업데이트 시 `DEL` 명령으로 캐시 삭제 후 다시 저장

### 5. **Write-through / Write-back / Cache-aside 패턴**

- Cache-aside: 요청 시 캐시 miss → DB 조회 후 캐시에 저장

# Optimistic vs Pessimistic Lock 실무 예시

| 구분 | Optimistic Lock | Pessimistic Lock |
| --- | --- | --- |
| 개념 | 충돌을 가정하지 않고 진행, 충돌 시 롤백 | 항상 락을 걸고 작업 |
| 실무 적용 | 쇼핑몰에서 재고 업데이트 시 버전 체크 | 은행 송금, 티켓 예매 등 동시성 민감 작업 |
| 기술 | DB의 `version` 컬럼, `CAS` 연산 | `SELECT ... FOR UPDATE`, Redis Lock 등 |
| 장점 | 성능 좋음, 충돌이 적을 경우 유리 | 충돌 없이 안전함 |
| 단점 | 충돌 많으면 성능 저하 | 락으로 인해 병목 발생 가능 |

# 비정상 종료 시 Lock 처리 방식

- 상황 : 트랜잭션 도중 애플리케이션/서버가 강제 종료되거나 예외로 인해 중단되면, 락이 해제되지 않고 남아 있을 수 있음
- 문제점
    - 데이터에 접근하려는 다른 트랜잭션이 무한 대기 상태가 됨
    - 시스템 전체 지연, 병목, 응답 불가로 이어질 수 있음
- 해결 방식
    - 트랜잭션 타임아웃을 설정
    - 커넥션 풀 관리
    - 애플리케이션 수준에서도 예외 처리 철저히 하기
    - 자체적으로 락 관리하기

# Deadlock 원인과 회피/해결 방법

## Deadlock 발생 원인

- 서로 다른 트랜잭션이 자원을 점유한 채 **서로 상대 자원**을 기다리는 상황
- 순환 대기 구조 → 무한 정체

## Deadlock 회피 및 해결 방법

1. **락 획득 순서 고정**
    - 모든 프로세스가 동일한 순서로 자원 요청 → 순환 대기 방지
2. **타임아웃 설정**
    - 일정 시간 이상 락 점유 실패 시 자동 종료
3. **락 재시도 로직 구현**
    - 락 획득 실패 시 일정 시간 후 재시도 (백오프 포함)
4. **분산 락 알고리즘 사용**
    - 예: Redis Redlock → 다중 Redis 노드에 락 분산
5. **락 최소화 및 빠른 해제**
    - 락 점유 시간을 가능한 짧게 유지해 충돌 가능성 낮춤