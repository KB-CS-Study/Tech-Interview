# Redis와 캐싱 전략 + Locking + Deadlock

## Redis란?

- Redis(Remote Dictionary Server)는 메모리 기반의 Key-Value 저장소다.
- 일반적으로 NoSQL 계열로 분류되며, 단순한 문자열(String)뿐 아니라 리스트(List), 집합(Set), 해시(Hash), 정렬된 집합(Sorted Set) 등 다양한 자료형을 지원한다.
- 데이터를 디스크가 아닌 메모리(RAM) 에 저장하여 매우 빠르게 읽고 쓸 수 있다.
- Redis는 단순 캐시를 넘어 세션 저장소, 카운터, 분산락, 메시지 큐, Pub/Sub 등 다양한 용도로 활용된다.

## Redis는 언제 쓸 수 있을까?

1. 조회수, 좋아요 수 등의 카운터 처리
   - 데이터 정합성보다는 누적 통계가 중요하고,
   - 요청량이 많아 DB로 바로 저장하기 부담스러울 때 적합하다.
   - INCR 명령으로 락 없이 빠르게 증가시킬 수 있다.
2. 세션 저장소
   - 로그인 상태 같은 데이터를 TTL을 걸어 자동으로 만료시키면서 관리할 수 있다.
   - 스프링 세션, JWT 리프레시 토큰 등에도 활용된다.
3. 캐시
   - DB에서 가져온 결과를 Redis에 저장하고, 다음 요청에서 빠르게 꺼내 쓰는 구조다.
   - 대표적으로 게시글 리스트, 상세 페이지, 검색어 자동완성 등이 있다.
4. 분산락
   - 멀티 서버 환경에서 동시 접근을 제어할 때 Redisson 같은 라이브러리를 통해 락을 구현할 수 있다.
   - SETNX와 EXPIRE를 활용해 race condition을 막는다.
5. API Rate Limit
    - 하나의 사용자나 IP가 초당 몇 번 이상 호출하지 못하도록 제한할 때 Redis의 INCR와 TTL을 조합해 구현할 수 있다.

## Redis는 왜 사용할까?

- 분산처리 환경에서 Local 캐시의 경우 일관성이 없을 수 있으며, 일관성이 보장된다고 하더라도 각 서버마다 각각 캐싱을 해야한다는 문제점이 발생한다.
- 서버에 캐싱을 하게되면 메모리 사용량이 증가하여 서버의 퍼포먼스에 영향이 생길 수 있다.(생긴다 X, 가능성 존재)
- 멀티 쓰레드 환경에서 Map과 같은 자료구조에 접근하다가 문제(Race Condition)가 발생할 수 있다.
- 이러한 문제를 해결하기 위해서 redis를 사용한다.

## Race Condition이란?

- Race Condition이란 여러개의 Thread가 경합하는 것으로 Context Swithcing에 따라서 원하지 않는 결과가 발생할 수 있다.
- 따라서 Redis는 기본적으로 Single Threaded로 동작한다.

## Redis TTL

### Redis의 TTL 특성

- Redis는 지정된 시간이 지나면 키가 자동으로 삭제되는 TTL 기능을 제공한다.
- 만료 시간을 설정하지 않으면 사용자가 명시적으로 삭제하지 않는 한 영원히 저장된다.
- 현재 컴퓨터 시간을 기반으로 TTL이 동작하기 때문에 만료 시간을 1000초로 설정해 놓고 현재 컴퓨터 시간을 2000초로 바꾸면 즉시 만료된다. 현재 컴퓨터 시간을 기반으로 TTL이 동작하기에, Redis 인스턴스가 현재 켜져 있지 않더라도 시간이 카운팅 된다.
- 2.4에서는 TTL 오차가 0~ 1초였지만 2.6부터는 TTL 오차가 0초 ~ 1 밀리초로 개선되었다.

### TTL 동작 과정

- Redis는 수동적인 만료와 능동적인 만료를 지원한다.
  - 수동적인 만료
    - 액세스를 시도할 때까지 실제로 키를 만료(삭제)하지 않는다. 키를 읽을 때마다 키가 이미 만료되었는지 확인하고 만료된 경우 자동으로 null키를 반환하고 삭제한다.
    - 구현이 단순하다는 장점이 있다.
    - 하지만 키에 접근하지 않으면 영원히 만료되지 않으며 계속해서 메모리 공간을 차지한다는 치명적인 단점이 있다. 그래서 수동적인 만료의 단점을 보완하기 위한 것이 능동적인 만료이다.
    - 능동적인 만료
      - 주기적으로 무작위의 몇 개의 키를 확인하고 만료된 키가 있으면 계속 진행하며 키를 제거한다.
      - 구체적인 예시는 다음과 같다.
        ```
        Redis가 초당 10회로 다음 작업을 수행한다.
          1. TTL이 첨부된 임의의 키 20개를 테스트한다.
          2. 20개 중 만료된 모든 키를 삭제한다.
          3. 20개 중 25% 이상이 만료된 경우, 1단계를 반복한다.
    
      - 간단히 말하자면 확률 알고리즘을 활용하여 만료된 키의 비율을 확인하고 만료된 키가 많다면 무작위로 키를 확인하고 필요에 따라 만료하는 작업을 반복한다.

## 캐시 무효화 전략

### TTL

- 캐시 항목마다 유효 기간을 설정하여 일정 시간이 지나면 캐시된 데이터를 자동으로 무효화하는 방식
- 장점: 캐시된 데이터가 오래 유지되지 않기 때문에 데이터 일관성을 일정 수준으로 유지할 수 있다.
- 단점: 데이터가 자주 변경되는 경우, TTL을 짧게 설정하면 캐시가 자주 갱신되어 캐시 히트율이 낮아질 수 있으며, TTL이 너무 길면 오래된 데이터가 사용될 수 있다.

### 수동 무효화(Manual Invalidation)

- 애플리케이션이 특정 이벤트(데이터 변경, 삭제 등)에 따라 캐시를 명시적으로 제거하거나 갱신하는 방식
- 사용 사례: 데이터베이스에서 변경 또는 삭제 이벤트가 발생했을 때 해당 데이터와 연관된 캐시 항목을 무효화한다.
- 장점: 데이터가 변경된 시점에 즉각적으로 캐시를 갱신하므로 일관성을 보장할 수 있다.
- 단점: 구현이 복잡할 수 있고, 특정 상황에서 캐시 갱신을 놓칠 수 있는 버그가 발생할 위험이 있다.

### 삭제 후 재로드(Write-Through/Write-Behind)

- Write-Through: 데이터를 DB와 캐시에 동시에 쓰는 방식으로 데이터가 변경될 때마다 캐시에 즉시 반영하므로 일관성이 높다.
- Write-Behind: 데이터가 DB에 저장된 후 일정 시간 후에 캐시에 기록되는 방식으로, 지연 쓰기가 이루어진다.
- 장점: 데이터 일관성을 유지하고 캐시 히트율이 높아진다.
- 단점: Write-Behind는 DB와 캐시 간 데이터 불일치가 발생할 수 있다.

### 캐시 갱신(Cache Refresh)

- 주기적으로 캐시된 데이터를 백그라운드에서 갱신하는 방식으로, 이는 캐시의 유효성을 높이며, 데이터 변경을 예측할 수 없을 때 사용된다.
- 장점: 캐시가 오래되지 않도록 주기적으로 갱신되며, 일관성도 높일 수 있다.
- 단점: 데이터가 실제로 변경되지 않았을 때도 불필요한 갱신이 발생할 수 있어 리소스 낭비가 발생할 수 있다.

### Lazy Invalidation

- 캐시에 저장된 데이터를 사용하려고 할 때 유효성을 확인하고, 만약 데이터가 오래되었다면 그때 무효화 및 갱신하는 방식
- 장점: 실시간으로 변경된 데이터를 반영할 수 있고, 불필요한 캐시 갱신을 줄일 수 있다.
- 단점: 데이터를 조회하는 시점에 무효화가 일어나면 성능 저하가 발생할 수 있다.

### Cache-aside

- 데이터 요청 시점에만 캐시를 조회하는 방식으로, 캐시에 데이터가 없거나 오래된 경우 DB에서 데이터를 가져와 캐시에 저장합니다. 주로 Lazy Invalidation과 함께 사용된다.
- 장점: 캐시에 저장된 데이터는 주로 최신 데이터가 된다.
- 단점: 최초 데이터 조회 시 캐시에 데이터가 없을 경우 DB 조회로 인한 성능 저하가 발생할 수 있다.

### LRU (Least Recently Used) 캐싱 알고리즘

- 컴퓨터 시스템에서 자주 사용하는 데이터를 빠르게 검색할 수 있도록 도와주는 캐시 알고리즘이다.
- 핵심 아이디어는 가장 최근에 사용된 데이터는 미래에도 계속해서 사용될 가능성이 높다는 것이다.
- LRU 캐시는 최근에 사용되지 않은 데이터를 캐시에서 제거하는 방식으로, 메모리 관리를 효과적으로 할 수 있게 해준다.
- LRU 캐시는 연결 리스트와 해시 테이블을 결합하여 O(1)의 시간 복잡도로 데이터의 조회, 삽입, 삭제를 수행할 수 있는 구현이 가능하다.

## Optimistic vs Pessimistic Lock

### 낙관적 락(Optimistic Lock)

- 트랜잭션 대부분이 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법
- 버전 정보를 이용하여 동시성을 제어
- 낙관적 락을 사용할 때는 트랜잭션 커밋 시 버전 정보가 달라 발생하는 예외에 대해 예외처리를 해주고, 예외가 발생했던 로직을 재시도해야한다.
- 예외 처리를 해주지 않으면, 같은 로직을 사용하는 요청에 대해 비즈니스 예외 상황이 아님에도 불구하고 요청이 실패할 수 있게된다.
- 단점
  - 개발자가 재시도 로직을 직접 작성해줘야 한다
  - 충돌이 많아짐에 따라 쿼리를 재수행해야 되므로 그에 따른 비용이 증가한다

### 비관적 락(Pessimistic Lock)

- 트랜잭션의 충돌이 발생한다고 가정하고, 데이터에 우선 락을 검으로써 데이터 정합성을 보장하는 방식
- 데이터베이스의 배타락을 사용한다.
- 단점
  - 데드락 발생 가능성

### 둘 중에 무엇을 사용해야하는가

- 충돌이 잦은 로직이냐, 아니냐가 선택 기준점이 된다.
- 충돌이 잦은 경우는 비관적 락, 충돌이 적은 경우는 낙관적 락을 고려하면 된다.
- 충돌이 많이 일어날지 잘 모르는 경우에는 우선 낙관적 락을 이용하다가(비관적 락에서 사용하는 데이터베이스 락 자체가 비용이므로), 운영상에서 이로 인한 성능 이슈가 발생할 때 비관적 락이나 다른 방법을 고려해보는 것이 괜찮은 방법이 될 것이다.

## 비정상 종료 시 Lock 처리 방식

- Lock Timeout
  - Lock을 걸 때, 타임아웃을 설정해 일정시간이 지나면 자동으로 Lock을 해제하도록 한다.
- Deadlock Detection
  - 교착상태가 발생하면 사후에 트랜잭션들 중 하나를 강제종료(rollback) 시키는 조치를 취하는 방식이다.
- 일반적인 회복 방법
  - 이외에도 Redo, Undo와 같은 회복 방법을 통해 트랜잭션으로 손상된 부분을 회복시킬 수 있다.
  - Redo (Media Recovery)
    - 비소멸장치(디스크, 테이프 등)의 내용 손상에 대한 회복 기법이다.
    - 가장 최근의 복제본(dump)을 적재시키고, 해당 복제본 이후의 변경을 log를 이용해 재실행하여 DB를 복원한다.
  - Undo
    - log를 이용해 모든 변경을 취소시키므로써 DB를 복원한다.

## Deadlock 원인과 회피/해결 방법

### 교착상태(Deadlock)란 ?

- 두 개 이상의 프로세스가 서로의 작업이 끝나기만을 기다리고 있어 둘 다 영원히 끝나지 않는 상황

![](https://velog.velcdn.com/images/ejung803/post/95cb7336-9fb4-4bb7-a769-41496a7c413a/image.png)

### 교착상태의 4가지 필요 조건

- 아래 4가지 조건이 모두 만족되는 경우 데드락이 발생할 가능성이 있다.
   → 하나라도 만족하지 않으면 발생하지 X

1. 상호 배제 (Mutual exclusion)
   - 한 리소스는 한 번에 한 프로세스만이 사용할 수 있다.
   - 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.
2. 점유와 대기(Hold and wait)
   - 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
3. 비선점 (No preemption)
   - 이미 할당된 자원을 강제로 빼앗을 수 없다.
   - 프로세스가 task를 마친 후 리소스를 자발적으로 반환할 때까지 기다려야 한다.
4. 환형 대기 (Circular wait)
   - 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.
   - Hold and wait 관계의 프로세스들이 서로를 기다림

### 교착상태 해결방법

1. 예방 (Prevention)
   - 교착상태가 발생할 수 있는 요구조건을 만족시키지 않게 함으로써 교착상태를 방지한다.
   - 위에 있는 교착상태 발생의 네가지 조건 중에서 어느 하나를 제거함으로써 수행된다.
   - 자원 낭비가 가장 심한 기법이다.
2. 회피 (Avoidance)
   - 교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법이다.
   - 리소스 할당의 측면에서, 교착상태가 발생할 가능성이 있는 자원 할당(unsafe allocation)을 하지 않는다.
   - 주로 은행원 알고리즘(Banker's Algorithm)이 사용된다.
     - 은행원 알고리즘
       - 은행원 알고리즘은 다익스트라가 제안한 기법으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래한 기법
       - 각 프로세스에게 자원을 할당하여 교착상태가 발생하지 않으며 모든 프로세스가 완료될 수 있는 상태는 안전상태, 교착상태가 발생할 수 있는 상태는 불안전 상태 라고 한다.
       - 은행원 알고리즘을 적용하기 위해서는 자원의 양과 사용자(프로세스) 수가 일정해야 한다.
       - 은행원 알고리즘은 프로세스의 모든 요구를 유한한 시간안에 할당하는 것을 보장한다.
3. 탐지 및 회복 (Detection and Recovery)
   - 교착상태가 발생 할 수 있도록 놔 두고 교착상태가 발생 할 경우 찾아내어 고친다.
   - 탐지
     - 시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견한다.
     - 교착상태 발견 알고리즘과 자원 할당 그래프 등을 사용한다.
   - 회복
     - 교착상태를 발견했다면 회복기법을 진행한다.
     - 교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복한다.