# Redis와 캐싱 전략 + Locking + Deadlock

### Redis란?

- Redis는 빠른 오픈 소스 인메모리(In-Memory) Key-Value 데이터 구조 스토어
- 일반적인 DB는 디스크에 저장되지만, Redis는 RAM을 사용해 빠른 읽기/쓰기 속도
- 휘발성 메모리 특성을 보완하기 위해 다음과 같은 영속성(Persistence) 전략을 제공
    - **RDB(Snapshot)**: 특정 시점의 데이터를 주기적으로 디스크에 저장
    - **AOF(Append Only File)**: 모든 쓰기 명령을 로그로 기록 → 서버 재시작 시 복구 가능
- 다양한 데이터 타입 지원:
    - `String`, `List`, `Set`, `Sorted Set`, `Hash` 외에도 `Stream`, `Bitmap`, `JSON`, `Geo` 등 확장 가능

---

### 언제 사용하는가?

- **캐시(Cache)**: 자주 사용하는 API 응답이나 DB 질의 결과를 저장해 성능 향상
- **세션 저장소**: 로그인 세션이나 장바구니 정보 저장에 적합
- **Pub/Sub**: 채팅, 알림, 실시간 이벤트 분산 처리
- **실시간 분석 및 카운터**: 트래픽, 조회수, 게임 점수판 등
- **검색 인덱스**: RedisJSON, RediSearch를 통해 텍스트 검색 및 필터링 가능

---

### 왜 사용하는가?

- ⚡ **초고속 처리 속도**: RAM을 활용해 밀리초 단위 응답
- 🧩 **다양한 구조 지원**: 문자열, 리스트, 셋, 정렬된 셋, 해시 등 구조화된 데이터 처리
- 🏗️ **확장성과 고가용성**: Sentinel, Cluster, Active-Active 구성 지원

---

### Redis TTL

- TTL(Time To Live)
    - Redis에 저장된 key에 대해 유효기간을 설정하는 기간
    - 지정된 시간이 지나면 해당 key는 자동으로 삭제
- 주요 명령어 정리

| **명령어** | **설명** |
| --- | --- |
| EXPIRE key seconds | 해당 key를 지정한 초(seconds) 후에 만료시키기 |
| EXPIREAT key timestamp | 지정한 UNIX timestamp(초 단위 시각)에 key 만료 |
| TTL key | 해당 key의 남은 TTL(초 단위)을 조회 (-1: 영구적, -2: 없음) |
| PERSIST key | 만료 시간 제거 (key를 영구적으로 변경) |
| SET key value EX seconds | 값 설정과 동시에 TTL 설정 (EX는 초 단위, PX는 밀리초) |

```SQL
SET session:1234 "user data"
EXPIRE session:1234 1800   # 30분 후 자동 삭제

# 또는 한 줄로
SET session:1234 "user data" EX 1800
```

- TTL을 사용하는 이유


    | **목적** | **설명** |
    | --- | --- |
    | 캐시 데이터 자동 삭제 | 오래된 캐시를 자동으로 제거해 스토리지 낭비 방지 |
    | 세션 만료 처리 | 로그인 세션을 일정 시간 후 자동 로그아웃 가능 |
    | 일시적 제한 | 로그인 시도 횟수 제한 등에서 일정 시간 후 제한 해제 가능 |
    | 데이터 정합성 유지 | 실시간성이 필요한 데이터(예: 주식 시세)는 TTL로 자동 갱신 |
- TTL 적용을 언제하면 좋을까?
    - 로그인/세션 관리 (session:userId, accessToken)
    - 주가/환율/날씨 등 실시간 API 캐싱
    - 로그인 실패 횟수 제한 (rate limiting)
    - 일정 시간 후 만료되는 인증번호 저장 (ex: SMS 인증번호)

- TTL 적용 시 주의사항
    1. 만료된 키는 즉시 삭제되지 않을 수 있다
        - Redis는 메모리 최적화를 위해 Lazy deletion 또는 주기적인 스캔을 통해 키를 제거
    2. TTL은 key단위로 적용
        - value 내부에 여러 속성이 있어도 TTL은 전체 key에 적용
    3. 갱신 시 TTL 리셋 주의
        - SET으로 다시 값을 설정하면 TTL이 초기화되므로 재설정 필요

---

### 캐시 무효화 전략, LRU 등

- 캐시에 저장된 데이터가 더이상 유효하지 않을 때 이를 갱신하거나 제거하는 전략
- 무효화 전략을 통해 데이터의 신뢰성과 일관성을 보장
- 캐시 무효화 전략으로는 `TTL 기반`, `수동 무효화`, `삭제 후 재로드`, `캐시 갱신`, `Lazy Invalidation`, `Cache-aside` 등이 있다.


    | **전략명** | **설명** |
    | --- | --- |
    | **1. TTL (Time To Live)** | 캐시 항목에 **유효시간**을 지정하고, 시간이 지나면 자동 삭제→ 자주 바뀌지 않는 데이터에 적합 |
    | **2. 수동 무효화 (Explicit Invalidation)** | 데이터가 변경될 때 **명시적으로 캐시 삭제**예: 게시글 수정 시 cache.delete("post:123") |
    | **3. Lazy Invalidation** | 읽을 때마다 **DB와 비교 후** 캐시가 다르면 갱신→ 읽기 성능은 떨어지나, 정합성 보장 |
    | **4. Write-through** | DB에 쓰는 동시에 캐시도 **같이 갱신**→ 정합성 높지만, 쓰기 비용 증가 |
    | **5. Write-back / Write-behind** | 캐시에 먼저 쓰고, **비동기로 DB에 반영**→ 쓰기 성능은 좋지만, 장애 시 데이터 유실 가능 |
    | **6. Cache-aside (Lazy loading)** | DB에서 먼저 읽고 캐시에 저장, 갱신 시에는 수동 삭제→ **가장 일반적인 전략**, 읽기 캐시 적합 |
- 필요한 이유
    - 캐시는 성능을 높이지만, DB와 데)이터 불일치가 생기기 쉽기 때문
    - 오래된 캐시로 인해 사용자에게 잘못된 정보가 제공될 수 있음
    - 무효화 전략을 통해 최신 데이터를 유지하면서도 성능을 잡을 수 있음
- 문제점 : 데이터 정합성 문제
    - 데이터 정합성 : 어느 한 캐시(Cache Store)와 데이터베이스(Data Store)이 두 곳에서 같은 데이터임에도 불구하고 데이터 정보값이 서로 다른 현상 (정보 불일치)
    - 예 : 사용자 프로필이 바뀌었는데 화면에 여전히 이전 이름이 보이는 경우

### LRU(Least Recently Used) 캐시 정책

- 메모리가 꽉 찼을 경우 가장 오래 사용되지 않은 데이터부터 삭제
- Redis, Spring Cache, Guava 등 기본 설정으로 자주 사용
- Redis에서 LRU는 Redis maxmemory-policy 설정을 통해 동작
    - ex. volatile-lru, allkeys-lru

### Optimistic vs Pessimistic Lock 실무 예시

- 개념 비교

| **구분** | **Optimistic Lock (낙관적)** | **Pessimistic Lock (비관적)** |
| --- | --- | --- |
| 락 방식 | **락을 걸지 않고** 갱신 시 충돌 검사 | **갱신 전에 락을 걸고** 다른 트랜잭션 차단 |
| 충돌 처리 | 버전 비교 → 다르면 갱신 실패 | 다른 트랜잭션이 끝날 때까지 대기 |
| 성능 | 충돌 적을 땐 빠름 | 락 경쟁 많으면 성능 저하 |
| 용도 | 조회 많은 서비스 (SNS 등) | 동시 수정 위험이 큰 서비스 (은행 등) |
- 실무 예시
    1. Optimistic Lock
        - 주로 version 기반 갱신 실패 감지 방식

       ex1) 게시글 좋아요 증가 **(조회 빈도 높고 충돌 가능성 낮은 경우)**

        - 여러 사용자가 동시에 “좋아요” 클릭 → 조회는 자주하지만 수정은 드물게 일어남
        - 해결 방법 : 게시글 테이블에 version 컬럼 추가 →  `UPDATE ... WHERE version = ?`
        - 갱신 시 버전 비교 → 다르면 갱신 실패, 재시도

       ex2) 상품 리뷰 수정 (**SNS, 커머스 UI 데이터)**

        - 리뷰는 작성 후 자주 바뀌지 않음
        - 동시에 수정할 가능성도 낮음
    2. Pessimistic Lock
        - 선점 후 작업 → 무조건 락을 걸고 처리
        - `SELECT ... FOR UPDATE` 등으로 **명시적으로 락을 걸고 작업**

       ex1) 은행 계좌 이체 **(정합성 최우선)**

        - 두 트랜잭션이 동시에 출금 요청 시, 금액이 꼬일 수 있음
        - 해결 방법 : 해당 row를 트랜잭션 끝날 때까지 락

       ex2) 주문 재고 차감 (**충돌 가능성이 크고 정확도 중요한 경우**)

        - 수량이 적은 상품 주문 시, 동시에 여러 사용자가 주문하면 재고 초과 문제 발생
        - 해결 방법 : 락을 걸고 수량 체크 후 감소

### 비정상 종료 시 Lock 처리 방식 & Deadlock 원인과 회피/해결 방법

- 비정상 종료 시 Lock 처리 방식
    - 상황 : 트랜잭션 도중 애플리케이션/서버가 강제 종료되거나 예외로 인해 중단되면, 락이 해제되지 않고 남아 있을 수 있음
    - 문제점
        - 데이터에 접근하려는 다른 트랜잭션이 무한 대기 상태가 됨
        - 시스템 전체 지연, 병목, 응답 불가로 이어질 수 있음
    - 해결 방식


        | **전략** | **설명** |
        | --- | --- |
        | **트랜잭션 타임아웃 설정** | 일정 시간 후 자동 롤백 및 락 해제→ spring.transaction.default-timeout, MySQL innodb_lock_wait_timeout |
        | **DBMS의 락 관리 기능** | 예: MySQL InnoDB는 세션이 끊기면 자동으로 롤백 & 락 해제 |
        | **애플리케이션 예외 처리** | try-catch-finally 블록으로 트랜잭션 명시적 종료 보장 |
        | **커넥션 풀 관리** | HikariCP 등에서 커넥션 유실 시 적절히 회수 및 초기화 |
- DeadLock
    - 여러 트랜잭션이 **서로가 가진 리소스를 요청하면서** 대기 상태에 빠져 **영원히 진행되지 않는 현상**
    - 발생 예시
        - 트랜잭션 A: 자원 X를 잡고 Y 요청
        - 트랜잭션 B: 자원 Y를 잡고 X 요청

          → 서로 **상대가 락을 해제할 때까지 기다림**

- DeadLock 발생 조건 4가지 (모두 만족해야함)

| **조건** | **설명** |
| --- | --- |
| **상호 배제(Mutual Exclusion)** | 하나의 리소스를 둘 이상의 트랜잭션이 동시에 사용할 수 없음 |
| **점유와 대기(Hold and Wait)** | 트랜잭션이 자원을 점유한 채, 추가 자원을 요청함 |
| **비선점(No Preemption)** | 점유한 자원을 강제로 빼앗을 수 없음 |
| **순환 대기(Circular Wait)** | 각 트랜잭션이 다음 트랜잭션의 자원을 기다림 |
- DeadLock 회피/해결 방법

| **방법** | **설명** |
| --- | --- |
| **락 순서 통일** | 트랜잭션마다 **동일한 순서로 테이블/리소스 접근**→ 순환 대기 방지 |
| **짧은 트랜잭션** | 트랜잭션 길이를 최소화해 락 점유 시간 줄이기 |
| **트랜잭션 타임아웃 설정** | 일정 시간 이상 대기하면 자동 중단 및 롤백 |
| **낙관적 락 사용 (Optimistic Lock)** | 충돌 발생 가능성이 낮은 경우 락 없이 버전 비교로 충돌 방지 |
| **DB Deadlock 감지 기능 사용** | MySQL, Oracle 등은 교착 상태 발생 시자동으로 하나의 트랜잭션을 강제 종료하고 복구 수행 |
| **Retry 로직 구현** | Deadlock이 발생한 트랜잭션을 **catch 후 재시도**하는 로직 구현 |

- 실무 예시
- 실시간 은행 계좌 이체 중 두 트랜잭션이 서로 다른 계좌의 잔액을 변경하려다 deadlock 발생
    - 해결: 트랜잭션 내 계좌 업데이트 순서를 고정
- 커머스 사이트에서 재고 감소 + 포인트 차감이 동시에 수행되며 교착 상태 발생
    - 해결: 짧은 트랜잭션 + 작업 순서 일관화 + retry 로직 도입

Q. Redis는 언제 사용하나요?

주로 DB 부하를 줄이거나 속도가 중요한 비동기 기능 구현 시 고려합니다. 디스크가 아닌 RAM에 데이터를 저장하기 때문에 빠르게 읽기/쓰기 성능이 필요한 상황에서 사용되기 때문입니다. 예를 들어, 투자 대시보드에서 주식 종목 정보를 Redis에 캐싱하면 DB 부하를 줄이면서 빠른 응답 가능합니다

Q. 캐시에 저장된 데이터가 DB와 다를 수 있는데, 데이터 정합성은 어떻게 보장하나요?

이를 해결하기 위해 보통 **캐시 무효화 전략**을 적용합니다. 캐시 무효화 전략으로는 TTL적용, 수동 무효화, Cache-aside 패턴 등이 있습니다. 또한 Redis Pub/Sub 또는 Kafka를 활용해 **캐시 무효화를 메시지 기반으로 처리**하는 방법도 실무에서 사용됩니다.

Q. DeadLock 발생 조건 4가지를 모두 말해주세요

상호 배제, 점유와 대기, 비선점, 순환 대기입니다.

- 상호 배제 : 하나의 리소스를 둘 이상의 트랜잭션이 동시에 사용할 수 없음
- 점유와 대기 : 트랜잭션이 자원을 점유한 채, 추가 자원을 요청함
- 비선점 : 점유한 자원을 강제로 빼앗을 수 없음
- 순환 대기 : 각 트랜잭션이 다음 트랜잭션의 장줜을 기다림