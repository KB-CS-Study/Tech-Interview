## Redis (Remote Dictionary Serve)

Redis란 Remote Dictionary Server의 약자로, 오픈 소스 **인메모리** 데이터 저장소이다.

주로 캐시, 메시지 브로커, 세션 저장소, 실시간 데이터 처리 등에 사용 됨

> Remote: 원격 서버 / Dictionary: 해시 테이블, 자바에 비유하면 해시 맵

-   \`키 -값\` 구조의 인메모리 데이터 베이스
-   빠른 속도 덕에 **캐시** 시스템이나 **실시간 애플리케이션**에서 많이 사용
-   데이터를 디스크에도 저장할 수 있어 **영속성**(persistence) 제공

> **❓ 영속성 (Persistence)이 머더라**  
> 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성

---

## 주요 특징 (장점)

| **특징**  | **설명** |
| --- | --- |
| **인메모리 저장소** | 모든 데이터를 \`**메모리(RAM)\`에 저장**하여 매우 빠름 (초당 수십만 건 처리 가능) |
| **데이터 구조 지원** | 문자열, 리스트, 셋(Set), 해시(Hash), 정렬된 셋(Sorted Set), 비트맵, 하이퍼로그로그 등 다양한 구조 |
| **영속성(Persistence)** | 메모리에 있는 데이터를 디스크에 저장 가능 (RDB, AOF 방식 지원) |
| **Pub/Sub 기능** | 메시지 브로커처럼 \`Publish/Subscribe\` 구조 지원 |
| **Atomic 연산** | 여러 명령도 원자적으로 처리 가능 |
| **복제 및 클러스터링** | Master-Slave 복제, 자동 샤딩(Cluster) 기능 제공 |
| **Lua 스크립트 지원** | 복잡한 로직을 서버 측에서 실행 가능 |

> **메모리에만 데이터를 저장하는 이유 👉 _속도_**   
> 메모리에서 데이터를 읽고 쓰는 속도는 디스크보다 수십 ~ 수백 배 빠름  
> Redis는 캐시나 실시간 처리 시스템처럼 **속도가 중요한 곳**에서 사용되므로 **메모리에 저장하는 게 적합함**

---

### Redis를 사용하는 때

1.  **캐시(Cache)로 사용할 때**
    -   자주 조회되지만 자주 바뀌지 않는 데이터를 저장하여 DB 부하 감소
    -   예: 사용자 프로필, 상품 목록, 게시물 인기 순위 등
2.  **세션 저장소(Session Store)로 사용할 때**
    -   웹 애플리케이션의 로그인 세션 유지
    -   예: 로그인 상태, 장바구니 정보 등을 Redis에 저장
3.  **Queue 시스템 (메시지 브로커)**
    -   Pub/Sub 구조로 간단한 메시지 큐 역할
    -   예: 알림 전송, 로그 수집, 작업 대기열 등
4.  **분산락(Lock) 시스템 구현 시**
    -   여러 서버 간 공유 자원 접근 제어
    -   RedLock 알고리즘 등으로 구현
5.  **실시간 데이터 처리**
    -   실시간 랭킹, 실시간 알림, 실시간 채팅 등
6.  **카운터/통계 저장**
    -   빠른 증가/감소 연산
    -   예: 좋아요 수, 조회 수, 방문자 수 등
7.  **Geospatial 데이터 처리**
    -   위치 기반 서비스 (주변 사용자, 매장 찾기 등)

---

### ❓ 어떻게 메모리에 다 저장할 수 있지?

Redis가 모든 데이터를 메모리에 저장한다는 의미는 실제로 **데이터를 디스크가 아닌 RAM에 저장하고 읽고 쓴다**는 뜻  
👉 당연히 RAM은 한정돼 있으므로 관련 로직이 필요함

1.  Redis는 메모리 사용한도 (\`**maxmemory**\`) 설정 가능
2.  한도를 넘어선다면, 정책에 따라 데이터를 **자동으로 제거** 가능
3.  캐시로 사용하는 경우에는 문제 없음  
    Redis는 **자주 접근되는 데이터**나 **짧은 시간만 필요한 데이터**를 저장하는 데 쓰이므로 이런 자동 제거 정책이 효율적임

---

### ❓ 영속적인 저장이 필요하다면?

Redis는 디스크에도 데이터를 저장할 수 있음 (RDB, AOF)

그러나 **조회/연산은 메모리에서만 수행**되며, **디스크는 재시작 시 복원용**임

---

#### Redis의 영속화

Redis는 메모리에 데이터를 저장하지만, 재부팅 및 장애 발생 시 데이터를 복구하기 위해 디스크에도 저장 가능

저장 방법: \`RDB\`, \`AOF\` 

#### 📸 1. RDB (Redis DataBase Snapshot)

**정해진 시간 간격**으로 Redis의 메모리 데이터를 그대로 **덤프 파일(\`dump.rdb\`)에 저장**

| **장점** | **단점** |
| --- | --- |
| 복원 속도가 빠름 (전체를 한 번에 불러옴) | 서버가 꺼지기 직전에 저장이 안 된 경우, 그 사이 변경된 데이터는 다 날아감   ex) 5분마다 저장되는데 4분쯤에 죽으면 4분 간 데이터 날아감 |
| 파일 하나로 깔끔하게 저장 |
| 디스크 I/O 사용량이 적음 |

---

#### 2\. AOF (Append Only File)

-   Redis에 **명령어가 들어올 때마다** 그 명령을 파일에 추가로 기록  
    ex) \`SET user:1 "Alice" → 그대로 AOF에 기록
-   재시작 시 **AOF를 한 줄씩 재실행해서 상태 복원**

| **장점** | **단점** |
| --- | --- |
| 안정적이고 안전함   (모든 변경 사항이 기록되므로 데이터 손실 少) | 파일 크기가 빠르게 커질 수 있음 |
| 실시간에 가까운 데이터 복구 가능 | 복구 시 시간이 오래 걸릴 수 있음 |

#### 실무에선 어떻게 쓸까

두 방식 동시에 사용할 수 있음  
👉 Redis는 재시작 시 AOF 우선 복구, RDB는 백업용으로 사용

```
# redis.conf 설정 예시
save 900 1         # 15분에 1개 이상 변경 시 RDB 저장
appendonly yes     # AOF 사용 설정
```

---

## Redis TTL

Redis는 TTL을 **설정한 키를 자동으로 만료하고 삭제**함

이를 통해 캐시, 세션, 임시 데이터 등을 효율적으로 관리할 수 있음

> \`TTL\`(Time To Live): 키가 살아 있는 시간

---

### 예시: TTL 사용 방법

```
# 키 설정 + 만료시간 함께 지정 (EX: 10초)
SET mykey "hello" EX 10

# 또는 따로 TTL 설정
SET mykey "hello"
EXPIRE mykey 10

# TTL 조회 (남은 시간, 단위: 초)
TTL mykey
# → 예: 8

# 키가 만료되면 자동 삭제됨
GET mykey
# → (nil)
```

| **명령어** |  **설명** |
| --- | --- |
| EXPIRE key seconds | 해당 키를 N초 뒤에 삭제 |
| PEXPIRE key milliseconds | N밀리초 뒤에 삭제 |
| TTL key | 남은 TTL을 초 단위로 반환 |
| PTTL key | 남은 TTL을 밀리초 단위로 반환 |
| PERSIST key | TTL 제거 → 영구 보존 |
| DEL key | 키 즉시 삭제 |

---

### 내부 동작 원리

Redis는 아래와 같은 두 가지 방식으로 만료 키를 삭제

1.  **\`Lazy 방식\`**: 키를 \`GET\` 하거나 접근 시 만료 여부 확인 및 삭제
2.  **\`Active 방식\`**: 백그라운드에서 주기적으로 만료된 키를 찾아 삭제

👉 정확히 N초 후에 무조건 삭제되지 않을 수 있다는 뜻 (거의 실시간처럼 작동하나 100%는 아님)

> **📌 예시  
> **
> 
> -   **세션 데이터:** 로그인 세션: 30분 뒤 만료
> -   **인증 코드 / OTP:** 문자 인증 번호: 3분 뒤 자동 삭제
> -   **임시 캐시:** 자주 조회되는 데이터만 잠

---

## 캐시 무효화 전략

캐시 무효화 전략을 크게 아래 세 가지로 나뉨

| **전략** | **설명** |
| --- | --- |
| **수동 무효화 (Manual / Explicit)** | 애플리케이션 로직에서 직접 캐시 삭제 |
| **TTL 기반 무효화**  | TTL을 설정해 일정 시간 후 자동 삭제 |
| **자동 무효화 (Eviction)   ** | 메모리가 부족할 때 설정된 정책에 따라 자동 삭제 |

### Redis의 자동 캐시 무효화 ( = Eviction Policy)

메모리 한도를 설정한 경우, Redis는 자동으로 키를 제거하여 메모리를 확보하는데 아래와 같은 정책들이 있음

```
maxmemory-policy
```

-   **\`noeviction\`**: 더 이상 저장하지 않고 **오류** 반환
-   **\`allkeys-lru\`**: 가장 오래 사용되지 않은 키부터 제거 (LRU)
-   **\`volatile-lru\`:** TTL이 설정된 키 중 LRU 제거
-   **\`volatile-ttl\`:** TTL이 설정된 키 중 가장 만료에 가까운 키 제거
-   **\`volatile-random\`:** TTL이 설정된 키 중 랜덤 제거
-   **\`allkeys-random\`**: 무작위 키 제거

---

### 캐시 무효화 전략이 중요한 이유

오래된 데이터를 계속 들고 있는 건 무의미하고, 새로운 데이터를 빠르게 반영하려면 타이밍 조절이 필요함

**캐시가 너무 커지면 Redis가 메모리 폭주, 성능 저하**로 귀결

∴ \`TTL + Eviction\` 을 잘 조합하는 것이 중요함

---

#### **🔥 메모리 폭주**

Redis에 캐시나 데이터를 계속 저장하는데 TTL, 삭제 정책, maxmemory 설정도 안 되어 있는 경우

→ 메모리에 저장되는 데이터는 쌓여감  
→ 서버의 RAM 한계를 초과함  
→ Redis가 다운되거나 시스템 전체가 느려지거나, OS가 프로세스를 강제 종료

이에 따라 아래와 같은 상황이 발생

#### 1\. Redis 자체 성능 저하

-   Redis는 **모든 연산을 메모리 기반으로** 하기 때문에, 메모리가 부족하면 메모리 할당/복사 등이 느려져서 성능 하락
-   대량의 키를 보유한 상태에서 **백업(RDB/AOF)** 할 경우 디스크 I/O도 폭주

#### 2\. 시스템 전체 불안정

-   Redis는 서버 메모리를 대부분 차지함
-   다른 애플리케이션, OS 커널 등이 사용할 메모리가 부족해짐
-   최악의 경우 OS가 Redis 프로세스를 **OOM(Out Of Memory) Killer**로 종료

---

### ❓  Redis는 메모리를 더 조심히 다뤄야 하는 이유

디스크 기반 DB는 저장공간이 부족해도 느려질 뿐임

Redis는 메모리 기반이라 RAM이 꽉 차면 터져버림

👉 TTL을 설정하지 않으면 키는 절대 사라지지 않음

---

#### 메모리 폭주 방지하는 법

| **방법** | **설명** |
| --- | --- |
| maxmemory 설정 | 사용할 메모리 최대치를 제한 |
| maxmemory-policy 설정 | 넘었을 때 어떤 데이터를 제거할지 정의 |
| TTL 사용 | 불필요한 키는 일정 시간 후 자동 삭제 |
| 캐시 키의 크기 제어 | 너무 많은 데이터 or 너무 큰 값을 저장하지 않도록 제한 |
| 모니터링 도구 사용 | INFO MEMORY, Grafana, RedisInsight 등으로 메모리 사용량 체크 |

#### 예시 설정

```
maxmemory 512mb # 메모리는 최대 512MB
maxmemory-policy allkeys-lru	# 꽉 차면 오래 안 쓰인 키부터 자동 삭제
```

---

여러 사용자가 동시에 같은 데이터를 수정하려고 할 때 경쟁 조건이 발생하는 경우 Redis는 어떻게 대처할까?

Redis는 경쟁 조건을 방지하기 위해 두 가지 접근 방식인  **Optimistic Lock**, **Pessimistic Lock** 을 사용한다.

| **시나리오** | **전략** | **이유** |
| --- | --- | --- |
| 재고 감소, 좋아요 수 증가 | Optimistic | 충돌 적고 성능 중요 |
| 결제, 티켓팅, 중복 요청 방지 | Pessimistic | 무조건 1개만 처리해야 함 |

---

## Optimistic Lock (낙관적 락)

문제가 발생하지 않을 것이라는 낙관적인 개념으로  
동시 접근을 허용하되, **마지막에 충돌이 발생하면 롤백**하는 방식이다.

Redis에서는 \`WATCH\`, \`MULTI\`, \`EXEC\` 명령어를 사용하여 구현한다.

**특징**

| **항목** | **설명** |
| --- | --- |
| **장점** | 락을 사용하지 않아 빠르고 병렬 처리에 유리 |
| **단점** | 충돌이 많으면 retry로 인해 성능 저하 |
| **적합한 경우** | 업데이트 충돌 가능성이 낮은 경우 |

**구현 방식**

```
WATCH mykey           # mykey를 감시 시작
MULTI                 # 트랜잭션 시작
SET mykey "new-value" # 여러 명령어를 큐에 담음
EXEC                  # 트랜잭션 실행 (다른 클라이언트가 mykey를 바꿨다면 실패)
```

**WATCH 이후 다른 클라이언트가 mykey를 변경**하면 EXEC 실행 시 **트랜잭션은 실패**한다. (롤백)  
👉 실패 시 **다시 시도(**retry) 한다

---

## Pessimistic Lock (비관적 락)

문제가 발생할 것이라는 비관적 개념으로  
공유자원에 접근하는 동안 다른 사용자의 접근을 막는다.

Redis에서는 \`SENTX\` 나 \`Redlock\` 알고리즘으로 구현한다.

**특징**

| **항목** | **설명** |
| --- | --- |
| **장점** | 경쟁 없이 안전하게 자원을 보호 |
| **단점** | 락 획득/해제 비용, 데드락 위험 |
| **적합한 경우** | 공유 자원에 대한 충돌 가능성이 높고 꼭 순서를 보장해야 하는 경우 |

**구현 방식 (SENTX)**

```
SETNX lock_key "locked"   # 락 획득 시 1 반환 (성공)
EXPIRE lock_key 10        # 타임아웃 설정 (10초)
...                       # 자원 사용
DEL lock_key              # 락 해제
```

---

## Redlock 알고리즘 (비관적 락)

단일 Redis 서버에서 SENTX로 락을 구현 시 Redis 서버가 다운되면 락 자체도 유실되어 신뢰성이 떨어진다.

∴ 분산 환경에서는 **여러 Redis 노드에 락을 동시에 걸고, 일부가 실패해도 안전하게 락을 유지**해야 한다.

> **📌 작동 원리**  
> N개의 서로 다른 Redis 인스턴스 중에서 **과반수 이상** (M)에게 락을 성공적으로 설정하면 **락 획득 성공**으로 간주  
> \`M = N/2+1\` (보통 N=5, M=3)

| **특성** | 설명 |
| --- | --- |
| **Safety (안전성)** | 오직 하나의 클라이언트만 락을 획득할 수 있음 |
| **Liveness (활성성)** | 일부 Redis 노드가 실패하더라도 락을 획득 가능 |
| **Fault-tolerance (내결함성)** | 다수 노드가 살아있으면 시스템은 정상 동작 |

---

#### 락 획득 과정

1.  현재 시간 기록 (밀리초 기준)
2.  모든 Redis 인스턴스에 동일 key, 동일 value로 락 시도
    -   예: SET lock\_key value NX PX 10000  
        (NX: 해당 키가 존재하지 않을 때만 설정, PX: TTL 10초)
3.  응답을 받은 Redis 인스턴스가 M 이상인지 check
4.  총 소요 시간이 TTL 보다 작을 경우 락 획득 성공
5.  실패하면 전체 락 해제 후 재시도 (retry with backoff)

---

#### 락 해제 과정

락을 해제할 때는 반드시 **락을 설정한 사용자만 해제**할 수 있어야 한다.

락 설정 시 사용하는 랜덤한 고유 값 (UUID 등)을 저장해 두었다가, 락 해제 시 key의 value값이 동일한 경우만 삭제한다.

```
-- Lua 스크립트 예시 (atomic하게 수행)
if redis.call("get", KEYS[1]) == ARGV[1] then
  return redis.call("del", KEYS[1])
else
  return 0
end
```

---

#### 결론

**Redlock은 단일 Redis 인스턴스 기반 락보다 훨씬 안전한 락 시스템**이며, 특히 다음과 같은 경우에 적합하다.

-   **분산 시스템 환경** (여러 서버에서 동시에 접근)
-   **락이 반드시 정확하게 지켜져야 하는 경우** (예: 주문 중복 방지, 결제 동시 처리)

| **항목**  | **안전하게 락 처리하려면** |
| --- | --- |
| **TTL** | 무조건 설정 (자동 해제용) |
| **UUID** | 락 소유자 식별을 위해 사용 |
| **비정상 종료** | TTL로 방지, UUID로 정확히 해제 |
| **장기 작업** | 필요 시 락 연장 로직 구현 |

---

### ❓ 응답을 받은 Redis 인스턴스가 M 미만 

락을 시도했는데, 성공한 Redis 인스턴스 수가 과반수보다 작은 상황

분산 시스템에서는 일부 노드가 네트워크 단절되거나 느려질 수 있기 때문에  
과반수 이상이 동의하지 않으면 \`**안전하지 않은 락**\`일 수 있다고 간주한다.

만일 과반수를 넘지 못하는 락을 신뢰한다면:

-   다른 클라이언트도 락을 잡았다고 착각 가능
-   동시에 같은 자원에 접근하여 Race Condition 발생 가능

---

### ❓ 락을 얻은 총 소요시간 ≥ TTL 

락이 획득되긴 했지만, 그 시점엔 이미 TTL이 거의 끝났거나 지나서 자원 보호가 되지 않는 상황  
👉 안전하지 않은 락이므로 실패로 간주한다.

#### 예시

-   TTL: 10,000ms (10초)
-   Redis  5개 중 3개에서 락을 성공적으로 설정
-   3개에서 락을 모두 얻는 데 걸린 시간: 11,000ms (> TTL)

락을 설정한 시점은 서로 다르고 각 Redis 인스턴스는 락을 잡은 후부터 TTL만큼만 유지  
즉, **락을 설정한 순간부터 각 노드는 10초 후에 자동으로 락을 해제**한다.

| 노드 | 락 설정 시간 | TTL 만료 시간 |
| --- | --- | --- |
| Redis A | 0ms | **10,000ms** |
| Redis B | 5,000ms | 15,000ms |
| Redis C | 11,000ms | 21,000ms |

→ 락을 11초에 얻었지만, Redis A에서는 이미 **TTL이 만료됨**  
→ 다른 클라이언트는 **Redis A에서 락이 해제된 것으로 보고 다시 락을 잡을 수 있음**

🟥 그러면 **두 클라이언트가 동시에 자원에 접근하는 Race Condition이 발생할 수 있음**

> 📌 락을 잡는 데 걸린 시간이 TTL 보다 길면, 락을 실패로 간주하고 즉시 해제 수 재시도해야 한다.

---

## DeadLock

클라이언트가 **락을 잡고 작업 중 죽거나 네트워크 단절**되는 경우, 락을 해제하지 못하게 되는데  
이런 상태에서 락이 계속 유지되면 다른 클라이언트가 접근하지 못한다. 👉 데드락 발생

### Redis 분산 락에서 Deadlock 예방/회피 방법

| **방법** | **설명** |
| --- | --- |
| **TTL 설정** | 락 자동 만료로 데드락 방지 |
| **UUID 사용** | 락 소유자 확인으로 안전한 해제 |
| **재시도 + 백오프** | 랜덤 시간 대기 후 재시도 → 과도한 경합으로 인한 데드락 가능성 감소 |
| **락 순서 고정** | 교착 상태 순환 대기 방지 |
| **락 연장 (신중)** | 긴 작업 시 락 유효 기간 연장 |
| **최소 락 시간** | 락 획득 기간 최소화 |

